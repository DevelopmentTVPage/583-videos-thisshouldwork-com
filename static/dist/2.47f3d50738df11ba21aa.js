tvpageJsonp([2],{

/***/ 325:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _react = __webpack_require__(1);\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _reactInteractive = __webpack_require__(414);\n\nvar _reactInteractive2 = _interopRequireDefault(_reactInteractive);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar ClampLines = function (_Component) {\n  _inherits(ClampLines, _Component);\n\n  function ClampLines(props) {\n    _classCallCheck(this, ClampLines);\n\n    var _this = _possibleConstructorReturn(this, (ClampLines.__proto__ || Object.getPrototypeOf(ClampLines)).call(this, props));\n\n    _this.element = null;\n    _this.original = props.text;\n    _this.watch = true;\n    _this.lineHeight = 0;\n    _this.start = 0;\n    _this.middle = 0;\n    _this.end = 0;\n    _this.state = {\n      noClamp: false,\n      text: \".\"\n    };\n\n    _this.action = _this.action.bind(_this);\n    _this.clickHandler = _this.clickHandler.bind(_this);\n\n    _this.debounced = _this.debounce(_this.action, props.delay);\n    return _this;\n  }\n\n  _createClass(ClampLines, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      if (this.props.text) {\n        this.lineHeight = this.element.clientHeight + 1;\n        this.clampLines();\n\n        if (this.watch) {\n          window.addEventListener('resize', this.debounced);\n        }\n      }\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      window.removeEventListener('resize', this.debounced);\n      this.action = null;\n      this.clickHandler = null;\n    }\n  }, {\n    key: \"shouldComponentUpdate\",\n    value: function shouldComponentUpdate(nextProps, nextState) {\n      if (this.original !== nextProps.text && this.element) {\n        this.original = nextProps.text;\n        this.setState({\n          text: \".\"\n        });\n        this.lineHeight = this.element.clientHeight + 1;\n        this.debounced();\n      }\n      return true;\n    }\n  }, {\n    key: \"debounce\",\n    value: function debounce(func, wait, immediate) {\n      var _this2 = this,\n          _arguments = arguments;\n\n      var timeout = void 0;\n\n      return function () {\n        var context = _this2,\n            args = _arguments;\n        var later = function later() {\n          timeout = null;\n          if (!immediate) func.apply(context, args);\n        };\n        var callNow = immediate && !timeout;\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) func.apply(context, args);\n      };\n    }\n  }, {\n    key: \"action\",\n    value: function action() {\n      if (this.watch) {\n        this.setState({ noClamp: false });\n        this.clampLines();\n      }\n    }\n  }, {\n    key: \"clampLines\",\n    value: function clampLines() {\n      this.setState({ text: '' });\n\n      var maxHeight = this.lineHeight * this.props.lines + 1;\n      this.start = 0;\n      this.middle = 0;\n      this.end = this.original.length;\n\n      while (this.start <= this.end) {\n        this.middle = Math.floor((this.start + this.end) / 2);\n        this.element.innerText = this.original.slice(0, this.middle);\n        if (this.middle === this.original.length) {\n          this.setState({\n            text: this.original,\n            noClamp: true\n          });\n          return;\n        }\n\n        this.moveMarkers(maxHeight);\n      }\n\n      this.element.innerText = this.original.slice(0, this.middle - 5) + this.getEllipsis();\n      this.setState({ text: this.original.slice(0, this.middle - 5) + this.getEllipsis() });\n    }\n  }, {\n    key: \"moveMarkers\",\n    value: function moveMarkers(maxHeight) {\n      if (this.element.clientHeight <= maxHeight) {\n        this.start = this.middle + 1;\n      } else {\n        this.end = this.middle - 1;\n      }\n    }\n  }, {\n    key: \"getClassName\",\n    value: function getClassName() {\n      var className = this.props.className || '';\n\n      return \"clamp-lines \" + className;\n    }\n  }, {\n    key: \"getEllipsis\",\n    value: function getEllipsis() {\n      return this.watch && !this.state.noClamp ? this.props.ellipsis : '';\n    }\n  }, {\n    key: \"getButton\",\n    value: function getButton() {\n      if (this.state.noClamp || !this.props.buttons) return;\n\n      var buttonText = this.watch ? this.props.moreText : this.props.lessText;\n\n      return _react2.default.createElement(\n        \"div\",\n        { className: \"tvp-show-more text-center\" },\n        _react2.default.createElement(\n          \"button\",\n          { className: \"clamp-lines__button\", onClick: this.clickHandler },\n          buttonText\n        )\n      );\n    }\n  }, {\n    key: \"clickHandler\",\n    value: function clickHandler(e) {\n      e.preventDefault();\n\n      this.watch = !this.watch;\n      this.watch ? this.clampLines() : this.setState({ text: this.original });\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this3 = this;\n\n      if (!this.props.text) {\n        return null;\n      }\n      var buttonText = this.watch ? this.props.moreText : this.props.lessText;\n      return _react2.default.createElement(\n        \"div\",\n        { className: this.getClassName() },\n        _react2.default.createElement(\n          \"div\",\n          { ref: function ref(e) {\n              _this3.element = e;\n            } },\n          this.state.text\n        ),\n        !this.state.noClamp && _react2.default.createElement(\n          \"div\",\n          { className: \"tvp-show-more text-center\" },\n          _react2.default.createElement(\n            _reactInteractive2.default,\n            { as: \"button\", className: \"clamp-lines__button\", normal: { className: \"tvp-normal\" }, hover: { className: \"tvp-hovered\" }, touchActive: { className: \"tvp-hovered\" }, onClick: this.clickHandler },\n            buttonText\n          )\n        )\n      );\n    }\n  }]);\n\n  return ClampLines;\n}(_react.Component);\n\nexports.default = ClampLines;\n\n\nClampLines.defaultProps = {\n  buttons: true,\n  lines: 3,\n  delay: 300,\n  ellipsis: '...',\n  moreText: 'Read more',\n  lessText: 'Read less'\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzI1LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL3NyYy9saWJzL3JlYWN0LWNsYW1wLWxpbmVzLmpzPzZiZDciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBJbnRlcmFjdGl2ZSBmcm9tIFwicmVhY3QtaW50ZXJhY3RpdmVcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ2xhbXBMaW5lcyBleHRlbmRzIENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuXG4gICAgdGhpcy5lbGVtZW50ID0gbnVsbDtcbiAgICB0aGlzLm9yaWdpbmFsID0gcHJvcHMudGV4dDtcbiAgICB0aGlzLndhdGNoID0gdHJ1ZTtcbiAgICB0aGlzLmxpbmVIZWlnaHQgPSAwO1xuICAgIHRoaXMuc3RhcnQgPSAwO1xuICAgIHRoaXMubWlkZGxlID0gMDtcbiAgICB0aGlzLmVuZCA9IDA7XG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIG5vQ2xhbXA6IGZhbHNlLFxuICAgICAgdGV4dDogXCIuXCJcbiAgICB9O1xuXG4gICAgdGhpcy5hY3Rpb24gPSB0aGlzLmFjdGlvbi5iaW5kKHRoaXMpO1xuICAgIHRoaXMuY2xpY2tIYW5kbGVyID0gdGhpcy5jbGlja0hhbmRsZXIuYmluZCh0aGlzKTtcblxuICAgIHRoaXMuZGVib3VuY2VkID0gdGhpcy5kZWJvdW5jZSh0aGlzLmFjdGlvbiwgcHJvcHMuZGVsYXkpO1xuICB9XG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIGlmICh0aGlzLnByb3BzLnRleHQpIHtcbiAgICAgIHRoaXMubGluZUhlaWdodCA9IHRoaXMuZWxlbWVudC5jbGllbnRIZWlnaHQgKyAxO1xuICAgICAgdGhpcy5jbGFtcExpbmVzKCk7XG5cbiAgICAgIGlmICh0aGlzLndhdGNoKSB7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLmRlYm91bmNlZCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMuZGVib3VuY2VkKTtcbiAgICB0aGlzLmFjdGlvbiA9IG51bGw7XG4gICAgdGhpcy5jbGlja0hhbmRsZXIgPSBudWxsO1xuICB9XG4gIHNob3VsZENvbXBvbmVudFVwZGF0ZShuZXh0UHJvcHMsbmV4dFN0YXRlKXtcbiAgICBpZih0aGlzLm9yaWdpbmFsICE9PSBuZXh0UHJvcHMudGV4dCAmJiB0aGlzLmVsZW1lbnQpe1xuICAgICAgdGhpcy5vcmlnaW5hbCA9IG5leHRQcm9wcy50ZXh0O1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIHRleHQ6IFwiLlwiXG4gICAgICB9KTtcbiAgICAgIHRoaXMubGluZUhlaWdodCA9IHRoaXMuZWxlbWVudC5jbGllbnRIZWlnaHQgKyAxO1xuICAgICAgdGhpcy5kZWJvdW5jZWQoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZGVib3VuY2UoZnVuYywgd2FpdCwgaW1tZWRpYXRlKSB7XG4gICAgbGV0IHRpbWVvdXQ7XG5cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgbGV0IGNvbnRleHQgPSB0aGlzLCBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgbGV0IGxhdGVyID0gKCkgPT4ge1xuICAgICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgaWYgKCFpbW1lZGlhdGUpIGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICB9O1xuICAgICAgbGV0IGNhbGxOb3cgPSBpbW1lZGlhdGUgJiYgIXRpbWVvdXQ7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgd2FpdCk7XG4gICAgICBpZiAoY2FsbE5vdykgZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICB9O1xuICB9O1xuXG4gIGFjdGlvbigpIHtcbiAgICBpZiAodGhpcy53YXRjaCkge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7IG5vQ2xhbXA6IGZhbHNlIH0pO1xuICAgICAgdGhpcy5jbGFtcExpbmVzKCk7XG4gICAgfVxuICB9XG5cbiAgY2xhbXBMaW5lcygpIHtcbiAgICB0aGlzLnNldFN0YXRlKHsgdGV4dDogJycgfSk7XG5cbiAgICBsZXQgbWF4SGVpZ2h0ID0gdGhpcy5saW5lSGVpZ2h0ICogdGhpcy5wcm9wcy5saW5lcyArIDE7XG4gICAgdGhpcy5zdGFydCA9IDA7XG4gICAgdGhpcy5taWRkbGUgPSAwO1xuICAgIHRoaXMuZW5kID0gdGhpcy5vcmlnaW5hbC5sZW5ndGg7XG5cbiAgICB3aGlsZSAodGhpcy5zdGFydCA8PSB0aGlzLmVuZCkge1xuICAgICAgdGhpcy5taWRkbGUgPSBNYXRoLmZsb29yKCh0aGlzLnN0YXJ0ICsgdGhpcy5lbmQpIC8gMik7XG4gICAgICB0aGlzLmVsZW1lbnQuaW5uZXJUZXh0ID0gdGhpcy5vcmlnaW5hbC5zbGljZSgwLCB0aGlzLm1pZGRsZSk7XG4gICAgICBpZiAodGhpcy5taWRkbGUgPT09IHRoaXMub3JpZ2luYWwubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgIHRleHQ6IHRoaXMub3JpZ2luYWwsXG4gICAgICAgICAgbm9DbGFtcDogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5tb3ZlTWFya2VycyhtYXhIZWlnaHQpO1xuICAgIH1cblxuICAgIHRoaXMuZWxlbWVudC5pbm5lclRleHQgPSB0aGlzLm9yaWdpbmFsLnNsaWNlKDAsIHRoaXMubWlkZGxlIC0gNSkgKyB0aGlzLmdldEVsbGlwc2lzKCk7XG4gICAgdGhpcy5zZXRTdGF0ZSh7IHRleHQ6IHRoaXMub3JpZ2luYWwuc2xpY2UoMCwgdGhpcy5taWRkbGUgLSA1KSArIHRoaXMuZ2V0RWxsaXBzaXMoKSB9KTtcbiAgfVxuXG4gIG1vdmVNYXJrZXJzKG1heEhlaWdodCkge1xuICAgIGlmICh0aGlzLmVsZW1lbnQuY2xpZW50SGVpZ2h0IDw9IG1heEhlaWdodCkge1xuICAgICAgdGhpcy5zdGFydCA9IHRoaXMubWlkZGxlICsgMTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5lbmQgPSB0aGlzLm1pZGRsZSAtIDE7XG4gICAgfVxuICB9XG5cbiAgZ2V0Q2xhc3NOYW1lKCkge1xuICAgIGxldCBjbGFzc05hbWUgPSB0aGlzLnByb3BzLmNsYXNzTmFtZSB8fCAnJztcblxuICAgIHJldHVybiBgY2xhbXAtbGluZXMgJHtjbGFzc05hbWV9YDtcbiAgfVxuXG4gIGdldEVsbGlwc2lzKCkge1xuICAgIHJldHVybiB0aGlzLndhdGNoICYmICF0aGlzLnN0YXRlLm5vQ2xhbXAgPyB0aGlzLnByb3BzLmVsbGlwc2lzIDogJyc7XG4gIH1cblxuICBnZXRCdXR0b24oKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUubm9DbGFtcCB8fCAhdGhpcy5wcm9wcy5idXR0b25zKSByZXR1cm47XG5cbiAgICBsZXQgYnV0dG9uVGV4dCA9IHRoaXMud2F0Y2ggPyB0aGlzLnByb3BzLm1vcmVUZXh0IDogdGhpcy5wcm9wcy5sZXNzVGV4dDtcblxuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cInR2cC1zaG93LW1vcmUgdGV4dC1jZW50ZXJcIj5cbiAgICAgIDxidXR0b24gY2xhc3NOYW1lPVwiY2xhbXAtbGluZXNfX2J1dHRvblwiIG9uQ2xpY2s9e3RoaXMuY2xpY2tIYW5kbGVyfT5cbiAgICAgICAge2J1dHRvblRleHR9XG4gICAgICA8L2J1dHRvbj5cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cblxuICBjbGlja0hhbmRsZXIoZSkge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgIHRoaXMud2F0Y2ggPSAhdGhpcy53YXRjaDtcbiAgICB0aGlzLndhdGNoID8gdGhpcy5jbGFtcExpbmVzKCkgOiB0aGlzLnNldFN0YXRlKHsgdGV4dDogdGhpcy5vcmlnaW5hbCB9KTtcbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICBpZiAoIXRoaXMucHJvcHMudGV4dCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGxldCBidXR0b25UZXh0ID0gdGhpcy53YXRjaCA/IHRoaXMucHJvcHMubW9yZVRleHQgOiB0aGlzLnByb3BzLmxlc3NUZXh0O1xuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGNsYXNzTmFtZT17dGhpcy5nZXRDbGFzc05hbWUoKX0+XG4gICAgICAgIDxkaXYgcmVmPXtlID0+IHsgdGhpcy5lbGVtZW50ID0gZTsgfX0+XG4gICAgICAgICAgICB7dGhpcy5zdGF0ZS50ZXh0fVxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgeyAoIXRoaXMuc3RhdGUubm9DbGFtcCkgJiZcbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInR2cC1zaG93LW1vcmUgdGV4dC1jZW50ZXJcIj5cbiAgICAgICAgICA8SW50ZXJhY3RpdmUgYXM9XCJidXR0b25cIiBjbGFzc05hbWU9XCJjbGFtcC1saW5lc19fYnV0dG9uXCIgbm9ybWFsPXt7Y2xhc3NOYW1lOlwidHZwLW5vcm1hbFwifX0gaG92ZXI9e3tjbGFzc05hbWU6XCJ0dnAtaG92ZXJlZFwifX0gdG91Y2hBY3RpdmU9e3tjbGFzc05hbWU6XCJ0dnAtaG92ZXJlZFwifX0gb25DbGljaz17dGhpcy5jbGlja0hhbmRsZXJ9PlxuICAgICAgICAgICAge2J1dHRvblRleHR9XG4gICAgICAgICAgPC9JbnRlcmFjdGl2ZT5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgfVxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxufVxuXG5DbGFtcExpbmVzLmRlZmF1bHRQcm9wcyA9IHtcbiAgYnV0dG9uczogdHJ1ZSxcbiAgbGluZXM6IDMsXG4gIGRlbGF5OiAzMDAsXG4gIGVsbGlwc2lzOiAnLi4uJyxcbiAgbW9yZVRleHQ6ICdSZWFkIG1vcmUnLFxuICBsZXNzVGV4dDogJ1JlYWQgbGVzcydcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2xpYnMvcmVhY3QtY2xhbXAtbGluZXMuanMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDQTs7O0FBQUE7QUFDQTs7Ozs7Ozs7Ozs7QUFDQTs7O0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBbEJBO0FBbUJBO0FBQ0E7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFEQTtBQU1BOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBREE7QUFMQTtBQWFBOzs7Ozs7QUEzSkE7QUFDQTtBQUNBO0FBNEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///325\n");

/***/ }),

/***/ 367:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.childInteractiveProps = exports.defaultTapTimeCutoff = exports.queueTime = exports.knownProps = exports.knownRoleTags = exports.nonBlurrableTags = exports.statePropOptionKeys = exports.stateProps = exports.iStates = exports.otherEvents = exports.touchEvents = exports.mouseEvents = exports.passiveEventSupport = exports.deviceHasMouse = exports.deviceHasTouch = exports.deviceType = undefined;\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nexports.enterKeyTrigger = enterKeyTrigger;\nexports.spaceKeyTrigger = spaceKeyTrigger;\nexports.dummyEvent = dummyEvent;\n\nvar _detectIt = __webpack_require__(416);\n\nvar _detectIt2 = _interopRequireDefault(_detectIt);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar deviceType = exports.deviceType = _detectIt2.default.deviceType;\nvar deviceHasTouch = exports.deviceHasTouch = _detectIt2.default.hasTouch;\nvar deviceHasMouse = exports.deviceHasMouse = _detectIt2.default.hasMouse;\nvar passiveEventSupport = exports.passiveEventSupport = _detectIt2.default.passiveEvents;\n\nvar mouseEvents = exports.mouseEvents = {\n  mouseenter: 'onMouseEnter',\n  mouseleave: 'onMouseLeave',\n  mousemove: 'onMouseMove',\n  mousedown: 'onMouseDown',\n  mouseup: 'onMouseUp'\n};\n\nvar touchEvents = exports.touchEvents = {\n  touchstart: 'onTouchStart',\n  touchend: 'onTouchEnd',\n  touchcancel: 'onTouchCancel'\n};\n\nvar otherEvents = exports.otherEvents = {\n  focus: 'onFocus',\n  blur: 'onBlur',\n  keydown: 'onKeyDown',\n  keyup: 'onKeyUp',\n  dragstart: 'onDragStart',\n  dragend: 'onDragEnd'\n};\n\nvar iStates = exports.iStates = {\n  normal: true,\n  hover: true,\n  hoverActive: true,\n  touchActive: true,\n  keyActive: true\n};\n\nvar stateProps = exports.stateProps = _extends({}, iStates, {\n  active: true,\n  focus: true,\n  focusFromTab: true,\n  focusFromMouse: true,\n  focusFromTouch: true\n});\n\nvar statePropOptionKeys = exports.statePropOptionKeys = ['style', 'className'];\n\n// don't toggle focus on these tags\nvar nonBlurrableTags = exports.nonBlurrableTags = {\n  input: true,\n  textarea: true,\n  select: true\n};\n\n// tags with known roles, and that the browser may have a click handler for\nvar knownRoleTags = exports.knownRoleTags = _extends({}, nonBlurrableTags, {\n  button: true,\n  a: true,\n  area: true\n});\n\n// elements triggered by the enter key\nfunction enterKeyTrigger(tag, type) {\n  return tag !== 'select' && (tag !== 'input' || type !== 'checkbox' && type !== 'radio');\n}\n\n// elements triggered by the space bar\nfunction spaceKeyTrigger(tag, type) {\n  return tag === 'button' || tag === 'select' || tag === 'input' && (type === 'checkbox' || type === 'radio' || type === 'submit');\n}\n\n// known props to not pass through, every prop not on this list is passed through\nvar knownProps = exports.knownProps = _extends({}, stateProps, {\n  children: true,\n  as: true,\n  style: true,\n  className: true,\n  wrapperStyle: true,\n  wrapperClassName: true,\n  onStateChange: true,\n  setStateCallback: true,\n  onClick: true,\n  onTapTwo: true,\n  onTapThree: true,\n  onTapFour: true,\n  onLongPress: true,\n  tapTimeCutoff: true,\n  onMouseEnter: true,\n  onMouseLeave: true,\n  onMouseMove: true,\n  onMouseDown: true,\n  onMouseUp: true,\n  onTouchStart: true,\n  onTouchMove: true,\n  onTouchEnd: true,\n  onTouchCancel: true,\n  onFocus: true,\n  onBlur: true,\n  onKeyDown: true,\n  onKeyUp: true,\n  forceState: true,\n  initialState: true,\n  refDOMNode: true,\n  mutableProps: true,\n  useBrowserOutlineFocus: true,\n  useBrowserCursor: true,\n  touchActiveTapOnly: true,\n  extraTouchNoTap: true,\n  focusToggleOff: true,\n  stylePriority: true,\n  nonContainedChild: true,\n  interactiveChild: true\n});\n\n// ms to allow for the browser to add subsequent event to the queue in setTimeouts\nvar queueTime = exports.queueTime = 600;\n\nvar defaultTapTimeCutoff = exports.defaultTapTimeCutoff = 500;\n\nfunction dummyEvent(type) {\n  return {\n    type: type,\n    persist: function persist() {},\n    preventDefault: function preventDefault() {},\n    stopPropagation: function stopPropagation() {}\n  };\n}\n\nvar childInteractiveProps = exports.childInteractiveProps = {\n  showOnParent: true,\n  onParentNormal: true,\n  onParentHover: true,\n  onParentActive: true,\n  onParentHoverActive: true,\n  onParentTouchActive: true,\n  onParentKeyActive: true,\n  onParentFocus: true,\n  onParentFocusFromTab: true,\n  onParentFocusFromMouse: true,\n  onParentFocusFromTouch: true\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzY3LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWludGVyYWN0aXZlL2xpYi9jb25zdGFudHMuanM/ZWI1NSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmNoaWxkSW50ZXJhY3RpdmVQcm9wcyA9IGV4cG9ydHMuZGVmYXVsdFRhcFRpbWVDdXRvZmYgPSBleHBvcnRzLnF1ZXVlVGltZSA9IGV4cG9ydHMua25vd25Qcm9wcyA9IGV4cG9ydHMua25vd25Sb2xlVGFncyA9IGV4cG9ydHMubm9uQmx1cnJhYmxlVGFncyA9IGV4cG9ydHMuc3RhdGVQcm9wT3B0aW9uS2V5cyA9IGV4cG9ydHMuc3RhdGVQcm9wcyA9IGV4cG9ydHMuaVN0YXRlcyA9IGV4cG9ydHMub3RoZXJFdmVudHMgPSBleHBvcnRzLnRvdWNoRXZlbnRzID0gZXhwb3J0cy5tb3VzZUV2ZW50cyA9IGV4cG9ydHMucGFzc2l2ZUV2ZW50U3VwcG9ydCA9IGV4cG9ydHMuZGV2aWNlSGFzTW91c2UgPSBleHBvcnRzLmRldmljZUhhc1RvdWNoID0gZXhwb3J0cy5kZXZpY2VUeXBlID0gdW5kZWZpbmVkO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5leHBvcnRzLmVudGVyS2V5VHJpZ2dlciA9IGVudGVyS2V5VHJpZ2dlcjtcbmV4cG9ydHMuc3BhY2VLZXlUcmlnZ2VyID0gc3BhY2VLZXlUcmlnZ2VyO1xuZXhwb3J0cy5kdW1teUV2ZW50ID0gZHVtbXlFdmVudDtcblxudmFyIF9kZXRlY3RJdCA9IHJlcXVpcmUoJ2RldGVjdC1pdCcpO1xuXG52YXIgX2RldGVjdEl0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2RldGVjdEl0KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIGRldmljZVR5cGUgPSBleHBvcnRzLmRldmljZVR5cGUgPSBfZGV0ZWN0SXQyLmRlZmF1bHQuZGV2aWNlVHlwZTtcbnZhciBkZXZpY2VIYXNUb3VjaCA9IGV4cG9ydHMuZGV2aWNlSGFzVG91Y2ggPSBfZGV0ZWN0SXQyLmRlZmF1bHQuaGFzVG91Y2g7XG52YXIgZGV2aWNlSGFzTW91c2UgPSBleHBvcnRzLmRldmljZUhhc01vdXNlID0gX2RldGVjdEl0Mi5kZWZhdWx0Lmhhc01vdXNlO1xudmFyIHBhc3NpdmVFdmVudFN1cHBvcnQgPSBleHBvcnRzLnBhc3NpdmVFdmVudFN1cHBvcnQgPSBfZGV0ZWN0SXQyLmRlZmF1bHQucGFzc2l2ZUV2ZW50cztcblxudmFyIG1vdXNlRXZlbnRzID0gZXhwb3J0cy5tb3VzZUV2ZW50cyA9IHtcbiAgbW91c2VlbnRlcjogJ29uTW91c2VFbnRlcicsXG4gIG1vdXNlbGVhdmU6ICdvbk1vdXNlTGVhdmUnLFxuICBtb3VzZW1vdmU6ICdvbk1vdXNlTW92ZScsXG4gIG1vdXNlZG93bjogJ29uTW91c2VEb3duJyxcbiAgbW91c2V1cDogJ29uTW91c2VVcCdcbn07XG5cbnZhciB0b3VjaEV2ZW50cyA9IGV4cG9ydHMudG91Y2hFdmVudHMgPSB7XG4gIHRvdWNoc3RhcnQ6ICdvblRvdWNoU3RhcnQnLFxuICB0b3VjaGVuZDogJ29uVG91Y2hFbmQnLFxuICB0b3VjaGNhbmNlbDogJ29uVG91Y2hDYW5jZWwnXG59O1xuXG52YXIgb3RoZXJFdmVudHMgPSBleHBvcnRzLm90aGVyRXZlbnRzID0ge1xuICBmb2N1czogJ29uRm9jdXMnLFxuICBibHVyOiAnb25CbHVyJyxcbiAga2V5ZG93bjogJ29uS2V5RG93bicsXG4gIGtleXVwOiAnb25LZXlVcCcsXG4gIGRyYWdzdGFydDogJ29uRHJhZ1N0YXJ0JyxcbiAgZHJhZ2VuZDogJ29uRHJhZ0VuZCdcbn07XG5cbnZhciBpU3RhdGVzID0gZXhwb3J0cy5pU3RhdGVzID0ge1xuICBub3JtYWw6IHRydWUsXG4gIGhvdmVyOiB0cnVlLFxuICBob3ZlckFjdGl2ZTogdHJ1ZSxcbiAgdG91Y2hBY3RpdmU6IHRydWUsXG4gIGtleUFjdGl2ZTogdHJ1ZVxufTtcblxudmFyIHN0YXRlUHJvcHMgPSBleHBvcnRzLnN0YXRlUHJvcHMgPSBfZXh0ZW5kcyh7fSwgaVN0YXRlcywge1xuICBhY3RpdmU6IHRydWUsXG4gIGZvY3VzOiB0cnVlLFxuICBmb2N1c0Zyb21UYWI6IHRydWUsXG4gIGZvY3VzRnJvbU1vdXNlOiB0cnVlLFxuICBmb2N1c0Zyb21Ub3VjaDogdHJ1ZVxufSk7XG5cbnZhciBzdGF0ZVByb3BPcHRpb25LZXlzID0gZXhwb3J0cy5zdGF0ZVByb3BPcHRpb25LZXlzID0gWydzdHlsZScsICdjbGFzc05hbWUnXTtcblxuLy8gZG9uJ3QgdG9nZ2xlIGZvY3VzIG9uIHRoZXNlIHRhZ3NcbnZhciBub25CbHVycmFibGVUYWdzID0gZXhwb3J0cy5ub25CbHVycmFibGVUYWdzID0ge1xuICBpbnB1dDogdHJ1ZSxcbiAgdGV4dGFyZWE6IHRydWUsXG4gIHNlbGVjdDogdHJ1ZVxufTtcblxuLy8gdGFncyB3aXRoIGtub3duIHJvbGVzLCBhbmQgdGhhdCB0aGUgYnJvd3NlciBtYXkgaGF2ZSBhIGNsaWNrIGhhbmRsZXIgZm9yXG52YXIga25vd25Sb2xlVGFncyA9IGV4cG9ydHMua25vd25Sb2xlVGFncyA9IF9leHRlbmRzKHt9LCBub25CbHVycmFibGVUYWdzLCB7XG4gIGJ1dHRvbjogdHJ1ZSxcbiAgYTogdHJ1ZSxcbiAgYXJlYTogdHJ1ZVxufSk7XG5cbi8vIGVsZW1lbnRzIHRyaWdnZXJlZCBieSB0aGUgZW50ZXIga2V5XG5mdW5jdGlvbiBlbnRlcktleVRyaWdnZXIodGFnLCB0eXBlKSB7XG4gIHJldHVybiB0YWcgIT09ICdzZWxlY3QnICYmICh0YWcgIT09ICdpbnB1dCcgfHwgdHlwZSAhPT0gJ2NoZWNrYm94JyAmJiB0eXBlICE9PSAncmFkaW8nKTtcbn1cblxuLy8gZWxlbWVudHMgdHJpZ2dlcmVkIGJ5IHRoZSBzcGFjZSBiYXJcbmZ1bmN0aW9uIHNwYWNlS2V5VHJpZ2dlcih0YWcsIHR5cGUpIHtcbiAgcmV0dXJuIHRhZyA9PT0gJ2J1dHRvbicgfHwgdGFnID09PSAnc2VsZWN0JyB8fCB0YWcgPT09ICdpbnB1dCcgJiYgKHR5cGUgPT09ICdjaGVja2JveCcgfHwgdHlwZSA9PT0gJ3JhZGlvJyB8fCB0eXBlID09PSAnc3VibWl0Jyk7XG59XG5cbi8vIGtub3duIHByb3BzIHRvIG5vdCBwYXNzIHRocm91Z2gsIGV2ZXJ5IHByb3Agbm90IG9uIHRoaXMgbGlzdCBpcyBwYXNzZWQgdGhyb3VnaFxudmFyIGtub3duUHJvcHMgPSBleHBvcnRzLmtub3duUHJvcHMgPSBfZXh0ZW5kcyh7fSwgc3RhdGVQcm9wcywge1xuICBjaGlsZHJlbjogdHJ1ZSxcbiAgYXM6IHRydWUsXG4gIHN0eWxlOiB0cnVlLFxuICBjbGFzc05hbWU6IHRydWUsXG4gIHdyYXBwZXJTdHlsZTogdHJ1ZSxcbiAgd3JhcHBlckNsYXNzTmFtZTogdHJ1ZSxcbiAgb25TdGF0ZUNoYW5nZTogdHJ1ZSxcbiAgc2V0U3RhdGVDYWxsYmFjazogdHJ1ZSxcbiAgb25DbGljazogdHJ1ZSxcbiAgb25UYXBUd286IHRydWUsXG4gIG9uVGFwVGhyZWU6IHRydWUsXG4gIG9uVGFwRm91cjogdHJ1ZSxcbiAgb25Mb25nUHJlc3M6IHRydWUsXG4gIHRhcFRpbWVDdXRvZmY6IHRydWUsXG4gIG9uTW91c2VFbnRlcjogdHJ1ZSxcbiAgb25Nb3VzZUxlYXZlOiB0cnVlLFxuICBvbk1vdXNlTW92ZTogdHJ1ZSxcbiAgb25Nb3VzZURvd246IHRydWUsXG4gIG9uTW91c2VVcDogdHJ1ZSxcbiAgb25Ub3VjaFN0YXJ0OiB0cnVlLFxuICBvblRvdWNoTW92ZTogdHJ1ZSxcbiAgb25Ub3VjaEVuZDogdHJ1ZSxcbiAgb25Ub3VjaENhbmNlbDogdHJ1ZSxcbiAgb25Gb2N1czogdHJ1ZSxcbiAgb25CbHVyOiB0cnVlLFxuICBvbktleURvd246IHRydWUsXG4gIG9uS2V5VXA6IHRydWUsXG4gIGZvcmNlU3RhdGU6IHRydWUsXG4gIGluaXRpYWxTdGF0ZTogdHJ1ZSxcbiAgcmVmRE9NTm9kZTogdHJ1ZSxcbiAgbXV0YWJsZVByb3BzOiB0cnVlLFxuICB1c2VCcm93c2VyT3V0bGluZUZvY3VzOiB0cnVlLFxuICB1c2VCcm93c2VyQ3Vyc29yOiB0cnVlLFxuICB0b3VjaEFjdGl2ZVRhcE9ubHk6IHRydWUsXG4gIGV4dHJhVG91Y2hOb1RhcDogdHJ1ZSxcbiAgZm9jdXNUb2dnbGVPZmY6IHRydWUsXG4gIHN0eWxlUHJpb3JpdHk6IHRydWUsXG4gIG5vbkNvbnRhaW5lZENoaWxkOiB0cnVlLFxuICBpbnRlcmFjdGl2ZUNoaWxkOiB0cnVlXG59KTtcblxuLy8gbXMgdG8gYWxsb3cgZm9yIHRoZSBicm93c2VyIHRvIGFkZCBzdWJzZXF1ZW50IGV2ZW50IHRvIHRoZSBxdWV1ZSBpbiBzZXRUaW1lb3V0c1xudmFyIHF1ZXVlVGltZSA9IGV4cG9ydHMucXVldWVUaW1lID0gNjAwO1xuXG52YXIgZGVmYXVsdFRhcFRpbWVDdXRvZmYgPSBleHBvcnRzLmRlZmF1bHRUYXBUaW1lQ3V0b2ZmID0gNTAwO1xuXG5mdW5jdGlvbiBkdW1teUV2ZW50KHR5cGUpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiB0eXBlLFxuICAgIHBlcnNpc3Q6IGZ1bmN0aW9uIHBlcnNpc3QoKSB7fSxcbiAgICBwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24gcHJldmVudERlZmF1bHQoKSB7fSxcbiAgICBzdG9wUHJvcGFnYXRpb246IGZ1bmN0aW9uIHN0b3BQcm9wYWdhdGlvbigpIHt9XG4gIH07XG59XG5cbnZhciBjaGlsZEludGVyYWN0aXZlUHJvcHMgPSBleHBvcnRzLmNoaWxkSW50ZXJhY3RpdmVQcm9wcyA9IHtcbiAgc2hvd09uUGFyZW50OiB0cnVlLFxuICBvblBhcmVudE5vcm1hbDogdHJ1ZSxcbiAgb25QYXJlbnRIb3ZlcjogdHJ1ZSxcbiAgb25QYXJlbnRBY3RpdmU6IHRydWUsXG4gIG9uUGFyZW50SG92ZXJBY3RpdmU6IHRydWUsXG4gIG9uUGFyZW50VG91Y2hBY3RpdmU6IHRydWUsXG4gIG9uUGFyZW50S2V5QWN0aXZlOiB0cnVlLFxuICBvblBhcmVudEZvY3VzOiB0cnVlLFxuICBvblBhcmVudEZvY3VzRnJvbVRhYjogdHJ1ZSxcbiAgb25QYXJlbnRGb2N1c0Zyb21Nb3VzZTogdHJ1ZSxcbiAgb25QYXJlbnRGb2N1c0Zyb21Ub3VjaDogdHJ1ZVxufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1pbnRlcmFjdGl2ZS9saWIvY29uc3RhbnRzLmpzXG4vLyBtb2R1bGUgaWQgPSAzNjdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDIgNCA1Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///367\n");

/***/ }),

/***/ 380:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.notifyOfNext = notifyOfNext;\nexports.cancelNotifyOfNext = cancelNotifyOfNext;\nexports.notifyOfAll = notifyOfAll;\n\nvar _constants = __webpack_require__(367);\n\n// list of callbacks that are called every time the event fires\n// only one callback function per eventType b/c notifyOfAll is only used by inputTracker\n// {\n//   eventType: callback,\n//   eventA: cbFunctionA,\n//   eventB: cbFunctionB,\n// }\nvar notifyOfAllSubs = {};\n\n// list of callbacks that are called only for the next event and then deleted\n// {\n//   eventType: [{ id, callback }, { id, callback }, ...],\n//   eventA: [{ id: 1, callback: cbFunctionA }, { id: 2, callback: cbFunctionB }],\n//   eventB: [{ id: 3, callback: cbFunctionC }, { id: 4, callback: cbFunctionD }],\n// }\nvar notifyOfNextSubs = {};\n\n// list of sub IDs with corresponding index in notifyOfNextSubs array for easy cancelation of sub\n// {\n//   eventType: { id: indexInNotifyOfNextSubsArray },\n//   eventA: { 1: 0, 2: 1 },\n//   eventB: { 3: 0, 4: 1 },\n// }\nvar subsIDs = {};\n\n// generate unique ID\nvar idPlace = 0;\nfunction nextID(eType) {\n  if (idPlace === Number.MAX_SAFE_INTEGER) idPlace = 0;\n  idPlace++;\n  if (subsIDs[eType][idPlace] === undefined) return idPlace;\n  return nextID(eType);\n}\n\n// subscribe to notifyOfNext, returns the ID of the subscription so it can be canceled\nfunction notifyOfNext(eType, callback) {\n  var id = nextID(eType);\n  subsIDs[eType][id] = notifyOfNextSubs[eType].push({ id: id, callback: callback }) - 1;\n  return id;\n}\n\n// cancel an already existing subscription\nvar blankFunction = function blankFunction() {};\nfunction cancelNotifyOfNext(eType, id) {\n  if (subsIDs[eType][id] !== 'undefined') {\n    notifyOfNextSubs[eType][subsIDs[eType][id]].callback = blankFunction;\n    delete subsIDs[eType][id];\n  }\n}\n\n// subscribe to notifyOfAll, only used by inputTracker\nfunction notifyOfAll(eTypes, callback) {\n  eTypes.forEach(function (eType) {\n    notifyOfAllSubs[eType] = callback;\n  });\n}\n\n// notify all when event comes in\nfunction handleNotifyAll(e) {\n  notifyOfAllSubs[e.type](e);\n}\n\n// notify next when event comes, if the callback returns 'reNotifyOfNext', then re-subscribe\n// using the same id\nfunction handleNotifyNext(e) {\n  if (notifyOfNextSubs[e.type].length === 0) return;\n  e.persist = blankFunction;\n  var reNotifyOfNext = [];\n  var reNotifyOfNextIDs = {};\n  notifyOfNextSubs[e.type].forEach(function (sub) {\n    if (sub.callback(e) === 'reNotifyOfNext') {\n      reNotifyOfNextIDs[sub.id] = reNotifyOfNext.push(sub) - 1;\n    }\n  });\n  notifyOfNextSubs[e.type] = reNotifyOfNext;\n  subsIDs[e.type] = reNotifyOfNextIDs;\n}\n\nfunction handleNotifyAllAndNext(e) {\n  handleNotifyAll(e);\n  handleNotifyNext(e);\n}\n\n// setup event listeners and notification system for events\nfunction setupEvent(element, eType, handler, capture) {\n  notifyOfNextSubs[eType] = [];\n  subsIDs[eType] = {};\n  element.addEventListener(eType, handler, _constants.passiveEventSupport ? {\n    capture: capture,\n    // don't set click listener as passive because syntheticClick may call preventDefault\n    passive: eType !== 'click'\n  } : capture);\n}\n\nif (_constants.deviceHasTouch) {\n  // set up click listener for use with syntheticClick on touch devices\n  setupEvent(window, 'click', handleNotifyAll, true);\n\n  // if the device has touch, then setup event listeners for touch events\n  Object.keys(_constants.touchEvents).forEach(function (eType) {\n    setupEvent(document, eType, eType === 'touchstart' ? handleNotifyAllAndNext : handleNotifyAll, true);\n  });\n}\n\n// if the device has a mouse, then setup event listeners for mouse events,\n// see manageNotifyOfNext and handleNotifyOfNext in index.js for more info\n// on why a specific listener is set\nif (_constants.deviceHasMouse) {\n  Object.keys(_constants.mouseEvents).forEach(function (eType) {\n    setupEvent(document, eType, eType === 'mouseenter' ? handleNotifyAllAndNext : handleNotifyAll,\n    // don't use capture for enter/leave so the event only fires when the mouse leaves the doc\n    !(eType === 'mouseenter' || eType === 'mouseleave'));\n  });\n\n  setupEvent(document, 'dragstart', handleNotifyNext, true);\n\n  if (_constants.passiveEventSupport) {\n    setupEvent(document, 'scroll', handleNotifyNext, true);\n  }\n\n  notifyOfNextSubs.mutation = [];\n  subsIDs.mutation = {};\n  var mutationEvent = (0, _constants.dummyEvent)('mutation');\n  var mo = new MutationObserver(handleNotifyNext.bind(null, mutationEvent));\n  mo.observe(document, {\n    childList: true,\n    attributes: true,\n    subtree: true,\n    characterData: true\n  });\n}\n\n// always set focus/blur listener on the window so know when leave/enter the app/window/tab\n['focus', 'blur'].forEach(function (eType) {\n  setupEvent(window, eType, handleNotifyNext, false);\n});\n\n// always set keydown listener for enter key events for form submission\nsetupEvent(document, 'keydown', handleNotifyAll, true);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzgwLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWludGVyYWN0aXZlL2xpYi9ub3RpZmllci5qcz81MzBmIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMubm90aWZ5T2ZOZXh0ID0gbm90aWZ5T2ZOZXh0O1xuZXhwb3J0cy5jYW5jZWxOb3RpZnlPZk5leHQgPSBjYW5jZWxOb3RpZnlPZk5leHQ7XG5leHBvcnRzLm5vdGlmeU9mQWxsID0gbm90aWZ5T2ZBbGw7XG5cbnZhciBfY29uc3RhbnRzID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcblxuLy8gbGlzdCBvZiBjYWxsYmFja3MgdGhhdCBhcmUgY2FsbGVkIGV2ZXJ5IHRpbWUgdGhlIGV2ZW50IGZpcmVzXG4vLyBvbmx5IG9uZSBjYWxsYmFjayBmdW5jdGlvbiBwZXIgZXZlbnRUeXBlIGIvYyBub3RpZnlPZkFsbCBpcyBvbmx5IHVzZWQgYnkgaW5wdXRUcmFja2VyXG4vLyB7XG4vLyAgIGV2ZW50VHlwZTogY2FsbGJhY2ssXG4vLyAgIGV2ZW50QTogY2JGdW5jdGlvbkEsXG4vLyAgIGV2ZW50QjogY2JGdW5jdGlvbkIsXG4vLyB9XG52YXIgbm90aWZ5T2ZBbGxTdWJzID0ge307XG5cbi8vIGxpc3Qgb2YgY2FsbGJhY2tzIHRoYXQgYXJlIGNhbGxlZCBvbmx5IGZvciB0aGUgbmV4dCBldmVudCBhbmQgdGhlbiBkZWxldGVkXG4vLyB7XG4vLyAgIGV2ZW50VHlwZTogW3sgaWQsIGNhbGxiYWNrIH0sIHsgaWQsIGNhbGxiYWNrIH0sIC4uLl0sXG4vLyAgIGV2ZW50QTogW3sgaWQ6IDEsIGNhbGxiYWNrOiBjYkZ1bmN0aW9uQSB9LCB7IGlkOiAyLCBjYWxsYmFjazogY2JGdW5jdGlvbkIgfV0sXG4vLyAgIGV2ZW50QjogW3sgaWQ6IDMsIGNhbGxiYWNrOiBjYkZ1bmN0aW9uQyB9LCB7IGlkOiA0LCBjYWxsYmFjazogY2JGdW5jdGlvbkQgfV0sXG4vLyB9XG52YXIgbm90aWZ5T2ZOZXh0U3VicyA9IHt9O1xuXG4vLyBsaXN0IG9mIHN1YiBJRHMgd2l0aCBjb3JyZXNwb25kaW5nIGluZGV4IGluIG5vdGlmeU9mTmV4dFN1YnMgYXJyYXkgZm9yIGVhc3kgY2FuY2VsYXRpb24gb2Ygc3ViXG4vLyB7XG4vLyAgIGV2ZW50VHlwZTogeyBpZDogaW5kZXhJbk5vdGlmeU9mTmV4dFN1YnNBcnJheSB9LFxuLy8gICBldmVudEE6IHsgMTogMCwgMjogMSB9LFxuLy8gICBldmVudEI6IHsgMzogMCwgNDogMSB9LFxuLy8gfVxudmFyIHN1YnNJRHMgPSB7fTtcblxuLy8gZ2VuZXJhdGUgdW5pcXVlIElEXG52YXIgaWRQbGFjZSA9IDA7XG5mdW5jdGlvbiBuZXh0SUQoZVR5cGUpIHtcbiAgaWYgKGlkUGxhY2UgPT09IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKSBpZFBsYWNlID0gMDtcbiAgaWRQbGFjZSsrO1xuICBpZiAoc3Vic0lEc1tlVHlwZV1baWRQbGFjZV0gPT09IHVuZGVmaW5lZCkgcmV0dXJuIGlkUGxhY2U7XG4gIHJldHVybiBuZXh0SUQoZVR5cGUpO1xufVxuXG4vLyBzdWJzY3JpYmUgdG8gbm90aWZ5T2ZOZXh0LCByZXR1cm5zIHRoZSBJRCBvZiB0aGUgc3Vic2NyaXB0aW9uIHNvIGl0IGNhbiBiZSBjYW5jZWxlZFxuZnVuY3Rpb24gbm90aWZ5T2ZOZXh0KGVUeXBlLCBjYWxsYmFjaykge1xuICB2YXIgaWQgPSBuZXh0SUQoZVR5cGUpO1xuICBzdWJzSURzW2VUeXBlXVtpZF0gPSBub3RpZnlPZk5leHRTdWJzW2VUeXBlXS5wdXNoKHsgaWQ6IGlkLCBjYWxsYmFjazogY2FsbGJhY2sgfSkgLSAxO1xuICByZXR1cm4gaWQ7XG59XG5cbi8vIGNhbmNlbCBhbiBhbHJlYWR5IGV4aXN0aW5nIHN1YnNjcmlwdGlvblxudmFyIGJsYW5rRnVuY3Rpb24gPSBmdW5jdGlvbiBibGFua0Z1bmN0aW9uKCkge307XG5mdW5jdGlvbiBjYW5jZWxOb3RpZnlPZk5leHQoZVR5cGUsIGlkKSB7XG4gIGlmIChzdWJzSURzW2VUeXBlXVtpZF0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgbm90aWZ5T2ZOZXh0U3Vic1tlVHlwZV1bc3Vic0lEc1tlVHlwZV1baWRdXS5jYWxsYmFjayA9IGJsYW5rRnVuY3Rpb247XG4gICAgZGVsZXRlIHN1YnNJRHNbZVR5cGVdW2lkXTtcbiAgfVxufVxuXG4vLyBzdWJzY3JpYmUgdG8gbm90aWZ5T2ZBbGwsIG9ubHkgdXNlZCBieSBpbnB1dFRyYWNrZXJcbmZ1bmN0aW9uIG5vdGlmeU9mQWxsKGVUeXBlcywgY2FsbGJhY2spIHtcbiAgZVR5cGVzLmZvckVhY2goZnVuY3Rpb24gKGVUeXBlKSB7XG4gICAgbm90aWZ5T2ZBbGxTdWJzW2VUeXBlXSA9IGNhbGxiYWNrO1xuICB9KTtcbn1cblxuLy8gbm90aWZ5IGFsbCB3aGVuIGV2ZW50IGNvbWVzIGluXG5mdW5jdGlvbiBoYW5kbGVOb3RpZnlBbGwoZSkge1xuICBub3RpZnlPZkFsbFN1YnNbZS50eXBlXShlKTtcbn1cblxuLy8gbm90aWZ5IG5leHQgd2hlbiBldmVudCBjb21lcywgaWYgdGhlIGNhbGxiYWNrIHJldHVybnMgJ3JlTm90aWZ5T2ZOZXh0JywgdGhlbiByZS1zdWJzY3JpYmVcbi8vIHVzaW5nIHRoZSBzYW1lIGlkXG5mdW5jdGlvbiBoYW5kbGVOb3RpZnlOZXh0KGUpIHtcbiAgaWYgKG5vdGlmeU9mTmV4dFN1YnNbZS50eXBlXS5sZW5ndGggPT09IDApIHJldHVybjtcbiAgZS5wZXJzaXN0ID0gYmxhbmtGdW5jdGlvbjtcbiAgdmFyIHJlTm90aWZ5T2ZOZXh0ID0gW107XG4gIHZhciByZU5vdGlmeU9mTmV4dElEcyA9IHt9O1xuICBub3RpZnlPZk5leHRTdWJzW2UudHlwZV0uZm9yRWFjaChmdW5jdGlvbiAoc3ViKSB7XG4gICAgaWYgKHN1Yi5jYWxsYmFjayhlKSA9PT0gJ3JlTm90aWZ5T2ZOZXh0Jykge1xuICAgICAgcmVOb3RpZnlPZk5leHRJRHNbc3ViLmlkXSA9IHJlTm90aWZ5T2ZOZXh0LnB1c2goc3ViKSAtIDE7XG4gICAgfVxuICB9KTtcbiAgbm90aWZ5T2ZOZXh0U3Vic1tlLnR5cGVdID0gcmVOb3RpZnlPZk5leHQ7XG4gIHN1YnNJRHNbZS50eXBlXSA9IHJlTm90aWZ5T2ZOZXh0SURzO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVOb3RpZnlBbGxBbmROZXh0KGUpIHtcbiAgaGFuZGxlTm90aWZ5QWxsKGUpO1xuICBoYW5kbGVOb3RpZnlOZXh0KGUpO1xufVxuXG4vLyBzZXR1cCBldmVudCBsaXN0ZW5lcnMgYW5kIG5vdGlmaWNhdGlvbiBzeXN0ZW0gZm9yIGV2ZW50c1xuZnVuY3Rpb24gc2V0dXBFdmVudChlbGVtZW50LCBlVHlwZSwgaGFuZGxlciwgY2FwdHVyZSkge1xuICBub3RpZnlPZk5leHRTdWJzW2VUeXBlXSA9IFtdO1xuICBzdWJzSURzW2VUeXBlXSA9IHt9O1xuICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoZVR5cGUsIGhhbmRsZXIsIF9jb25zdGFudHMucGFzc2l2ZUV2ZW50U3VwcG9ydCA/IHtcbiAgICBjYXB0dXJlOiBjYXB0dXJlLFxuICAgIC8vIGRvbid0IHNldCBjbGljayBsaXN0ZW5lciBhcyBwYXNzaXZlIGJlY2F1c2Ugc3ludGhldGljQ2xpY2sgbWF5IGNhbGwgcHJldmVudERlZmF1bHRcbiAgICBwYXNzaXZlOiBlVHlwZSAhPT0gJ2NsaWNrJ1xuICB9IDogY2FwdHVyZSk7XG59XG5cbmlmIChfY29uc3RhbnRzLmRldmljZUhhc1RvdWNoKSB7XG4gIC8vIHNldCB1cCBjbGljayBsaXN0ZW5lciBmb3IgdXNlIHdpdGggc3ludGhldGljQ2xpY2sgb24gdG91Y2ggZGV2aWNlc1xuICBzZXR1cEV2ZW50KHdpbmRvdywgJ2NsaWNrJywgaGFuZGxlTm90aWZ5QWxsLCB0cnVlKTtcblxuICAvLyBpZiB0aGUgZGV2aWNlIGhhcyB0b3VjaCwgdGhlbiBzZXR1cCBldmVudCBsaXN0ZW5lcnMgZm9yIHRvdWNoIGV2ZW50c1xuICBPYmplY3Qua2V5cyhfY29uc3RhbnRzLnRvdWNoRXZlbnRzKS5mb3JFYWNoKGZ1bmN0aW9uIChlVHlwZSkge1xuICAgIHNldHVwRXZlbnQoZG9jdW1lbnQsIGVUeXBlLCBlVHlwZSA9PT0gJ3RvdWNoc3RhcnQnID8gaGFuZGxlTm90aWZ5QWxsQW5kTmV4dCA6IGhhbmRsZU5vdGlmeUFsbCwgdHJ1ZSk7XG4gIH0pO1xufVxuXG4vLyBpZiB0aGUgZGV2aWNlIGhhcyBhIG1vdXNlLCB0aGVuIHNldHVwIGV2ZW50IGxpc3RlbmVycyBmb3IgbW91c2UgZXZlbnRzLFxuLy8gc2VlIG1hbmFnZU5vdGlmeU9mTmV4dCBhbmQgaGFuZGxlTm90aWZ5T2ZOZXh0IGluIGluZGV4LmpzIGZvciBtb3JlIGluZm9cbi8vIG9uIHdoeSBhIHNwZWNpZmljIGxpc3RlbmVyIGlzIHNldFxuaWYgKF9jb25zdGFudHMuZGV2aWNlSGFzTW91c2UpIHtcbiAgT2JqZWN0LmtleXMoX2NvbnN0YW50cy5tb3VzZUV2ZW50cykuZm9yRWFjaChmdW5jdGlvbiAoZVR5cGUpIHtcbiAgICBzZXR1cEV2ZW50KGRvY3VtZW50LCBlVHlwZSwgZVR5cGUgPT09ICdtb3VzZWVudGVyJyA/IGhhbmRsZU5vdGlmeUFsbEFuZE5leHQgOiBoYW5kbGVOb3RpZnlBbGwsXG4gICAgLy8gZG9uJ3QgdXNlIGNhcHR1cmUgZm9yIGVudGVyL2xlYXZlIHNvIHRoZSBldmVudCBvbmx5IGZpcmVzIHdoZW4gdGhlIG1vdXNlIGxlYXZlcyB0aGUgZG9jXG4gICAgIShlVHlwZSA9PT0gJ21vdXNlZW50ZXInIHx8IGVUeXBlID09PSAnbW91c2VsZWF2ZScpKTtcbiAgfSk7XG5cbiAgc2V0dXBFdmVudChkb2N1bWVudCwgJ2RyYWdzdGFydCcsIGhhbmRsZU5vdGlmeU5leHQsIHRydWUpO1xuXG4gIGlmIChfY29uc3RhbnRzLnBhc3NpdmVFdmVudFN1cHBvcnQpIHtcbiAgICBzZXR1cEV2ZW50KGRvY3VtZW50LCAnc2Nyb2xsJywgaGFuZGxlTm90aWZ5TmV4dCwgdHJ1ZSk7XG4gIH1cblxuICBub3RpZnlPZk5leHRTdWJzLm11dGF0aW9uID0gW107XG4gIHN1YnNJRHMubXV0YXRpb24gPSB7fTtcbiAgdmFyIG11dGF0aW9uRXZlbnQgPSAoMCwgX2NvbnN0YW50cy5kdW1teUV2ZW50KSgnbXV0YXRpb24nKTtcbiAgdmFyIG1vID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoaGFuZGxlTm90aWZ5TmV4dC5iaW5kKG51bGwsIG11dGF0aW9uRXZlbnQpKTtcbiAgbW8ub2JzZXJ2ZShkb2N1bWVudCwge1xuICAgIGNoaWxkTGlzdDogdHJ1ZSxcbiAgICBhdHRyaWJ1dGVzOiB0cnVlLFxuICAgIHN1YnRyZWU6IHRydWUsXG4gICAgY2hhcmFjdGVyRGF0YTogdHJ1ZVxuICB9KTtcbn1cblxuLy8gYWx3YXlzIHNldCBmb2N1cy9ibHVyIGxpc3RlbmVyIG9uIHRoZSB3aW5kb3cgc28ga25vdyB3aGVuIGxlYXZlL2VudGVyIHRoZSBhcHAvd2luZG93L3RhYlxuWydmb2N1cycsICdibHVyJ10uZm9yRWFjaChmdW5jdGlvbiAoZVR5cGUpIHtcbiAgc2V0dXBFdmVudCh3aW5kb3csIGVUeXBlLCBoYW5kbGVOb3RpZnlOZXh0LCBmYWxzZSk7XG59KTtcblxuLy8gYWx3YXlzIHNldCBrZXlkb3duIGxpc3RlbmVyIGZvciBlbnRlciBrZXkgZXZlbnRzIGZvciBmb3JtIHN1Ym1pc3Npb25cbnNldHVwRXZlbnQoZG9jdW1lbnQsICdrZXlkb3duJywgaGFuZGxlTm90aWZ5QWxsLCB0cnVlKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1pbnRlcmFjdGl2ZS9saWIvbm90aWZpZXIuanNcbi8vIG1vZHVsZSBpZCA9IDM4MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMiA0IDUiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///380\n");

/***/ }),

/***/ 414:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _react = __webpack_require__(1);\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _objectAssign = __webpack_require__(20);\n\nvar _objectAssign2 = _interopRequireDefault(_objectAssign);\n\nvar _propTypes = __webpack_require__(415);\n\nvar _compareProps = __webpack_require__(421);\n\nvar _compareProps2 = _interopRequireDefault(_compareProps);\n\nvar _mergeAndExtractProps2 = __webpack_require__(422);\n\nvar _mergeAndExtractProps3 = _interopRequireDefault(_mergeAndExtractProps2);\n\nvar _extractStyle = __webpack_require__(423);\n\nvar _recursiveNodeCheck = __webpack_require__(424);\n\nvar _recursiveNodeCheck2 = _interopRequireDefault(_recursiveNodeCheck);\n\nvar _inputTracker = __webpack_require__(425);\n\nvar _inputTracker2 = _interopRequireDefault(_inputTracker);\n\nvar _notifier = __webpack_require__(380);\n\nvar _syntheticClick = __webpack_require__(426);\n\nvar _syntheticClick2 = _interopRequireDefault(_syntheticClick);\n\nvar _constants = __webpack_require__(367);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar Interactive = function (_React$Component) {\n  _inherits(Interactive, _React$Component);\n\n  function Interactive(props) {\n    _classCallCheck(this, Interactive);\n\n    // state is always an object with two keys, `iState` and `focus`\n    var _this = _possibleConstructorReturn(this, (Interactive.__proto__ || Object.getPrototypeOf(Interactive)).call(this, props));\n\n    _this.refCallback = function (node) {\n      _this.refNode = node;\n      if (node) {\n        var prevTopNode = _this.topNode;\n        // if `as` is a component, then the `refNode` is the span wrapper, so get its firstChild\n        if (typeof _this.p.props.as !== 'string') _this.topNode = node.firstChild;else _this.topNode = node;\n        _this.tagName = _this.topNode.tagName.toLowerCase();\n        _this.type = _this.topNode.type && _this.topNode.type.toLowerCase();\n        _this.enterKeyTrigger = (0, _constants.enterKeyTrigger)(_this.tagName, _this.type);\n        _this.spaceKeyTrigger = (0, _constants.spaceKeyTrigger)(_this.tagName, _this.type);\n        // if as is a react component then won't have access to tag in componentWillReceiveProps,\n        // so check if click listener needs to be set again here (after this.tagName is set)\n        if (_this.setClickListener(_this.p.props)) _this.p.passThroughProps.onClick = _this.handleEvent;\n        // if node is a new node then call manageFocus to keep browser in sync with RI,\n        // note: above assignments can't be in this if statement b/c node could have mutated,\n        // node should maintain focus state when mutated\n        if (prevTopNode !== _this.topNode) {\n          _this.manageFocus('refCallback');\n          // if refDOMNode prop, pass along new DOM node\n          _this.p.props.refDOMNode && _this.p.props.refDOMNode(_this.topNode);\n        }\n      }\n    };\n\n    _this.handleEvent = function (e) {\n      if (!_this.isValidEvent(e)) return;\n\n      if (_constants.mouseEvents[e.type]) {\n        if (_this.handleMouseEvent(e) === 'terminate') return;\n      } else if (_constants.touchEvents[e.type] || e.type === 'touchmove' || e.type === 'touchtapcancel') {\n        if (_this.handleTouchEvent(e) === 'terminate') return;\n      } else if (e.type === 'click') {\n        if (_this.handleClickEvent(e) === 'terminate') return;\n      } else if (_this.handleOtherEvent(e) === 'terminate') return;\n\n      // compute the new state object and pass it as an argument to updateState,\n      // which calls setState and state change callbacks if needed\n      _this.updateState(_this.computeState(), _this.p.props, e);\n    };\n\n    _this.handleNotifyOfNext = function (e) {\n      var updateState = false;\n\n      switch (e.type) {\n        case 'scroll':\n        case 'mouseenter':\n        case 'mutation':\n          // check mouse position, if it's still on RI, then reNotifyOfNext, else updateState\n          if (_this.track.mouseOn && _this.checkMousePosition() === 'mouseOn') {\n            return 'reNotifyOfNext';\n          }\n          _this.track.mouseOn = false;\n          _this.track.buttonDown = false;\n          updateState = true;\n          break;\n\n        case 'touchstart':\n          // cancel tap if extra touch point, or when touch someplace else on the screen\n          // check topNode and children to make sure they weren't the target\n          if (_this.p.props.extraTouchNoTap) {\n            if (_this.track.touches.active < _this.maxTapPoints && (0, _recursiveNodeCheck2.default)(_this.topNode, function (node) {\n              return e.target === node;\n            })) {\n              return 'reNotifyOfNext';\n            }\n            updateState = _this.handleTouchEvent({ type: 'touchtapcancel' }) === 'updateState';\n          }\n          break;\n\n        case 'dragstart':\n          // use setTimeout because notifier drag event will fire before the drag event on RI,\n          // so w/o timeout when this intance of RI is dragged it would go:\n          // active -> force normal from notifier drag -> active from RI's drag event,\n          // but the timeout will allow time for RI's drag event to fire before force normal\n          _this.manageSetTimeout('dragstart', function () {\n            if (!_this.track.drag) {\n              _this.forceTrackIState('normal');\n              _this.updateState(_this.computeState(), _this.p.props, e, true);\n            }\n          }, 30);\n          break;\n\n        // window focus event\n        case 'focus':\n          // reinstate previous focus state if this window focus event is followed by\n          // an element focus event, otherwise cancel focus reinstatement\n          if (_this.track.previousFocus !== false) {\n            _this.track.reinstateFocus = true;\n            _this.manageSetTimeout('windowFocus', function () {\n              _this.track.reinstateFocus = false;\n            }, _constants.queueTime);\n          }\n          break;\n\n        // window blur event to preserve the focus state\n        case 'blur':\n          // clear the timer set in manageNotifyOfNext that was set to cancel this notification\n          _this.cancelTimeout('elementBlur');\n          // notifiy of the next window focus event (re-entering the app/window/tab)\n          if (!_this.track.notifyOfNext.focus) {\n            _this.track.notifyOfNext.focus = (0, _notifier.notifyOfNext)('focus', _this.handleNotifyOfNext);\n          }\n          break;\n        default:\n      }\n\n      if (updateState) _this.updateState(_this.computeState(), _this.p.props, e, true);\n      delete _this.track.notifyOfNext[e.type];\n      return null;\n    };\n\n    _this.state = {\n      // iState is always 1 of 5 strings:\n      // 'normal', 'hover', 'hoverActive', 'touchActive', 'keyActive'\n      iState: 'normal',\n      // focus is always 1 of 4 values: false, 'tab', 'mouse' or 'touch'\n      focus: false\n    };\n\n    // things to keep track of so RI knows what to do when\n    _this.track = {\n      touchDown: false,\n      recentTouch: false,\n      touches: { points: {}, active: 0 },\n      mouseOn: false,\n      buttonDown: false,\n      clickType: 'reset',\n      focus: false,\n      previousFocus: false,\n      reinstateFocus: false,\n      focusTransition: 'reset',\n      focusStateOnMouseDown: false,\n      spaceKeyDown: false,\n      enterKeyDown: false,\n      drag: false,\n      updateTopNode: false,\n      notifyOfNext: {},\n      timeoutIDs: {},\n      state: _this.state\n    };\n\n    // the node returned by the ref callback\n    _this.refNode = null;\n    // the actual top DOM node of `as`, needed when `as` is wrapped in a span (is ReactComponent)\n    _this.topNode = null;\n    // tagName and type properties of topNode, updated in refCallback\n    _this.tagName = typeof props.as === 'string' && props.as || '';\n    _this.type = props.type || '';\n    // if the topNode is triggered by the enter key, and/or the space bar\n    _this.enterKeyTrigger = false;\n    _this.spaceKeyTrigger = false;\n\n    // maximum number of touch points where a tap is still possible, updated in propsSetup\n    _this.maxTapPoints = 1;\n\n    // the event handlers to pass down as props to the element/component\n    _this.eventHandlers = _this.setupEventHandlers();\n\n    // this.p is used to store things that are a deterministic function of props\n    // to avoid recalculating every time they are needed, it can be thought of as a pure\n    // extension to props and is only updated in the constructor and componentWillReceiveProps\n    _this.p = { sameProps: false };\n    // set properties of `this.p`\n    _this.propsSetup(props);\n    // if initialState prop, update state.iState for initial render, note that state.focus\n    // will be updated in componentDidMount b/c can't call focus until have ref to DOM node\n    if (_this.p.props.initialState && _this.p.props.initialState.iState) {\n      _this.forceTrackIState(_this.p.props.initialState.iState);\n      _this.state = _this.computeState();\n    }\n    return _this;\n  }\n\n  _createClass(Interactive, [{\n    key: 'componentDidMount',\n    value: function componentDidMount() {\n      // enter focus state if initialState.focus - called here instead of constructor\n      // because can't call focus until have ref to DOM node\n      if (this.p.props.initialState && this.p.props.initialState.focus !== undefined) {\n        this.forceState({ focus: this.p.props.initialState.focus });\n      }\n    }\n  }, {\n    key: 'componentWillReceiveProps',\n    value: function componentWillReceiveProps(nextProps) {\n      // set if the `topNode` needs to be updated in componentDidUpdate => `as` is different\n      // and not a string, note that if `as` is a new string, then the `refCallback`\n      // will be called by React so no need to do anything in componentDidUpdate\n      this.track.updateTopNode = this.props.as !== nextProps.as && typeof this.props.as !== 'string' && typeof nextProps.as !== 'string';\n\n      // check if nextProps are the same as this.props\n      this.p.sameProps = false;\n      if (!nextProps.mutableProps && (0, _compareProps2.default)(this.props, nextProps)) {\n        this.p.sameProps = true;\n      } else {\n        // if not same props, do props setup => set properties of `this.p`\n        this.propsSetup(nextProps);\n      }\n\n      // if `forceState` prop, then force update state\n      if (this.p.props.forceState) this.forceState(this.p.props.forceState);\n    }\n  }, {\n    key: 'shouldComponentUpdate',\n    value: function shouldComponentUpdate(nextProps, nextState) {\n      // or statement, returns true on first true value, returns false if all are false\n      return (\n        // return true if props have changed since last render\n        !this.p.sameProps && nextProps !== this.props ||\n        // always update if there are interactive children\n        nextProps.interactiveChild ||\n        // if `iState` changed, AND the `style` or `className` for the new `iState` is different,\n        // prevents renders when switching b/t two states that have the same `style` and `className`\n        nextState.iState !== this.state.iState && (this.p[nextState.iState + 'Style'].style !== this.p[this.state.iState + 'Style'].style || this.p[nextState.iState + 'Style'].className !== this.p[this.state.iState + 'Style'].className) ||\n        // if `focus` state changed (always update to work with default style)\n        nextState.focus !== this.state.focus\n      );\n    }\n  }, {\n    key: 'componentDidUpdate',\n    value: function componentDidUpdate() {\n      // `refCallback` isn't called by React when `as` is a component because the span wrapper\n      // remains the same element and is not re-mounted in the DOM, so need to call refCallback here\n      // if `as` is new and a component (`updateTopNode` was set in componentWillReceiveProps).\n      if (this.track.updateTopNode) {\n        this.track.updateTopNode = false;\n        this.refCallback(this.refNode);\n      }\n    }\n  }, {\n    key: 'componentWillUnmount',\n    value: function componentWillUnmount() {\n      var _this2 = this;\n\n      Object.keys(this.track.notifyOfNext).forEach(function (eType) {\n        (0, _notifier.cancelNotifyOfNext)(eType, _this2.track.notifyOfNext[eType]);\n      });\n      Object.keys(this.track.timeoutIDs).forEach(function (timer) {\n        window.clearTimeout(_this2.track.timeoutIDs[timer]);\n      });\n    }\n\n    // determine event handlers to use based on the device type - only determined once in constructor\n\n  }, {\n    key: 'setupEventHandlers',\n    value: function setupEventHandlers() {\n      var _this3 = this;\n\n      var eventHandlers = {};\n      Object.keys(_constants.otherEvents).forEach(function (event) {\n        eventHandlers[_constants.otherEvents[event]] = _this3.handleEvent;\n      });\n\n      // if the device has touch, set touch event listeners\n      if (_constants.deviceHasTouch) {\n        Object.keys(_constants.touchEvents).forEach(function (event) {\n          eventHandlers[_constants.touchEvents[event]] = _this3.handleEvent;\n        });\n      }\n      // if the device has a mouse, set mouse event listeners\n      if (_constants.deviceHasMouse) {\n        Object.keys(_constants.mouseEvents).forEach(function (event) {\n          eventHandlers[_constants.mouseEvents[event]] = _this3.handleEvent;\n        });\n      }\n      return eventHandlers;\n    }\n\n    // returns true if a click listener should be set, called from propsSetup and refCallback\n\n  }, {\n    key: 'setClickListener',\n    value: function setClickListener(props) {\n      // set click listener when there is an onClick prop\n      if (props.onClick) return true;\n      if (_constants.deviceHasTouch) {\n        // set click listener when the element is focusable - this is to correct a bug\n        // in Chrome on iOS where it will sometimes, when it is under stress, fire focus and\n        // click events without firing a touch event on the document - the result is the focus event\n        // will cause RI to enter the focus from tab state errantly, and then the click event will\n        // toggle focus off making the correction, so have to listen for click events\n        if (props.tabIndex) return true;\n        // set click listener when the element has a knownRoleTag, i.e. the browser\n        // has a click event handler so preventDefault() needs to be called when the\n        // browser sends a click event after RI has canceled tap (e.g. touchTapTimer expired, etc)\n        if (_constants.knownRoleTags[this.tagName]) return true;\n      }\n      return false;\n    }\n\n    // find and set the top DOM node of `as`\n\n  }, {\n    key: 'propsSetup',\n\n\n    // setup `this.p`, only called from constructor and componentWillReceiveProps\n    value: function propsSetup(props) {\n      var _mergeAndExtractProps = (0, _mergeAndExtractProps3.default)(props, _constants.knownProps),\n          mergedProps = _mergeAndExtractProps.mergedProps,\n          passThroughProps = _mergeAndExtractProps.passThroughProps;\n\n      (0, _extractStyle.setActiveAndFocusProps)(mergedProps);\n\n      // if focus state prop and no tabIndex, then add a tabIndex so RI is focusable by browser\n      if (passThroughProps.tabIndex === null) delete passThroughProps.tabIndex;else if (!passThroughProps.tabIndex && (mergedProps.focus || mergedProps.focusFromTab || mergedProps.focusFromMouse || mergedProps.focusFromTouch || mergedProps.onClick)) {\n        mergedProps.tabIndex = '0';\n        passThroughProps.tabIndex = '0';\n      }\n\n      // if onClick prop but it's not clear what the role of the element is then add role=\"button\"\n      if (passThroughProps.role === null) delete passThroughProps.role;else if (mergedProps.onClick && !mergedProps.role && typeof mergedProps.as === 'string' && !_constants.knownRoleTags[mergedProps.as]) {\n        mergedProps.role = 'button';\n        passThroughProps.role = 'button';\n      }\n\n      // maximum number of touch points where a tap is still possible\n      this.maxTapPoints = mergedProps.onTapFour && 4 || mergedProps.onTapThree && 3 || mergedProps.onTapTwo && 2 || 1;\n\n      // add onClick handler to passThroughProps if it's required\n      if (this.setClickListener(mergedProps)) passThroughProps.onClick = this.handleEvent;\n\n      //  add onTouchMove handler to passThroughProps if it's required\n      if (_constants.deviceHasTouch && (mergedProps.touchActiveTapOnly || mergedProps.onLongPress || mergedProps.onTouchMove)) {\n        passThroughProps.onTouchMove = this.handleEvent;\n      }\n\n      // add other event handlers to passThroughProps\n      (0, _objectAssign2.default)(passThroughProps, this.eventHandlers);\n\n      this.p.normalStyle = (0, _extractStyle.extractStyle)(mergedProps, 'normal');\n      this.p.hoverStyle = (0, _extractStyle.extractStyle)(mergedProps, 'hover');\n      this.p.hoverActiveStyle = (0, _extractStyle.extractStyle)(mergedProps, 'hoverActive');\n      this.p.touchActiveStyle = (0, _extractStyle.extractStyle)(mergedProps, 'touchActive');\n      this.p.keyActiveStyle = (0, _extractStyle.extractStyle)(mergedProps, 'keyActive');\n      this.p.tabFocusStyle = (0, _extractStyle.extractStyle)(mergedProps, 'focusFromTab');\n      this.p.mouseFocusStyle = (0, _extractStyle.extractStyle)(mergedProps, 'focusFromMouse');\n      this.p.touchFocusStyle = (0, _extractStyle.extractStyle)(mergedProps, 'focusFromTouch');\n      this.p.passThroughProps = passThroughProps;\n      this.p.props = mergedProps;\n    }\n\n    // keep track of running timeouts so can clear in componentWillUnmount\n\n  }, {\n    key: 'manageSetTimeout',\n    value: function manageSetTimeout(type, cb, delay) {\n      var _this4 = this;\n\n      if (this.track.timeoutIDs[type] !== undefined) {\n        window.clearTimeout(this.track.timeoutIDs[type]);\n      }\n      this.track.timeoutIDs[type] = window.setTimeout(function () {\n        delete _this4.track.timeoutIDs[type];\n        cb();\n      }, delay);\n    }\n  }, {\n    key: 'cancelTimeout',\n    value: function cancelTimeout(type) {\n      if (this.track.timeoutIDs[type] !== undefined) {\n        window.clearTimeout(this.track.timeoutIDs[type]);\n        delete this.track.timeoutIDs[type];\n      }\n    }\n\n    // force set this.track properties based on iState\n\n  }, {\n    key: 'forceTrackIState',\n    value: function forceTrackIState(iState) {\n      if (this.computeState().iState !== iState) {\n        this.track.mouseOn = iState === 'hover' || iState === 'hoverActive';\n        this.track.buttonDown = iState === 'hoverActive';\n        this.track.touchDown = iState === 'touchActive';\n        this.track.spaceKeyDown = iState === 'keyActive';\n        this.track.enterKeyDown = iState === 'keyActive';\n        this.track.drag = false;\n      }\n    }\n\n    // force set new state\n\n  }, {\n    key: 'forceState',\n    value: function forceState(newState) {\n      // set this.track properties to match new iState\n      if (newState.iState !== undefined) this.forceTrackIState(newState.iState);\n\n      // if new focus state, call manageFocus and return b/c focus calls updateState\n      if (newState.focus !== undefined && newState.focus !== this.track.state.focus) {\n        this.track.focus = newState.focus;\n        this.manageFocus(newState.focus ? 'forceStateFocusTrue' : 'forceStateFocusFalse');\n        return;\n      }\n\n      // update state with new computed state and dummy 'event' that caused state change\n      this.updateState(this.computeState(), this.p.props, (0, _constants.dummyEvent)('forcestate'));\n    }\n\n    // compute the state based on what's set in `this.track`, returns a new state object\n    // note: use the respective active state when drag is true (i.e. dragging the element)\n\n  }, {\n    key: 'computeState',\n    value: function computeState() {\n      var _track = this.track,\n          mouseOn = _track.mouseOn,\n          buttonDown = _track.buttonDown,\n          touchDown = _track.touchDown,\n          focus = _track.focus,\n          drag = _track.drag;\n\n      var focusKeyDown = focus && (this.track.enterKeyDown && this.enterKeyTrigger || this.track.spaceKeyDown && this.spaceKeyTrigger);\n      var newState = { focus: focus };\n      if (!mouseOn && !buttonDown && !touchDown && !focusKeyDown && !drag) newState.iState = 'normal';else if (mouseOn && !buttonDown && !touchDown && !focusKeyDown && !drag) {\n        newState.iState = 'hover';\n      } else if (mouseOn && buttonDown && !touchDown && !focusKeyDown || drag && !touchDown) {\n        newState.iState = 'hoverActive';\n      } else if (focusKeyDown && !touchDown) newState.iState = 'keyActive';else if (touchDown || drag) newState.iState = 'touchActive';\n      return newState;\n    }\n\n    // takes a new state, calls setState and the state change callbacks\n\n  }, {\n    key: 'updateState',\n    value: function updateState(newState, props, event, dontManageNotifyOfNext) {\n      if (!dontManageNotifyOfNext) this.manageNotifyOfNext(newState);\n      var prevIState = this.track.state.iState;\n      var nextIState = newState.iState;\n      var iStateChange = nextIState !== prevIState;\n      var focusChange = newState.focus !== this.track.state.focus;\n\n      // early return if state doesn't need to change\n      if (!iStateChange && !focusChange) return;\n\n      // create new prev and next state objects with immutable values\n      var prevState = {\n        iState: prevIState,\n        focus: this.track.state.focus\n      };\n      var nextState = {\n        iState: nextIState,\n        focus: newState.focus\n      };\n\n      // call onStateChange prop callback\n      props.onStateChange && props.onStateChange({ prevState: prevState, nextState: nextState, event: event });\n\n      // track new state because setState is asyncrounous\n      this.track.state = newState;\n\n      // only place that setState is called\n      this.setState(newState, props.setStateCallback && props.setStateCallback.bind(this, { prevState: prevState, nextState: nextState }));\n    }\n\n    // handles all events - first checks if it's a valid event, then calls the specific\n    // type of event handler (to set the proper this.track properties),\n    // and at the end calls this.updateState(...)\n\n  }, {\n    key: 'isValidEvent',\n\n\n    // checks if the event is a valid event or not, returns true / false respectivly\n    value: function isValidEvent(e) {\n      // if it's a known click event then return true\n      if (e.type === 'click' && this.track.clickType !== 'reset') return true;\n      // if it's a focus/blur event and this Interactive instance is not the target then return true\n      if ((e.type === 'focus' || e.type === 'blur') && e.target !== this.topNode) return true;\n\n      // refCallbackFocus calls focus when there is a new top DOM node and RI is already in the\n      // focus state to keep the browser's focus state in sync with RI's, so reset and return false\n      if (e.type === 'focus' && this.track.focusTransition === 'refCallbackFocus') {\n        e.stopPropagation();\n        this.track.focusTransition = 'reset';\n        return false;\n      }\n\n      // if the focusTransition is a force blur and RI is not currently in the focus state,\n      // then the force blur is to keep the browser focus state in sync with RI's focus state,\n      // so reset the focusTransition and return false, no need to do anything\n      // else because the blur event was only for the benefit of the browser, not RI\n      if (e.type === 'blur' && this.track.focusTransition === 'focusForceBlur' && !this.track.state.focus) {\n        e.stopPropagation();\n        this.track.focusTransition = 'reset';\n        return false;\n      }\n\n      // if the device is touchOnly or a hybrid\n      if (_constants.deviceHasTouch) {\n        // reject click events that are from touch interactions, unless no active or touchActive prop\n        // if no active or touchActive prop, then let the browser determine what is a click from touch\n        // this allows for edge taps that don't fire touch events on RI (only click events)\n        // so the click event is allowed through when WebkitTapHightlightColor indicates a click\n        if (e.type === 'click' && (_inputTracker2.default.touch.recentTouch || _inputTracker2.default.touch.touchOnScreen) && (this.p.props.active || this.p.props.touchActive)) {\n          e.preventDefault();\n          e.stopPropagation();\n          return false;\n        }\n        // reject unknown focus events from touch interactions\n        if (e.type === 'focus') {\n          if (this.track.focusTransition === 'reset' && (_inputTracker2.default.touch.recentTouch || !this.track.touchDown && _inputTracker2.default.touch.touchOnScreen)) {\n            e.preventDefault();\n            e.stopPropagation();\n            this.manageFocus('focusForceBlur');\n            return false;\n          }\n        }\n      }\n\n      if (_constants.deviceType === 'hybrid') {\n        // reject mouse events from touch interactions\n        if (/mouse/.test(e.type) && (_inputTracker2.default.touch.touchOnScreen || _inputTracker2.default.touch.recentTouch)) {\n          e.preventDefault();\n          e.stopPropagation();\n          return false;\n        }\n      }\n\n      return true;\n    }\n\n    // notifyOfNext plugs the holes in the events fired by the browser on the RI element,\n    // in some situations the browser fails to fire the necessary event leaving RI stuck\n    // in the wrong state (a not normal iState), so sign up to be notified of the next global event\n    // and do some checks (in handleNotifyOfNext) to confirm RI is in the correct state,\n    // note that notifyOfNext only while not in the normal state makes the notifier O(1) instead of\n    // O(n), where n is the number of mounted RI components\n\n  }, {\n    key: 'manageNotifyOfNext',\n    value: function manageNotifyOfNext(newState) {\n      var _this5 = this;\n\n      // set notifyOfNext\n      var setNON = function setNON(eType) {\n        if (!_this5.track.notifyOfNext[eType]) {\n          _this5.track.notifyOfNext[eType] = (0, _notifier.notifyOfNext)(eType, _this5.handleNotifyOfNext);\n        }\n      };\n      // cancel notifyOfNext\n      var cancelNON = function cancelNON(eType) {\n        if (_this5.track.notifyOfNext[eType]) {\n          (0, _notifier.cancelNotifyOfNext)(eType, _this5.track.notifyOfNext[eType]);\n          delete _this5.track.notifyOfNext[eType];\n        }\n      };\n\n      if (_constants.deviceHasMouse) {\n        // if not in the normal state and not dragging, then set notifyOfNext, otherwise cancel\n        var shouldSetNON = newState.iState !== 'normal' && !this.track.drag;\n\n        // check mouse position on document mouseenter to prevent from sticking in\n        // the hover state after switching to another app/window, moving the mouse,\n        // and then switching  back (so the mouse is no longer over the element)\n        shouldSetNON ? setNON('mouseenter') : cancelNON('mouseenter');\n\n        // the dragstart event on an element fires after a short delay, so it is possible to\n        // start dragging an element and have the mouseenter another element putting it in the\n        // hoverActive state before the dragstart event fires (after the dragstart event\n        // no other mouse events are fired), so sign up for next global dragstart to force intro\n        // normal state while another element is being dragged\n        shouldSetNON ? setNON('dragstart') : cancelNON('dragstart');\n\n        // the scroll listener provides a minor improvement to accuracy by exiting the hover state\n        // as soon as the mouse is scrolled off an element instead of waiting for the scrolling to end\n        // only set as a passive listener as the improvement is not worth it if it hurts performance\n        if (_constants.passiveEventSupport) {\n          shouldSetNON ? setNON('scroll') : cancelNON('scroll');\n        }\n\n        // if the mouse is on RI, then sign up for next DOM mutation event, which could\n        // move the mouse off of RI (by changing the layout of the page)\n        // without firing a mouseleave event (because the mouse never moved)\n        this.track.mouseOn ? setNON('mutation') : cancelNON('mutation');\n      }\n\n      if (_constants.deviceHasTouch) {\n        // cancel tap when touch someplace else on the screen\n        newState.iState === 'touchActive' ? this.p.props.extraTouchNoTap && setNON('touchstart') : cancelNON('touchstart');\n      }\n\n      // notify of next setup for maintaining correct focusFrom when switching apps/windows,\n      // if exiting the focus state, notify of the next window blur (leaving the app/window/tab)\n      // event if it immediately follows this event, otherwise cancel the notify of next\n      if (this.track.state.focus && !newState.focus) {\n        setNON('blur');\n        this.manageSetTimeout('elementBlur', function () {\n          _this5.track.previousFocus = false;\n          cancelNON('blur');\n        }, _constants.queueTime);\n      }\n    }\n  }, {\n    key: 'checkMousePosition',\n\n\n    // check the mouse position relative to the RI element on the page\n    value: function checkMousePosition(e) {\n      if (!_constants.deviceHasMouse) return null;\n\n      var mouseX = e && e.clientX || _inputTracker2.default.mouse.clientX;\n      var mouseY = e && e.clientY || _inputTracker2.default.mouse.clientY;\n      function mouseOnNode(node) {\n        var rect = node.getBoundingClientRect();\n        return mouseX >= rect.left - 1 && mouseX <= rect.right + 1 && mouseY >= rect.top - 1 && mouseY <= rect.bottom + 1;\n      }\n\n      var mouseOn = true;\n\n      if (!_inputTracker2.default.mouse.mouseOnDocument) {\n        mouseOn = false;\n      } else if (!this.p.props.nonContainedChild) {\n        mouseOn = mouseOnNode(this.topNode);\n      } else {\n        // if the nonContainedChild prop is present, then do a recursive check of the node and its\n        // children until the mouse is on a node or all children are checked,\n        // this is useful when the children aren't inside of the parent on the page\n        mouseOn = (0, _recursiveNodeCheck2.default)(this.topNode, mouseOnNode);\n      }\n\n      return mouseOn ? 'mouseOn' : 'mouseOff';\n    }\n\n    // check to see if a focusTransition is necessary and update this.track.focusTransition\n    // returns 'terminate' if handleEvent should terminate, returns 'updateState'\n    // if handleEvent should continue and call updateState this time through\n    // focus event lifecycle:\n    // - browser calls focus -> onFocus listener triggered\n    // - RI calls focus (using manageFocus) -> set focusTransition -> onFocus listener triggered\n    // - RI event handler uses track.focusTransition to determine if the focus event is:\n    //   - not a valid event (in isValidEvent)\n    //     - sent from RI to keep browser focus in sync with RI -> reset focusTransition -> end\n    //     - errant -> call blur to keep browser in sync, set focusTransition to focusForceBlur -> end\n    //   - a valid event\n    //     - sent from RI -> reset focusTransition -> RI enters the focus state w/ focus\n    //       based on the focusTransition\n    //     - sent from browser -> RI enters the focus state w/ focus set to 'tab'\n    // - browser calls blur -> onBlur listener triggered\n    // - RI calls blur (using manageFocus) -> set focusTransition -> onBlur listener triggered\n    // - RI event handler uses track.focusTransition to determine if the blur event is:\n    //   - not a valid event (in isValidEvent)\n    //     - a force blur to keep the browser focus state in sync -> reset focusTransition -> end\n    //       (if it's a force blur meant for both RI and the browser, then it's a valid event)\n    //   - eveything else -> reset focusTransition -> RI leaves focus state\n\n  }, {\n    key: 'manageFocus',\n    value: function manageFocus(type, e) {\n      var _this6 = this;\n\n      // if this exact event has already been used for focus/blur by another instance of Interactive\n      // i.e. a child and the event is bubbling, then don't manage focus and return updateState\n      if (e && (_inputTracker.focusRegistry.focus === e || _inputTracker.focusRegistry.blur === e)) return 'updateState';\n\n      // is the DOM node tag blurable for toggle focus\n      var tagIsBlurable = !_constants.nonBlurrableTags[this.tagName] && !this.p.props.focusToggleOff;\n      // is the node focusable, if there is a focus or tabIndex prop, or it's non-blurable, then it is\n      var tagIsFocusable = this.p.props.tabIndex || _constants.knownRoleTags[this.tagName];\n\n      // calls focus/blur to transition focus, returns 'terminate' if focus/blur call is made\n      // because focus/blur event handler called updateState,\n      // returns 'updateState' if not allowed to make specified transition, so RI will continue\n      // to updateState this time through handleEvent\n      var focusTransition = function focusTransition(event, transitionAs, force) {\n        if (force === 'force' || event === 'focus' && tagIsFocusable || event === 'blur' && tagIsBlurable) {\n          // if the manageFocus call is from a browser event (i.e. will bubble), register it\n          if (e) {\n            _inputTracker.focusRegistry[event] = e;\n            // reset event registry after bubbling has finished because React reuses events so\n            // future event equality checks may give a false positive if not reset\n            _this6.manageSetTimeout('focusRegistry', function () {\n              _inputTracker.focusRegistry[event] = null;\n            }, 0);\n          }\n          _this6.track.focusTransition = transitionAs;\n          _this6.topNode[event]();\n          // if focusTransition has changed, then the focus/blur call was sucessful so terminate\n          if (_this6.track.focusTransition !== transitionAs) {\n            return 'terminate';\n          }\n        }\n        _this6.track.focusTransition = 'reset';\n        return 'updateState';\n      };\n\n      // toggles focus by calling focusTransition, returns focusTransition's return\n      var toggleFocus = function toggleFocus(toggleAs, force) {\n        if (_this6.track.state.focus) return focusTransition('blur', toggleAs + 'Blur', force);\n        return focusTransition('focus', toggleAs + 'Focus', force);\n      };\n\n      switch (type) {\n        case 'mousedown':\n          return focusTransition('focus', 'mouseDownFocus');\n        case 'mouseup':\n          // blur only if focus was not initiated on the preceding mousedown,\n          if (this.track.focusStateOnMouseDown) return focusTransition('blur', 'mouseUpBlur');\n          this.track.focusTransition = 'reset';\n          return 'updateState';\n        case 'touchclick':\n          return toggleFocus('touchClick');\n        case 'forceStateFocusTrue':\n          // setTimeout because React misses focus calls made during componentWillReceiveProps,\n          // which is where forceState calls come from (the browser receives the focus call\n          // but not React), so have to call focus asyncrounsly so React receives it\n          this.manageSetTimeout('forceStateFocusTrue', function () {\n            !_this6.track.state.focus && focusTransition('focus', 'forceStateFocus', 'force');\n          }, 0);\n          return 'terminate';\n        case 'forceStateFocusFalse':\n          // same as forceStateFocusTrue, but for focus false\n          this.manageSetTimeout('forceStateFocusFalse', function () {\n            _this6.track.state.focus && focusTransition('blur', 'forceStateBlur', 'force');\n          }, 0);\n          return 'terminate';\n        case 'refCallback':\n          // if in the focus state and RI has a new topDOMNode, then call focus() on `this.topNode`\n          // to keep the browser focus state in sync with RI's focus state\n          if (this.track.state.focus) return focusTransition('focus', 'refCallbackFocus', 'force');\n          this.track.focusTransition = 'reset';\n          return 'terminate';\n        case 'focusForceBlur':\n          return focusTransition('blur', 'focusForceBlur', 'force');\n        default:\n          return 'updateState';\n      }\n    }\n\n    // returns 'terminate' if the caller (this.handleEvent) should not call updateState(...)\n\n  }, {\n    key: 'handleMouseEvent',\n    value: function handleMouseEvent(e) {\n      switch (e.type) {\n        case 'mouseenter':\n          (0, _inputTracker.updateMouseFromRI)(e);\n          this.p.props.onMouseEnter && this.p.props.onMouseEnter(e);\n          this.track.mouseOn = true;\n          this.track.buttonDown = e.buttons === 1;\n          return 'updateState';\n        case 'mouseleave':\n          (0, _inputTracker.updateMouseFromRI)(e);\n          this.p.props.onMouseLeave && this.p.props.onMouseLeave(e);\n          this.track.mouseOn = false;\n          this.track.buttonDown = false;\n          return 'updateState';\n        case 'mousemove':\n          this.p.props.onMouseMove && this.p.props.onMouseMove(e);\n          // early return for mouse move\n          if (this.track.mouseOn && this.track.buttonDown === (e.buttons === 1)) return 'terminate';\n          this.track.mouseOn = true;\n          this.track.buttonDown = e.buttons === 1;\n          return 'updateState';\n        case 'mousedown':\n          this.p.props.onMouseDown && this.p.props.onMouseDown(e);\n          this.track.mouseOn = true;\n          this.track.buttonDown = true;\n          // track focus state on mousedown to know if should blur on mouseup\n          this.track.focusStateOnMouseDown = this.track.state.focus;\n          return this.manageFocus('mousedown', e);\n        case 'mouseup':\n          {\n            this.p.props.onMouseUp && this.p.props.onMouseUp(e);\n            this.track.buttonDown = false;\n            var manageFocusReturn = this.manageFocus('mouseup', e);\n            this.manageClick('mouseClick');\n            return manageFocusReturn;\n          }\n        default:\n          return 'terminate';\n      }\n    }\n\n    // returns 'terminate' if the caller (this.handleEvent) should not call updateState(...)\n    // note that a touch interaction lasts from the start of the first touch point on RI,\n    // until removal of the last touch point on RI, and then the touch interaction is reset\n\n  }, {\n    key: 'handleTouchEvent',\n    value: function handleTouchEvent(e) {\n      var _this7 = this;\n\n      // reset mouse trackers\n      this.track.mouseOn = false;\n      this.track.buttonDown = false;\n\n      // reset touch interaction tracking, called when there are no more touches on the target\n      var resetTouchInteraction = function resetTouchInteraction() {\n        _this7.track.touchDown = false;\n        _this7.track.touches = { points: {}, active: 0 };\n        // clear the touchTapTimer if it's running\n        _this7.cancelTimeout('touchTapTimer');\n      };\n\n      // track recent touch, called from touchend and touchcancel\n      var recentTouch = function recentTouch() {\n        _this7.track.recentTouch = true;\n        _this7.manageSetTimeout('recentTouchTimer', function () {\n          _this7.track.recentTouch = false;\n        }, _constants.queueTime);\n      };\n\n      // returns true if there are extra touches on the screen\n      var extraTouches = function extraTouches() {\n        return (\n          // if extraTouchNoTap prop and also touching someplace else on the screen, or\n          _this7.p.props.extraTouchNoTap && e.touches.length !== _this7.track.touches.active ||\n          // more touches on RI than maxTapPoints\n          _this7.track.touches.active > _this7.maxTapPoints\n        );\n      };\n\n      // returns true if a touch point has moved more than is allowed for a tap\n      var touchMoved = function touchMoved(endTouch, startTouch, numberOfPoints) {\n        return Math.abs(endTouch.clientX - startTouch.startX) >= 15 + 3 * numberOfPoints || Math.abs(endTouch.clientY - startTouch.startY) >= 15 + 3 * numberOfPoints;\n      };\n\n      // log touch position for each touch point that is part of the touch event\n      var logTouchCoordsAs = function logTouchCoordsAs(logAs) {\n        for (var i = 0; i < e.changedTouches.length; i++) {\n          var point = _this7.track.touches.points[e.changedTouches[i].identifier] || {};\n          point[logAs + 'X'] = e.changedTouches[i].clientX;\n          point[logAs + 'Y'] = e.changedTouches[i].clientY;\n          _this7.track.touches.points[e.changedTouches[i].identifier] = point;\n        }\n      };\n\n      switch (e.type) {\n        case 'touchstart':\n          {\n            this.p.props.onTouchStart && this.p.props.onTouchStart(e);\n            // update number of active touches\n            this.track.touches.active += e.changedTouches.length;\n            if (this.track.touches.tapCanceled) return 'terminate';\n            var newTouchDown = !this.track.touchDown;\n            this.track.touchDown = true;\n            // cancel tap if there was already a touchend in this interaction or there are extra touches\n            if (this.track.touches.touchend || extraTouches()) {\n              // recursively call handleTouchEvent with a touchtapcancel event to set track properties,\n              // call handleTouchEvent directly don't go through handleEvent so updateState isn't called\n              return this.handleTouchEvent({ type: 'touchtapcancel' }) === 'updateState' || newTouchDown ? 'updateState' : 'terminate';\n            }\n\n            // if going from no touch to touch, set touchTapTimer\n            if (newTouchDown) {\n              e.persist();\n              this.manageSetTimeout('touchTapTimer', function () {\n                // if the timer finishes then call onLongPress callback and\n                // fire a touchtapcancel event to cancel the tap,\n                // because this goes through handleEvent, updateState will be called if needed\n                _this7.p.props.onLongPress && _this7.p.props.onLongPress(e);\n                _this7.handleEvent((0, _constants.dummyEvent)('touchtapcancel'));\n              }, this.p.props.tapTimeCutoff);\n            }\n\n            // log touch start position\n            logTouchCoordsAs('start');\n            return 'updateState';\n          }\n\n        case 'touchmove':\n          this.p.props.onTouchMove && this.p.props.onTouchMove(e);\n          if (this.track.touches.tapCanceled) return 'terminate';\n          // cancel tap if there are extra touches\n          if (extraTouches()) return this.handleTouchEvent({ type: 'touchtapcancel' });\n\n          // if touchActiveTapOnly or onLongPress prop,\n          // check to see if the touch moved enough to cancel tap\n          if (this.p.props.touchActiveTapOnly || this.p.props.onLongPress) {\n            for (var i = 0; i < e.changedTouches.length; i++) {\n              var touch = this.track.touches.points[e.changedTouches[i].identifier];\n              if (touch && touchMoved(e.changedTouches[i], touch, this.maxTapPoints)) {\n                return this.handleTouchEvent({ type: 'touchtapcancel' });\n              }\n            }\n          }\n          return 'terminate';\n\n        case 'touchend':\n          // start recent touch timer\n          recentTouch();\n          this.p.props.onTouchEnd && this.p.props.onTouchEnd(e);\n          // update number of active touches\n          this.track.touches.active -= e.changedTouches.length;\n          // if a touch event was dropped somewhere, i.e.\n          // cumulative length of changed touches for touchstarts !== touchends, then reset\n          if (this.track.touches.active < 0 || e.touches.length === 0 && this.track.touches.active > 0) {\n            resetTouchInteraction();\n            return 'updateState';\n          }\n\n          // track that there has been a touchend in this touch interaction\n          this.track.touches.touchend = true;\n\n          // check to see if tap is already canceled or should be canceled\n          if (this.track.touches.active === 0 && (this.track.touches.tapCanceled || extraTouches())) {\n            resetTouchInteraction();\n            return 'updateState';\n          } else if (this.track.touches.tapCanceled) return 'terminate';else if (extraTouches()) return this.handleTouchEvent({ type: 'touchtapcancel' });\n\n          // log touch end position\n          logTouchCoordsAs('client');\n\n          // if there are no remaining touches, then process the touch interaction\n          if (this.track.touches.active === 0) {\n            var touches = this.track.touches.points;\n            var touchKeys = Object.keys(touches);\n            var count = touchKeys.length;\n\n            // determine if there was a tap and number of touch points for the tap\n            // if every touch point hasn't moved, set tapTouchPoints to count\n            var tapTouchPoints = touchKeys.every(function (touch) {\n              return !touchMoved(touches[touch], touches[touch], count);\n            }) ? count : 0;\n\n            // reset the touch interaction\n            resetTouchInteraction();\n\n            switch (tapTouchPoints) {\n              case 1:\n                {\n                  var manageFocusReturn = 'updateState';\n                  // if no active or touchActive prop, let the browser handle click events\n                  if (this.p.props.active || this.p.props.touchActive) {\n                    manageFocusReturn = this.manageFocus('touchclick', e);\n                    this.manageClick('tapClick');\n                  }\n                  return manageFocusReturn;\n                }\n              case 2:\n                this.p.props.onTapTwo && this.p.props.onTapTwo(e);\n                break;\n              case 3:\n                this.p.props.onTapThree && this.p.props.onTapThree(e);\n                break;\n              case 4:\n                this.p.props.onTapFour && this.p.props.onTapFour(e);\n                break;\n              default:\n            }\n          }\n          return 'updateState';\n\n        case 'touchcancel':\n          recentTouch();\n          this.p.props.onTouchCancel && this.p.props.onTouchCancel(e);\n          this.track.touches.active -= e.changedTouches.length;\n\n          // if there are no remaining touches, then reset the touch interaction\n          if (this.track.touches.active === 0) {\n            resetTouchInteraction();\n            return 'updateState';\n          }\n\n          // cancel tap and return whatever touchtapcancel says todo\n          return this.handleTouchEvent({ type: 'touchtapcancel' });\n\n        // cancel tap for this touch interaction\n        case 'touchtapcancel':\n          // clear the touchTapTimer if it's running\n          this.cancelTimeout('touchTapTimer');\n          if (this.track.touchDown) {\n            // set the tap event to canceled\n            this.track.touches.tapCanceled = true;\n            if (this.p.props.touchActiveTapOnly) {\n              // if touchActiveTapOnly prop, exit the touchActive state and updateState\n              this.track.touchDown = false;\n              return 'updateState';\n            }\n          }\n          return 'terminate';\n        default:\n          return 'terminate';\n      }\n    }\n\n    // called in anticipation of a click event (before it's fired) to track the source\n    // of the click event (mouse, touch, key), and synthetically call node.click() if needed\n\n  }, {\n    key: 'manageClick',\n    value: function manageClick(type) {\n      var _this8 = this;\n\n      // clear clickType timer if it's running\n      this.cancelTimeout('clickType');\n\n      // timer to reset the clickType,\n      // when it's left to the browser to call click(), the browser has queueTime\n      // to add the click event to the queue for it to be recognized as a known click event\n      var setClickTypeTimer = function setClickTypeTimer() {\n        _this8.manageSetTimeout('clickType', function () {\n          _this8.track.clickType = 'reset';\n        }, _constants.queueTime);\n      };\n\n      switch (type) {\n        case 'mouseClick':\n          this.track.clickType = 'mouseClick';\n          // let the browser call click() for mouse interactions\n          setClickTypeTimer();\n          break;\n        case 'tapClick':\n          this.track.clickType = 'tapClick';\n          // for touch interactions, use syntheticClick to call node.click() now and\n          // block the subsequent click event created by the browser if there is one\n          (0, _syntheticClick2.default)(this.topNode);\n          this.track.clickType = 'reset';\n          break;\n        case 'keyClick':\n          this.track.clickType = 'keyClick';\n          // if the element has a known interactive role (a, button, input, etc),\n          // then let the browser call click() for keyClick interactions (enter key and/or space bar)\n          if (_constants.knownRoleTags[this.tagName]) {\n            setClickTypeTimer();\n\n            // if the element doesn't have a known interactive role, but there is an onClick prop,\n            // then call node.click() directly as the browser won't fire a click event\n            // from a keyClick interaction\n          } else if (this.p.props.onClick) {\n            this.topNode.click();\n            this.track.clickType = 'reset';\n          }\n          break;\n        default:\n      }\n    }\n\n    // returns 'terminate' if the caller (this.handleEvent) should not call updateState(...)\n    // in almost cases this will return terminate as click events don't change state,\n    // the one exception is an unknown but valid click event from a touch interaction,\n    // which will need to manageFocus, and then return whatever manageFocus says to do\n\n  }, {\n    key: 'handleClickEvent',\n    value: function handleClickEvent(e) {\n      // clear clickType timer if running\n      this.cancelTimeout('clickType');\n      var returnValue = 'terminate';\n      // if this is an unknown click event, make some assumptions\n      if (this.track.clickType === 'reset') {\n        // unknown click event on a form submit input with a recentEnterKeyDown on the document\n        // is considered to be a keyClick (when you press enter to submit a form\n        // but focus is not on the submit button)\n        var enterKeyFormSubmit = this.tagName === 'input' && this.type === 'submit' && _inputTracker2.default.key.recentEnterKeyDown;\n        if (enterKeyFormSubmit) this.track.clickType = 'keyClick';else if (_inputTracker2.default.touch.recentTouch || _inputTracker2.default.touch.touchOnScreen || _constants.deviceType === 'touchOnly') {\n          // if there is a recent touch on the document,\n          // or this is a unknown synthetic click event on a touchOnly device\n          returnValue = this.manageFocus('touchclick', e);\n          this.track.keyClick = 'tapClick';\n          // else this is a unknown synthetic click event on a mouseOnly or hybrid device\n        } else this.track.keyClick = 'mouseClick';\n      }\n\n      // focus is not called on touch tap with links that open in a new window\n      // on pages that have been navigated to with pushState (only tested react router).\n      // So need to simulate a previous focus state of touch and a window blur event by\n      // signing up to be notified of next window focus event.\n      // Note that if navigated to www.example.tld/some-page with pushState link (e.g. RR Link)\n      // then focus is not called on tap, but if do a fresh page load for www.example.tld/some-page\n      // then focus is called on tap before opening the link in a new window (which is really weird).\n      // Note that focus not called means the browser doesn't respect focus calls generated by RI\n      // (and the browser may not generate a focus call itself, results varied by browser).\n      // This is only a problem on Android Chrome because despite not calling focus on link tap,\n      // upon returning to the window, focus is called on the element putting it\n      // into the focusFromTab state, when it should be in the focusFromTouch state.\n      if (this.p.props.target === '_blank' && this.track.clickType === 'tapClick' && !this.track.notifyOfNext.focus) {\n        this.track.previousFocus = 'touch';\n        this.track.notifyOfNext.focus = (0, _notifier.notifyOfNext)('focus', this.handleNotifyOfNext);\n      }\n\n      // call onClick handler and pass in clickType (mouseClick, tapClick, keyClick) as 2nd argument\n      this.p.props.onClick && this.p.props.onClick(e, this.track.clickType);\n      this.track.clickType = 'reset';\n      return returnValue;\n    }\n\n    // returns 'terminate' if the caller (this.handleEvent) should not call updateState(...)\n\n  }, {\n    key: 'handleOtherEvent',\n    value: function handleOtherEvent(e) {\n      switch (e.type) {\n        case 'focus':\n          this.p.props.onFocus && this.p.props.onFocus(e);\n\n          // if this instance of RI is not the focus target, then don't enter the focus state\n          if (e.target !== this.topNode) return 'terminate';\n\n          // if this is a known focusTransition or focus is false,\n          // then set focus based on the type of focusTransition,\n          if (this.track.focusTransition !== 'reset' || !this.track.focus) {\n            var focusTransition = this.track.focusTransition.toLowerCase();\n            if (/mouse/.test(focusTransition)) {\n              this.track.focus = 'mouse';\n            } else if (/touch/.test(focusTransition) || this.track.touchDown) {\n              this.track.focus = 'touch';\n            } else if (this.track.reinstateFocus) {\n              this.track.focus = this.track.previousFocus;\n            } else if (!/forcestate/.test(focusTransition)) {\n              this.track.focus = 'tab';\n            }\n          }\n\n          // if there was a timer set by a recent window focus event, clear it\n          this.cancelTimeout('windowFocus');\n          // only reinstate focus from window blur/focus for next focus event\n          this.track.reinstateFocus = false;\n\n          this.track.focusTransition = 'reset';\n          return 'updateState';\n        case 'blur':\n          this.p.props.onBlur && this.p.props.onBlur(e);\n          if (e.target !== this.topNode) return 'terminate';\n          this.track.focusTransition = 'reset';\n          this.track.previousFocus = this.track.focus;\n          this.track.focus = false;\n          this.track.spaceKeyDown = false;\n          this.track.enterKeyDown = false;\n          return 'updateState';\n        case 'keydown':\n          this.p.props.onKeyDown && this.p.props.onKeyDown(e);\n          if (!this.track.focus) return 'terminate';\n          if (e.key === ' ') this.track.spaceKeyDown = true;else if (e.key === 'Enter') {\n            this.track.enterKeyDown = true;\n            if (this.enterKeyTrigger) this.manageClick('keyClick');\n          } else return 'terminate';\n          return 'updateState';\n        case 'keyup':\n          this.p.props.onKeyUp && this.p.props.onKeyUp(e);\n          if (!this.track.focus) return 'terminate';\n          if (e.key === 'Enter') this.track.enterKeyDown = false;else if (e.key === ' ') {\n            this.track.spaceKeyDown = false;\n            if (this.spaceKeyTrigger) this.manageClick('keyClick');\n          } else return 'terminate';\n          return 'updateState';\n        case 'dragstart':\n          this.p.props.onDragStart && this.p.props.onDragStart(e);\n          this.track.drag = true;\n          return 'updateState';\n        case 'dragend':\n          this.p.props.onDragEnd && this.p.props.onDragEnd(e);\n          this.forceTrackIState('normal');\n          return 'updateState';\n        default:\n          return 'terminate';\n      }\n    }\n  }, {\n    key: 'computeStyle',\n    value: function computeStyle() {\n      // build style object, priority order: state styles, style prop, default styles\n      var style = {};\n      // add default styles first:\n      // if focusFromTab prop provided, then reset browser focus style,\n      // otherwise only reset it when focus is not from tab\n      if (!this.p.props.useBrowserOutlineFocus && (this.p.props.focusFromTab || this.state.focus !== 'tab' && !_constants.nonBlurrableTags[this.tagName])) {\n        style.outline = 0;\n        style.outlineOffset = 0;\n      }\n      // if touchActive or active prop provided, then reset webkit tap highlight style\n      if ((this.p.props.touchActive || this.p.props.active) && _constants.deviceHasTouch) {\n        style.WebkitTapHighlightColor = 'rgba(0, 0, 0, 0)';\n      }\n      // set cursor to pointer if clicking does something\n      var lowerAs = typeof this.p.props.as === 'string' && this.p.props.as.toLowerCase();\n      if (!this.p.props.useBrowserCursor && (this.p.props.onClick || lowerAs !== 'input' && this.p.props.tabIndex && (this.p.mouseFocusStyle.style || this.p.mouseFocusStyle.className) || lowerAs === 'input' && (this.p.props.type === 'checkbox' || this.p.props.type === 'radio' || this.p.props.type === 'submit') || lowerAs === 'button' || lowerAs === 'a' || lowerAs === 'area' || lowerAs === 'select') && !this.p.props.disabled) {\n        style.cursor = 'pointer';\n      }\n\n      // add style prop styles second:\n      (0, _objectAssign2.default)(style, this.p.props.style);\n\n      // add iState and focus state styles third:\n      // focus has priority over iState styles unless overridden in stylePriority\n      var hasPriority = this.state.iState === 'keyActive' || this.p.props.stylePriority && this.p.props.stylePriority[this.state.iState];\n      var iStateStyle = this.p[this.state.iState + 'Style'].style;\n      var focusStyle = this.state.focus ? this.p[this.state.focus + 'FocusStyle'].style : null;\n      if (hasPriority) {\n        (0, _objectAssign2.default)(style, focusStyle, iStateStyle);\n      } else {\n        (0, _objectAssign2.default)(style, iStateStyle, focusStyle);\n      }\n      return style;\n    }\n  }, {\n    key: 'computeClassName',\n    value: function computeClassName() {\n      // build className string, union of class names from className prop, iState className,\n      // and focus className (if in the focus state)\n      return (0, _extractStyle.joinClasses)(this.p.props.className || '', this.p[this.state.iState + 'Style'].className, this.state.focus ? this.p[this.state.focus + 'FocusStyle'].className : '');\n    }\n\n    // compute children when there is an interactiveChild prop, returns the new children\n\n  }, {\n    key: 'computeChildren',\n    value: function computeChildren() {\n      var _this9 = this;\n\n      // convert this.state.focus to the string focusFrom[Type] for use later\n      var focusFrom = this.state.focus && 'focusFrom' + this.state.focus.charAt(0).toUpperCase() + this.state.focus.slice(1);\n      // does the current iState style have priority over the focus state style\n      var iStateStylePriority = this.p.props.stylePriority && this.p.props.stylePriority[this.state.iState];\n\n      var computeChildStyle = function computeChildStyle(props) {\n        var style = props.style ? _extends({}, props.style) : {};\n        (0, _extractStyle.setActiveAndFocusProps)(props);\n        var iStateStyle = (0, _extractStyle.extractStyle)(props, _this9.state.iState);\n        var focusStyle = _this9.state.focus && (0, _extractStyle.extractStyle)(props, focusFrom);\n\n        return {\n          className: (0, _extractStyle.joinClasses)(props.className || '', iStateStyle.className, focusStyle && focusStyle.className || ''),\n          style: iStateStylePriority && (0, _objectAssign2.default)(style, focusStyle.style, iStateStyle.style) || (0, _objectAssign2.default)(style, iStateStyle.style, focusStyle.style)\n        };\n      };\n\n      // recurse and map children, if child is an Interactive component, then don't recurse into\n      // it's children\n      var recursiveMap = function recursiveMap(children) {\n        return _react2.default.Children.map(children, function (child) {\n          if (!_react2.default.isValidElement(child)) return child;\n\n          // if the child should not be shown, then return null\n          if (child.props.showOnParent) {\n            var showOn = child.props.showOnParent.split(' ');\n            if (!showOn.some(function (el) {\n              return el === _this9.state.iState || /Active/.test(_this9.state.iState) && el === 'active' || _this9.state.focus && (el === focusFrom || el === 'focus');\n            })) {\n              return null;\n            }\n          }\n\n          var childPropKeys = Object.keys(child.props);\n\n          // if the child doesn't have any interactive child props, then return the child\n          if (!childPropKeys.some(function (key) {\n            return _constants.childInteractiveProps[key];\n          })) {\n            if (child.type === Interactive) return child;\n            // if the child is not an Interactive component, then still recuse into its children\n            return _react2.default.cloneElement(child, {}, recursiveMap(child.props.children));\n          }\n\n          var newChildProps = {};\n          var childStyleProps = {};\n          // separate child props to pass through (newChildProps), from props used\n          // to compute the child's style (childStyleProps)\n          childPropKeys.forEach(function (key) {\n            if (!_constants.childInteractiveProps[key]) newChildProps[key] = child.props[key];else if (key !== 'showOnParent') {\n              childStyleProps['' + key.slice(8).charAt(0).toLowerCase() + key.slice(9)] = child.props[key];\n            }\n          });\n\n          childStyleProps.style = child.props.style;\n          childStyleProps.className = child.props.className;\n\n          var _computeChildStyle = computeChildStyle(childStyleProps),\n              style = _computeChildStyle.style,\n              className = _computeChildStyle.className;\n\n          newChildProps.style = style;\n          if (className) newChildProps.className = className;\n\n          // can't use cloneElement because not possible to delete existing child prop,\n          // e.g. need to delete the prop onParentHover from the child\n          return _react2.default.createElement(child.type, newChildProps, child.type === Interactive ? child.props.children : recursiveMap(child.props.children));\n        });\n      };\n\n      return recursiveMap(this.p.props.children);\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      // props to pass down:\n      // passThroughProps (includes event handlers)\n      // style\n      // className\n      this.p.passThroughProps.style = this.computeStyle();\n      var className = this.computeClassName();\n      if (className) this.p.passThroughProps.className = className;\n\n      var children = this.p.props.interactiveChild ? this.computeChildren() : this.p.props.children;\n\n      // if `as` is a string (i.e. DOM tag name), then add the ref to props and render `as`\n      if (typeof this.p.props.as === 'string') {\n        this.p.passThroughProps.ref = this.refCallback;\n        return _react2.default.createElement(this.p.props.as, this.p.passThroughProps, children);\n      }\n      // If `as` is a ReactClass or a ReactFunctionalComponent, then wrap it in a span\n      // so can access the DOM node without breaking encapsulation\n      return _react2.default.createElement('span', {\n        ref: this.refCallback,\n        style: this.p.props.wrapperStyle,\n        className: this.p.props.wrapperClassName\n      }, _react2.default.createElement(this.p.props.as, this.p.passThroughProps, children));\n    }\n  }]);\n\n  return Interactive;\n}(_react2.default.Component);\n\nInteractive.propTypes = _propTypes.propTypes;\nInteractive.defaultProps = _propTypes.defaultProps;\nexports.default = Interactive;\nmodule.exports = exports['default'];//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDE0LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWludGVyYWN0aXZlL2xpYi9pbmRleC5qcz81NWJiIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG52YXIgX29iamVjdEFzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIF9vYmplY3RBc3NpZ24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfb2JqZWN0QXNzaWduKTtcblxudmFyIF9wcm9wVHlwZXMgPSByZXF1aXJlKCcuL3Byb3BUeXBlcycpO1xuXG52YXIgX2NvbXBhcmVQcm9wcyA9IHJlcXVpcmUoJy4vY29tcGFyZVByb3BzJyk7XG5cbnZhciBfY29tcGFyZVByb3BzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NvbXBhcmVQcm9wcyk7XG5cbnZhciBfbWVyZ2VBbmRFeHRyYWN0UHJvcHMyID0gcmVxdWlyZSgnLi9tZXJnZUFuZEV4dHJhY3RQcm9wcycpO1xuXG52YXIgX21lcmdlQW5kRXh0cmFjdFByb3BzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX21lcmdlQW5kRXh0cmFjdFByb3BzMik7XG5cbnZhciBfZXh0cmFjdFN0eWxlID0gcmVxdWlyZSgnLi9leHRyYWN0U3R5bGUnKTtcblxudmFyIF9yZWN1cnNpdmVOb2RlQ2hlY2sgPSByZXF1aXJlKCcuL3JlY3Vyc2l2ZU5vZGVDaGVjaycpO1xuXG52YXIgX3JlY3Vyc2l2ZU5vZGVDaGVjazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWN1cnNpdmVOb2RlQ2hlY2spO1xuXG52YXIgX2lucHV0VHJhY2tlciA9IHJlcXVpcmUoJy4vaW5wdXRUcmFja2VyJyk7XG5cbnZhciBfaW5wdXRUcmFja2VyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2lucHV0VHJhY2tlcik7XG5cbnZhciBfbm90aWZpZXIgPSByZXF1aXJlKCcuL25vdGlmaWVyJyk7XG5cbnZhciBfc3ludGhldGljQ2xpY2sgPSByZXF1aXJlKCcuL3N5bnRoZXRpY0NsaWNrJyk7XG5cbnZhciBfc3ludGhldGljQ2xpY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc3ludGhldGljQ2xpY2spO1xuXG52YXIgX2NvbnN0YW50cyA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIEludGVyYWN0aXZlID0gZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKEludGVyYWN0aXZlLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBJbnRlcmFjdGl2ZShwcm9wcykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJbnRlcmFjdGl2ZSk7XG5cbiAgICAvLyBzdGF0ZSBpcyBhbHdheXMgYW4gb2JqZWN0IHdpdGggdHdvIGtleXMsIGBpU3RhdGVgIGFuZCBgZm9jdXNgXG4gICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKEludGVyYWN0aXZlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoSW50ZXJhY3RpdmUpKS5jYWxsKHRoaXMsIHByb3BzKSk7XG5cbiAgICBfdGhpcy5yZWZDYWxsYmFjayA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICBfdGhpcy5yZWZOb2RlID0gbm9kZTtcbiAgICAgIGlmIChub2RlKSB7XG4gICAgICAgIHZhciBwcmV2VG9wTm9kZSA9IF90aGlzLnRvcE5vZGU7XG4gICAgICAgIC8vIGlmIGBhc2AgaXMgYSBjb21wb25lbnQsIHRoZW4gdGhlIGByZWZOb2RlYCBpcyB0aGUgc3BhbiB3cmFwcGVyLCBzbyBnZXQgaXRzIGZpcnN0Q2hpbGRcbiAgICAgICAgaWYgKHR5cGVvZiBfdGhpcy5wLnByb3BzLmFzICE9PSAnc3RyaW5nJykgX3RoaXMudG9wTm9kZSA9IG5vZGUuZmlyc3RDaGlsZDtlbHNlIF90aGlzLnRvcE5vZGUgPSBub2RlO1xuICAgICAgICBfdGhpcy50YWdOYW1lID0gX3RoaXMudG9wTm9kZS50YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIF90aGlzLnR5cGUgPSBfdGhpcy50b3BOb2RlLnR5cGUgJiYgX3RoaXMudG9wTm9kZS50eXBlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIF90aGlzLmVudGVyS2V5VHJpZ2dlciA9ICgwLCBfY29uc3RhbnRzLmVudGVyS2V5VHJpZ2dlcikoX3RoaXMudGFnTmFtZSwgX3RoaXMudHlwZSk7XG4gICAgICAgIF90aGlzLnNwYWNlS2V5VHJpZ2dlciA9ICgwLCBfY29uc3RhbnRzLnNwYWNlS2V5VHJpZ2dlcikoX3RoaXMudGFnTmFtZSwgX3RoaXMudHlwZSk7XG4gICAgICAgIC8vIGlmIGFzIGlzIGEgcmVhY3QgY29tcG9uZW50IHRoZW4gd29uJ3QgaGF2ZSBhY2Nlc3MgdG8gdGFnIGluIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMsXG4gICAgICAgIC8vIHNvIGNoZWNrIGlmIGNsaWNrIGxpc3RlbmVyIG5lZWRzIHRvIGJlIHNldCBhZ2FpbiBoZXJlIChhZnRlciB0aGlzLnRhZ05hbWUgaXMgc2V0KVxuICAgICAgICBpZiAoX3RoaXMuc2V0Q2xpY2tMaXN0ZW5lcihfdGhpcy5wLnByb3BzKSkgX3RoaXMucC5wYXNzVGhyb3VnaFByb3BzLm9uQ2xpY2sgPSBfdGhpcy5oYW5kbGVFdmVudDtcbiAgICAgICAgLy8gaWYgbm9kZSBpcyBhIG5ldyBub2RlIHRoZW4gY2FsbCBtYW5hZ2VGb2N1cyB0byBrZWVwIGJyb3dzZXIgaW4gc3luYyB3aXRoIFJJLFxuICAgICAgICAvLyBub3RlOiBhYm92ZSBhc3NpZ25tZW50cyBjYW4ndCBiZSBpbiB0aGlzIGlmIHN0YXRlbWVudCBiL2Mgbm9kZSBjb3VsZCBoYXZlIG11dGF0ZWQsXG4gICAgICAgIC8vIG5vZGUgc2hvdWxkIG1haW50YWluIGZvY3VzIHN0YXRlIHdoZW4gbXV0YXRlZFxuICAgICAgICBpZiAocHJldlRvcE5vZGUgIT09IF90aGlzLnRvcE5vZGUpIHtcbiAgICAgICAgICBfdGhpcy5tYW5hZ2VGb2N1cygncmVmQ2FsbGJhY2snKTtcbiAgICAgICAgICAvLyBpZiByZWZET01Ob2RlIHByb3AsIHBhc3MgYWxvbmcgbmV3IERPTSBub2RlXG4gICAgICAgICAgX3RoaXMucC5wcm9wcy5yZWZET01Ob2RlICYmIF90aGlzLnAucHJvcHMucmVmRE9NTm9kZShfdGhpcy50b3BOb2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBfdGhpcy5oYW5kbGVFdmVudCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAoIV90aGlzLmlzVmFsaWRFdmVudChlKSkgcmV0dXJuO1xuXG4gICAgICBpZiAoX2NvbnN0YW50cy5tb3VzZUV2ZW50c1tlLnR5cGVdKSB7XG4gICAgICAgIGlmIChfdGhpcy5oYW5kbGVNb3VzZUV2ZW50KGUpID09PSAndGVybWluYXRlJykgcmV0dXJuO1xuICAgICAgfSBlbHNlIGlmIChfY29uc3RhbnRzLnRvdWNoRXZlbnRzW2UudHlwZV0gfHwgZS50eXBlID09PSAndG91Y2htb3ZlJyB8fCBlLnR5cGUgPT09ICd0b3VjaHRhcGNhbmNlbCcpIHtcbiAgICAgICAgaWYgKF90aGlzLmhhbmRsZVRvdWNoRXZlbnQoZSkgPT09ICd0ZXJtaW5hdGUnKSByZXR1cm47XG4gICAgICB9IGVsc2UgaWYgKGUudHlwZSA9PT0gJ2NsaWNrJykge1xuICAgICAgICBpZiAoX3RoaXMuaGFuZGxlQ2xpY2tFdmVudChlKSA9PT0gJ3Rlcm1pbmF0ZScpIHJldHVybjtcbiAgICAgIH0gZWxzZSBpZiAoX3RoaXMuaGFuZGxlT3RoZXJFdmVudChlKSA9PT0gJ3Rlcm1pbmF0ZScpIHJldHVybjtcblxuICAgICAgLy8gY29tcHV0ZSB0aGUgbmV3IHN0YXRlIG9iamVjdCBhbmQgcGFzcyBpdCBhcyBhbiBhcmd1bWVudCB0byB1cGRhdGVTdGF0ZSxcbiAgICAgIC8vIHdoaWNoIGNhbGxzIHNldFN0YXRlIGFuZCBzdGF0ZSBjaGFuZ2UgY2FsbGJhY2tzIGlmIG5lZWRlZFxuICAgICAgX3RoaXMudXBkYXRlU3RhdGUoX3RoaXMuY29tcHV0ZVN0YXRlKCksIF90aGlzLnAucHJvcHMsIGUpO1xuICAgIH07XG5cbiAgICBfdGhpcy5oYW5kbGVOb3RpZnlPZk5leHQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgdmFyIHVwZGF0ZVN0YXRlID0gZmFsc2U7XG5cbiAgICAgIHN3aXRjaCAoZS50eXBlKSB7XG4gICAgICAgIGNhc2UgJ3Njcm9sbCc6XG4gICAgICAgIGNhc2UgJ21vdXNlZW50ZXInOlxuICAgICAgICBjYXNlICdtdXRhdGlvbic6XG4gICAgICAgICAgLy8gY2hlY2sgbW91c2UgcG9zaXRpb24sIGlmIGl0J3Mgc3RpbGwgb24gUkksIHRoZW4gcmVOb3RpZnlPZk5leHQsIGVsc2UgdXBkYXRlU3RhdGVcbiAgICAgICAgICBpZiAoX3RoaXMudHJhY2subW91c2VPbiAmJiBfdGhpcy5jaGVja01vdXNlUG9zaXRpb24oKSA9PT0gJ21vdXNlT24nKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3JlTm90aWZ5T2ZOZXh0JztcbiAgICAgICAgICB9XG4gICAgICAgICAgX3RoaXMudHJhY2subW91c2VPbiA9IGZhbHNlO1xuICAgICAgICAgIF90aGlzLnRyYWNrLmJ1dHRvbkRvd24gPSBmYWxzZTtcbiAgICAgICAgICB1cGRhdGVTdGF0ZSA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAndG91Y2hzdGFydCc6XG4gICAgICAgICAgLy8gY2FuY2VsIHRhcCBpZiBleHRyYSB0b3VjaCBwb2ludCwgb3Igd2hlbiB0b3VjaCBzb21lcGxhY2UgZWxzZSBvbiB0aGUgc2NyZWVuXG4gICAgICAgICAgLy8gY2hlY2sgdG9wTm9kZSBhbmQgY2hpbGRyZW4gdG8gbWFrZSBzdXJlIHRoZXkgd2VyZW4ndCB0aGUgdGFyZ2V0XG4gICAgICAgICAgaWYgKF90aGlzLnAucHJvcHMuZXh0cmFUb3VjaE5vVGFwKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMudHJhY2sudG91Y2hlcy5hY3RpdmUgPCBfdGhpcy5tYXhUYXBQb2ludHMgJiYgKDAsIF9yZWN1cnNpdmVOb2RlQ2hlY2syLmRlZmF1bHQpKF90aGlzLnRvcE5vZGUsIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgIHJldHVybiBlLnRhcmdldCA9PT0gbm9kZTtcbiAgICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICAgIHJldHVybiAncmVOb3RpZnlPZk5leHQnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdXBkYXRlU3RhdGUgPSBfdGhpcy5oYW5kbGVUb3VjaEV2ZW50KHsgdHlwZTogJ3RvdWNodGFwY2FuY2VsJyB9KSA9PT0gJ3VwZGF0ZVN0YXRlJztcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnZHJhZ3N0YXJ0JzpcbiAgICAgICAgICAvLyB1c2Ugc2V0VGltZW91dCBiZWNhdXNlIG5vdGlmaWVyIGRyYWcgZXZlbnQgd2lsbCBmaXJlIGJlZm9yZSB0aGUgZHJhZyBldmVudCBvbiBSSSxcbiAgICAgICAgICAvLyBzbyB3L28gdGltZW91dCB3aGVuIHRoaXMgaW50YW5jZSBvZiBSSSBpcyBkcmFnZ2VkIGl0IHdvdWxkIGdvOlxuICAgICAgICAgIC8vIGFjdGl2ZSAtPiBmb3JjZSBub3JtYWwgZnJvbSBub3RpZmllciBkcmFnIC0+IGFjdGl2ZSBmcm9tIFJJJ3MgZHJhZyBldmVudCxcbiAgICAgICAgICAvLyBidXQgdGhlIHRpbWVvdXQgd2lsbCBhbGxvdyB0aW1lIGZvciBSSSdzIGRyYWcgZXZlbnQgdG8gZmlyZSBiZWZvcmUgZm9yY2Ugbm9ybWFsXG4gICAgICAgICAgX3RoaXMubWFuYWdlU2V0VGltZW91dCgnZHJhZ3N0YXJ0JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCFfdGhpcy50cmFjay5kcmFnKSB7XG4gICAgICAgICAgICAgIF90aGlzLmZvcmNlVHJhY2tJU3RhdGUoJ25vcm1hbCcpO1xuICAgICAgICAgICAgICBfdGhpcy51cGRhdGVTdGF0ZShfdGhpcy5jb21wdXRlU3RhdGUoKSwgX3RoaXMucC5wcm9wcywgZSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgMzApO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIC8vIHdpbmRvdyBmb2N1cyBldmVudFxuICAgICAgICBjYXNlICdmb2N1cyc6XG4gICAgICAgICAgLy8gcmVpbnN0YXRlIHByZXZpb3VzIGZvY3VzIHN0YXRlIGlmIHRoaXMgd2luZG93IGZvY3VzIGV2ZW50IGlzIGZvbGxvd2VkIGJ5XG4gICAgICAgICAgLy8gYW4gZWxlbWVudCBmb2N1cyBldmVudCwgb3RoZXJ3aXNlIGNhbmNlbCBmb2N1cyByZWluc3RhdGVtZW50XG4gICAgICAgICAgaWYgKF90aGlzLnRyYWNrLnByZXZpb3VzRm9jdXMgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICBfdGhpcy50cmFjay5yZWluc3RhdGVGb2N1cyA9IHRydWU7XG4gICAgICAgICAgICBfdGhpcy5tYW5hZ2VTZXRUaW1lb3V0KCd3aW5kb3dGb2N1cycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgX3RoaXMudHJhY2sucmVpbnN0YXRlRm9jdXMgPSBmYWxzZTtcbiAgICAgICAgICAgIH0sIF9jb25zdGFudHMucXVldWVUaW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgLy8gd2luZG93IGJsdXIgZXZlbnQgdG8gcHJlc2VydmUgdGhlIGZvY3VzIHN0YXRlXG4gICAgICAgIGNhc2UgJ2JsdXInOlxuICAgICAgICAgIC8vIGNsZWFyIHRoZSB0aW1lciBzZXQgaW4gbWFuYWdlTm90aWZ5T2ZOZXh0IHRoYXQgd2FzIHNldCB0byBjYW5jZWwgdGhpcyBub3RpZmljYXRpb25cbiAgICAgICAgICBfdGhpcy5jYW5jZWxUaW1lb3V0KCdlbGVtZW50Qmx1cicpO1xuICAgICAgICAgIC8vIG5vdGlmaXkgb2YgdGhlIG5leHQgd2luZG93IGZvY3VzIGV2ZW50IChyZS1lbnRlcmluZyB0aGUgYXBwL3dpbmRvdy90YWIpXG4gICAgICAgICAgaWYgKCFfdGhpcy50cmFjay5ub3RpZnlPZk5leHQuZm9jdXMpIHtcbiAgICAgICAgICAgIF90aGlzLnRyYWNrLm5vdGlmeU9mTmV4dC5mb2N1cyA9ICgwLCBfbm90aWZpZXIubm90aWZ5T2ZOZXh0KSgnZm9jdXMnLCBfdGhpcy5oYW5kbGVOb3RpZnlPZk5leHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgIH1cblxuICAgICAgaWYgKHVwZGF0ZVN0YXRlKSBfdGhpcy51cGRhdGVTdGF0ZShfdGhpcy5jb21wdXRlU3RhdGUoKSwgX3RoaXMucC5wcm9wcywgZSwgdHJ1ZSk7XG4gICAgICBkZWxldGUgX3RoaXMudHJhY2subm90aWZ5T2ZOZXh0W2UudHlwZV07XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuXG4gICAgX3RoaXMuc3RhdGUgPSB7XG4gICAgICAvLyBpU3RhdGUgaXMgYWx3YXlzIDEgb2YgNSBzdHJpbmdzOlxuICAgICAgLy8gJ25vcm1hbCcsICdob3ZlcicsICdob3ZlckFjdGl2ZScsICd0b3VjaEFjdGl2ZScsICdrZXlBY3RpdmUnXG4gICAgICBpU3RhdGU6ICdub3JtYWwnLFxuICAgICAgLy8gZm9jdXMgaXMgYWx3YXlzIDEgb2YgNCB2YWx1ZXM6IGZhbHNlLCAndGFiJywgJ21vdXNlJyBvciAndG91Y2gnXG4gICAgICBmb2N1czogZmFsc2VcbiAgICB9O1xuXG4gICAgLy8gdGhpbmdzIHRvIGtlZXAgdHJhY2sgb2Ygc28gUkkga25vd3Mgd2hhdCB0byBkbyB3aGVuXG4gICAgX3RoaXMudHJhY2sgPSB7XG4gICAgICB0b3VjaERvd246IGZhbHNlLFxuICAgICAgcmVjZW50VG91Y2g6IGZhbHNlLFxuICAgICAgdG91Y2hlczogeyBwb2ludHM6IHt9LCBhY3RpdmU6IDAgfSxcbiAgICAgIG1vdXNlT246IGZhbHNlLFxuICAgICAgYnV0dG9uRG93bjogZmFsc2UsXG4gICAgICBjbGlja1R5cGU6ICdyZXNldCcsXG4gICAgICBmb2N1czogZmFsc2UsXG4gICAgICBwcmV2aW91c0ZvY3VzOiBmYWxzZSxcbiAgICAgIHJlaW5zdGF0ZUZvY3VzOiBmYWxzZSxcbiAgICAgIGZvY3VzVHJhbnNpdGlvbjogJ3Jlc2V0JyxcbiAgICAgIGZvY3VzU3RhdGVPbk1vdXNlRG93bjogZmFsc2UsXG4gICAgICBzcGFjZUtleURvd246IGZhbHNlLFxuICAgICAgZW50ZXJLZXlEb3duOiBmYWxzZSxcbiAgICAgIGRyYWc6IGZhbHNlLFxuICAgICAgdXBkYXRlVG9wTm9kZTogZmFsc2UsXG4gICAgICBub3RpZnlPZk5leHQ6IHt9LFxuICAgICAgdGltZW91dElEczoge30sXG4gICAgICBzdGF0ZTogX3RoaXMuc3RhdGVcbiAgICB9O1xuXG4gICAgLy8gdGhlIG5vZGUgcmV0dXJuZWQgYnkgdGhlIHJlZiBjYWxsYmFja1xuICAgIF90aGlzLnJlZk5vZGUgPSBudWxsO1xuICAgIC8vIHRoZSBhY3R1YWwgdG9wIERPTSBub2RlIG9mIGBhc2AsIG5lZWRlZCB3aGVuIGBhc2AgaXMgd3JhcHBlZCBpbiBhIHNwYW4gKGlzIFJlYWN0Q29tcG9uZW50KVxuICAgIF90aGlzLnRvcE5vZGUgPSBudWxsO1xuICAgIC8vIHRhZ05hbWUgYW5kIHR5cGUgcHJvcGVydGllcyBvZiB0b3BOb2RlLCB1cGRhdGVkIGluIHJlZkNhbGxiYWNrXG4gICAgX3RoaXMudGFnTmFtZSA9IHR5cGVvZiBwcm9wcy5hcyA9PT0gJ3N0cmluZycgJiYgcHJvcHMuYXMgfHwgJyc7XG4gICAgX3RoaXMudHlwZSA9IHByb3BzLnR5cGUgfHwgJyc7XG4gICAgLy8gaWYgdGhlIHRvcE5vZGUgaXMgdHJpZ2dlcmVkIGJ5IHRoZSBlbnRlciBrZXksIGFuZC9vciB0aGUgc3BhY2UgYmFyXG4gICAgX3RoaXMuZW50ZXJLZXlUcmlnZ2VyID0gZmFsc2U7XG4gICAgX3RoaXMuc3BhY2VLZXlUcmlnZ2VyID0gZmFsc2U7XG5cbiAgICAvLyBtYXhpbXVtIG51bWJlciBvZiB0b3VjaCBwb2ludHMgd2hlcmUgYSB0YXAgaXMgc3RpbGwgcG9zc2libGUsIHVwZGF0ZWQgaW4gcHJvcHNTZXR1cFxuICAgIF90aGlzLm1heFRhcFBvaW50cyA9IDE7XG5cbiAgICAvLyB0aGUgZXZlbnQgaGFuZGxlcnMgdG8gcGFzcyBkb3duIGFzIHByb3BzIHRvIHRoZSBlbGVtZW50L2NvbXBvbmVudFxuICAgIF90aGlzLmV2ZW50SGFuZGxlcnMgPSBfdGhpcy5zZXR1cEV2ZW50SGFuZGxlcnMoKTtcblxuICAgIC8vIHRoaXMucCBpcyB1c2VkIHRvIHN0b3JlIHRoaW5ncyB0aGF0IGFyZSBhIGRldGVybWluaXN0aWMgZnVuY3Rpb24gb2YgcHJvcHNcbiAgICAvLyB0byBhdm9pZCByZWNhbGN1bGF0aW5nIGV2ZXJ5IHRpbWUgdGhleSBhcmUgbmVlZGVkLCBpdCBjYW4gYmUgdGhvdWdodCBvZiBhcyBhIHB1cmVcbiAgICAvLyBleHRlbnNpb24gdG8gcHJvcHMgYW5kIGlzIG9ubHkgdXBkYXRlZCBpbiB0aGUgY29uc3RydWN0b3IgYW5kIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNcbiAgICBfdGhpcy5wID0geyBzYW1lUHJvcHM6IGZhbHNlIH07XG4gICAgLy8gc2V0IHByb3BlcnRpZXMgb2YgYHRoaXMucGBcbiAgICBfdGhpcy5wcm9wc1NldHVwKHByb3BzKTtcbiAgICAvLyBpZiBpbml0aWFsU3RhdGUgcHJvcCwgdXBkYXRlIHN0YXRlLmlTdGF0ZSBmb3IgaW5pdGlhbCByZW5kZXIsIG5vdGUgdGhhdCBzdGF0ZS5mb2N1c1xuICAgIC8vIHdpbGwgYmUgdXBkYXRlZCBpbiBjb21wb25lbnREaWRNb3VudCBiL2MgY2FuJ3QgY2FsbCBmb2N1cyB1bnRpbCBoYXZlIHJlZiB0byBET00gbm9kZVxuICAgIGlmIChfdGhpcy5wLnByb3BzLmluaXRpYWxTdGF0ZSAmJiBfdGhpcy5wLnByb3BzLmluaXRpYWxTdGF0ZS5pU3RhdGUpIHtcbiAgICAgIF90aGlzLmZvcmNlVHJhY2tJU3RhdGUoX3RoaXMucC5wcm9wcy5pbml0aWFsU3RhdGUuaVN0YXRlKTtcbiAgICAgIF90aGlzLnN0YXRlID0gX3RoaXMuY29tcHV0ZVN0YXRlKCk7XG4gICAgfVxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhJbnRlcmFjdGl2ZSwgW3tcbiAgICBrZXk6ICdjb21wb25lbnREaWRNb3VudCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgLy8gZW50ZXIgZm9jdXMgc3RhdGUgaWYgaW5pdGlhbFN0YXRlLmZvY3VzIC0gY2FsbGVkIGhlcmUgaW5zdGVhZCBvZiBjb25zdHJ1Y3RvclxuICAgICAgLy8gYmVjYXVzZSBjYW4ndCBjYWxsIGZvY3VzIHVudGlsIGhhdmUgcmVmIHRvIERPTSBub2RlXG4gICAgICBpZiAodGhpcy5wLnByb3BzLmluaXRpYWxTdGF0ZSAmJiB0aGlzLnAucHJvcHMuaW5pdGlhbFN0YXRlLmZvY3VzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5mb3JjZVN0YXRlKHsgZm9jdXM6IHRoaXMucC5wcm9wcy5pbml0aWFsU3RhdGUuZm9jdXMgfSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzKSB7XG4gICAgICAvLyBzZXQgaWYgdGhlIGB0b3BOb2RlYCBuZWVkcyB0byBiZSB1cGRhdGVkIGluIGNvbXBvbmVudERpZFVwZGF0ZSA9PiBgYXNgIGlzIGRpZmZlcmVudFxuICAgICAgLy8gYW5kIG5vdCBhIHN0cmluZywgbm90ZSB0aGF0IGlmIGBhc2AgaXMgYSBuZXcgc3RyaW5nLCB0aGVuIHRoZSBgcmVmQ2FsbGJhY2tgXG4gICAgICAvLyB3aWxsIGJlIGNhbGxlZCBieSBSZWFjdCBzbyBubyBuZWVkIHRvIGRvIGFueXRoaW5nIGluIGNvbXBvbmVudERpZFVwZGF0ZVxuICAgICAgdGhpcy50cmFjay51cGRhdGVUb3BOb2RlID0gdGhpcy5wcm9wcy5hcyAhPT0gbmV4dFByb3BzLmFzICYmIHR5cGVvZiB0aGlzLnByb3BzLmFzICE9PSAnc3RyaW5nJyAmJiB0eXBlb2YgbmV4dFByb3BzLmFzICE9PSAnc3RyaW5nJztcblxuICAgICAgLy8gY2hlY2sgaWYgbmV4dFByb3BzIGFyZSB0aGUgc2FtZSBhcyB0aGlzLnByb3BzXG4gICAgICB0aGlzLnAuc2FtZVByb3BzID0gZmFsc2U7XG4gICAgICBpZiAoIW5leHRQcm9wcy5tdXRhYmxlUHJvcHMgJiYgKDAsIF9jb21wYXJlUHJvcHMyLmRlZmF1bHQpKHRoaXMucHJvcHMsIG5leHRQcm9wcykpIHtcbiAgICAgICAgdGhpcy5wLnNhbWVQcm9wcyA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBpZiBub3Qgc2FtZSBwcm9wcywgZG8gcHJvcHMgc2V0dXAgPT4gc2V0IHByb3BlcnRpZXMgb2YgYHRoaXMucGBcbiAgICAgICAgdGhpcy5wcm9wc1NldHVwKG5leHRQcm9wcyk7XG4gICAgICB9XG5cbiAgICAgIC8vIGlmIGBmb3JjZVN0YXRlYCBwcm9wLCB0aGVuIGZvcmNlIHVwZGF0ZSBzdGF0ZVxuICAgICAgaWYgKHRoaXMucC5wcm9wcy5mb3JjZVN0YXRlKSB0aGlzLmZvcmNlU3RhdGUodGhpcy5wLnByb3BzLmZvcmNlU3RhdGUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3Nob3VsZENvbXBvbmVudFVwZGF0ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNob3VsZENvbXBvbmVudFVwZGF0ZShuZXh0UHJvcHMsIG5leHRTdGF0ZSkge1xuICAgICAgLy8gb3Igc3RhdGVtZW50LCByZXR1cm5zIHRydWUgb24gZmlyc3QgdHJ1ZSB2YWx1ZSwgcmV0dXJucyBmYWxzZSBpZiBhbGwgYXJlIGZhbHNlXG4gICAgICByZXR1cm4gKFxuICAgICAgICAvLyByZXR1cm4gdHJ1ZSBpZiBwcm9wcyBoYXZlIGNoYW5nZWQgc2luY2UgbGFzdCByZW5kZXJcbiAgICAgICAgIXRoaXMucC5zYW1lUHJvcHMgJiYgbmV4dFByb3BzICE9PSB0aGlzLnByb3BzIHx8XG4gICAgICAgIC8vIGFsd2F5cyB1cGRhdGUgaWYgdGhlcmUgYXJlIGludGVyYWN0aXZlIGNoaWxkcmVuXG4gICAgICAgIG5leHRQcm9wcy5pbnRlcmFjdGl2ZUNoaWxkIHx8XG4gICAgICAgIC8vIGlmIGBpU3RhdGVgIGNoYW5nZWQsIEFORCB0aGUgYHN0eWxlYCBvciBgY2xhc3NOYW1lYCBmb3IgdGhlIG5ldyBgaVN0YXRlYCBpcyBkaWZmZXJlbnQsXG4gICAgICAgIC8vIHByZXZlbnRzIHJlbmRlcnMgd2hlbiBzd2l0Y2hpbmcgYi90IHR3byBzdGF0ZXMgdGhhdCBoYXZlIHRoZSBzYW1lIGBzdHlsZWAgYW5kIGBjbGFzc05hbWVgXG4gICAgICAgIG5leHRTdGF0ZS5pU3RhdGUgIT09IHRoaXMuc3RhdGUuaVN0YXRlICYmICh0aGlzLnBbbmV4dFN0YXRlLmlTdGF0ZSArICdTdHlsZSddLnN0eWxlICE9PSB0aGlzLnBbdGhpcy5zdGF0ZS5pU3RhdGUgKyAnU3R5bGUnXS5zdHlsZSB8fCB0aGlzLnBbbmV4dFN0YXRlLmlTdGF0ZSArICdTdHlsZSddLmNsYXNzTmFtZSAhPT0gdGhpcy5wW3RoaXMuc3RhdGUuaVN0YXRlICsgJ1N0eWxlJ10uY2xhc3NOYW1lKSB8fFxuICAgICAgICAvLyBpZiBgZm9jdXNgIHN0YXRlIGNoYW5nZWQgKGFsd2F5cyB1cGRhdGUgdG8gd29yayB3aXRoIGRlZmF1bHQgc3R5bGUpXG4gICAgICAgIG5leHRTdGF0ZS5mb2N1cyAhPT0gdGhpcy5zdGF0ZS5mb2N1c1xuICAgICAgKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjb21wb25lbnREaWRVcGRhdGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnREaWRVcGRhdGUoKSB7XG4gICAgICAvLyBgcmVmQ2FsbGJhY2tgIGlzbid0IGNhbGxlZCBieSBSZWFjdCB3aGVuIGBhc2AgaXMgYSBjb21wb25lbnQgYmVjYXVzZSB0aGUgc3BhbiB3cmFwcGVyXG4gICAgICAvLyByZW1haW5zIHRoZSBzYW1lIGVsZW1lbnQgYW5kIGlzIG5vdCByZS1tb3VudGVkIGluIHRoZSBET00sIHNvIG5lZWQgdG8gY2FsbCByZWZDYWxsYmFjayBoZXJlXG4gICAgICAvLyBpZiBgYXNgIGlzIG5ldyBhbmQgYSBjb21wb25lbnQgKGB1cGRhdGVUb3BOb2RlYCB3YXMgc2V0IGluIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMpLlxuICAgICAgaWYgKHRoaXMudHJhY2sudXBkYXRlVG9wTm9kZSkge1xuICAgICAgICB0aGlzLnRyYWNrLnVwZGF0ZVRvcE5vZGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5yZWZDYWxsYmFjayh0aGlzLnJlZk5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NvbXBvbmVudFdpbGxVbm1vdW50JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgT2JqZWN0LmtleXModGhpcy50cmFjay5ub3RpZnlPZk5leHQpLmZvckVhY2goZnVuY3Rpb24gKGVUeXBlKSB7XG4gICAgICAgICgwLCBfbm90aWZpZXIuY2FuY2VsTm90aWZ5T2ZOZXh0KShlVHlwZSwgX3RoaXMyLnRyYWNrLm5vdGlmeU9mTmV4dFtlVHlwZV0pO1xuICAgICAgfSk7XG4gICAgICBPYmplY3Qua2V5cyh0aGlzLnRyYWNrLnRpbWVvdXRJRHMpLmZvckVhY2goZnVuY3Rpb24gKHRpbWVyKSB7XG4gICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQoX3RoaXMyLnRyYWNrLnRpbWVvdXRJRHNbdGltZXJdKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIGRldGVybWluZSBldmVudCBoYW5kbGVycyB0byB1c2UgYmFzZWQgb24gdGhlIGRldmljZSB0eXBlIC0gb25seSBkZXRlcm1pbmVkIG9uY2UgaW4gY29uc3RydWN0b3JcblxuICB9LCB7XG4gICAga2V5OiAnc2V0dXBFdmVudEhhbmRsZXJzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0dXBFdmVudEhhbmRsZXJzKCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIHZhciBldmVudEhhbmRsZXJzID0ge307XG4gICAgICBPYmplY3Qua2V5cyhfY29uc3RhbnRzLm90aGVyRXZlbnRzKS5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBldmVudEhhbmRsZXJzW19jb25zdGFudHMub3RoZXJFdmVudHNbZXZlbnRdXSA9IF90aGlzMy5oYW5kbGVFdmVudDtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBpZiB0aGUgZGV2aWNlIGhhcyB0b3VjaCwgc2V0IHRvdWNoIGV2ZW50IGxpc3RlbmVyc1xuICAgICAgaWYgKF9jb25zdGFudHMuZGV2aWNlSGFzVG91Y2gpIHtcbiAgICAgICAgT2JqZWN0LmtleXMoX2NvbnN0YW50cy50b3VjaEV2ZW50cykuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICBldmVudEhhbmRsZXJzW19jb25zdGFudHMudG91Y2hFdmVudHNbZXZlbnRdXSA9IF90aGlzMy5oYW5kbGVFdmVudDtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICAvLyBpZiB0aGUgZGV2aWNlIGhhcyBhIG1vdXNlLCBzZXQgbW91c2UgZXZlbnQgbGlzdGVuZXJzXG4gICAgICBpZiAoX2NvbnN0YW50cy5kZXZpY2VIYXNNb3VzZSkge1xuICAgICAgICBPYmplY3Qua2V5cyhfY29uc3RhbnRzLm1vdXNlRXZlbnRzKS5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgIGV2ZW50SGFuZGxlcnNbX2NvbnN0YW50cy5tb3VzZUV2ZW50c1tldmVudF1dID0gX3RoaXMzLmhhbmRsZUV2ZW50O1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBldmVudEhhbmRsZXJzO1xuICAgIH1cblxuICAgIC8vIHJldHVybnMgdHJ1ZSBpZiBhIGNsaWNrIGxpc3RlbmVyIHNob3VsZCBiZSBzZXQsIGNhbGxlZCBmcm9tIHByb3BzU2V0dXAgYW5kIHJlZkNhbGxiYWNrXG5cbiAgfSwge1xuICAgIGtleTogJ3NldENsaWNrTGlzdGVuZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRDbGlja0xpc3RlbmVyKHByb3BzKSB7XG4gICAgICAvLyBzZXQgY2xpY2sgbGlzdGVuZXIgd2hlbiB0aGVyZSBpcyBhbiBvbkNsaWNrIHByb3BcbiAgICAgIGlmIChwcm9wcy5vbkNsaWNrKSByZXR1cm4gdHJ1ZTtcbiAgICAgIGlmIChfY29uc3RhbnRzLmRldmljZUhhc1RvdWNoKSB7XG4gICAgICAgIC8vIHNldCBjbGljayBsaXN0ZW5lciB3aGVuIHRoZSBlbGVtZW50IGlzIGZvY3VzYWJsZSAtIHRoaXMgaXMgdG8gY29ycmVjdCBhIGJ1Z1xuICAgICAgICAvLyBpbiBDaHJvbWUgb24gaU9TIHdoZXJlIGl0IHdpbGwgc29tZXRpbWVzLCB3aGVuIGl0IGlzIHVuZGVyIHN0cmVzcywgZmlyZSBmb2N1cyBhbmRcbiAgICAgICAgLy8gY2xpY2sgZXZlbnRzIHdpdGhvdXQgZmlyaW5nIGEgdG91Y2ggZXZlbnQgb24gdGhlIGRvY3VtZW50IC0gdGhlIHJlc3VsdCBpcyB0aGUgZm9jdXMgZXZlbnRcbiAgICAgICAgLy8gd2lsbCBjYXVzZSBSSSB0byBlbnRlciB0aGUgZm9jdXMgZnJvbSB0YWIgc3RhdGUgZXJyYW50bHksIGFuZCB0aGVuIHRoZSBjbGljayBldmVudCB3aWxsXG4gICAgICAgIC8vIHRvZ2dsZSBmb2N1cyBvZmYgbWFraW5nIHRoZSBjb3JyZWN0aW9uLCBzbyBoYXZlIHRvIGxpc3RlbiBmb3IgY2xpY2sgZXZlbnRzXG4gICAgICAgIGlmIChwcm9wcy50YWJJbmRleCkgcmV0dXJuIHRydWU7XG4gICAgICAgIC8vIHNldCBjbGljayBsaXN0ZW5lciB3aGVuIHRoZSBlbGVtZW50IGhhcyBhIGtub3duUm9sZVRhZywgaS5lLiB0aGUgYnJvd3NlclxuICAgICAgICAvLyBoYXMgYSBjbGljayBldmVudCBoYW5kbGVyIHNvIHByZXZlbnREZWZhdWx0KCkgbmVlZHMgdG8gYmUgY2FsbGVkIHdoZW4gdGhlXG4gICAgICAgIC8vIGJyb3dzZXIgc2VuZHMgYSBjbGljayBldmVudCBhZnRlciBSSSBoYXMgY2FuY2VsZWQgdGFwIChlLmcuIHRvdWNoVGFwVGltZXIgZXhwaXJlZCwgZXRjKVxuICAgICAgICBpZiAoX2NvbnN0YW50cy5rbm93blJvbGVUYWdzW3RoaXMudGFnTmFtZV0pIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIGZpbmQgYW5kIHNldCB0aGUgdG9wIERPTSBub2RlIG9mIGBhc2BcblxuICB9LCB7XG4gICAga2V5OiAncHJvcHNTZXR1cCcsXG5cblxuICAgIC8vIHNldHVwIGB0aGlzLnBgLCBvbmx5IGNhbGxlZCBmcm9tIGNvbnN0cnVjdG9yIGFuZCBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByb3BzU2V0dXAocHJvcHMpIHtcbiAgICAgIHZhciBfbWVyZ2VBbmRFeHRyYWN0UHJvcHMgPSAoMCwgX21lcmdlQW5kRXh0cmFjdFByb3BzMy5kZWZhdWx0KShwcm9wcywgX2NvbnN0YW50cy5rbm93blByb3BzKSxcbiAgICAgICAgICBtZXJnZWRQcm9wcyA9IF9tZXJnZUFuZEV4dHJhY3RQcm9wcy5tZXJnZWRQcm9wcyxcbiAgICAgICAgICBwYXNzVGhyb3VnaFByb3BzID0gX21lcmdlQW5kRXh0cmFjdFByb3BzLnBhc3NUaHJvdWdoUHJvcHM7XG5cbiAgICAgICgwLCBfZXh0cmFjdFN0eWxlLnNldEFjdGl2ZUFuZEZvY3VzUHJvcHMpKG1lcmdlZFByb3BzKTtcblxuICAgICAgLy8gaWYgZm9jdXMgc3RhdGUgcHJvcCBhbmQgbm8gdGFiSW5kZXgsIHRoZW4gYWRkIGEgdGFiSW5kZXggc28gUkkgaXMgZm9jdXNhYmxlIGJ5IGJyb3dzZXJcbiAgICAgIGlmIChwYXNzVGhyb3VnaFByb3BzLnRhYkluZGV4ID09PSBudWxsKSBkZWxldGUgcGFzc1Rocm91Z2hQcm9wcy50YWJJbmRleDtlbHNlIGlmICghcGFzc1Rocm91Z2hQcm9wcy50YWJJbmRleCAmJiAobWVyZ2VkUHJvcHMuZm9jdXMgfHwgbWVyZ2VkUHJvcHMuZm9jdXNGcm9tVGFiIHx8IG1lcmdlZFByb3BzLmZvY3VzRnJvbU1vdXNlIHx8IG1lcmdlZFByb3BzLmZvY3VzRnJvbVRvdWNoIHx8IG1lcmdlZFByb3BzLm9uQ2xpY2spKSB7XG4gICAgICAgIG1lcmdlZFByb3BzLnRhYkluZGV4ID0gJzAnO1xuICAgICAgICBwYXNzVGhyb3VnaFByb3BzLnRhYkluZGV4ID0gJzAnO1xuICAgICAgfVxuXG4gICAgICAvLyBpZiBvbkNsaWNrIHByb3AgYnV0IGl0J3Mgbm90IGNsZWFyIHdoYXQgdGhlIHJvbGUgb2YgdGhlIGVsZW1lbnQgaXMgdGhlbiBhZGQgcm9sZT1cImJ1dHRvblwiXG4gICAgICBpZiAocGFzc1Rocm91Z2hQcm9wcy5yb2xlID09PSBudWxsKSBkZWxldGUgcGFzc1Rocm91Z2hQcm9wcy5yb2xlO2Vsc2UgaWYgKG1lcmdlZFByb3BzLm9uQ2xpY2sgJiYgIW1lcmdlZFByb3BzLnJvbGUgJiYgdHlwZW9mIG1lcmdlZFByb3BzLmFzID09PSAnc3RyaW5nJyAmJiAhX2NvbnN0YW50cy5rbm93blJvbGVUYWdzW21lcmdlZFByb3BzLmFzXSkge1xuICAgICAgICBtZXJnZWRQcm9wcy5yb2xlID0gJ2J1dHRvbic7XG4gICAgICAgIHBhc3NUaHJvdWdoUHJvcHMucm9sZSA9ICdidXR0b24nO1xuICAgICAgfVxuXG4gICAgICAvLyBtYXhpbXVtIG51bWJlciBvZiB0b3VjaCBwb2ludHMgd2hlcmUgYSB0YXAgaXMgc3RpbGwgcG9zc2libGVcbiAgICAgIHRoaXMubWF4VGFwUG9pbnRzID0gbWVyZ2VkUHJvcHMub25UYXBGb3VyICYmIDQgfHwgbWVyZ2VkUHJvcHMub25UYXBUaHJlZSAmJiAzIHx8IG1lcmdlZFByb3BzLm9uVGFwVHdvICYmIDIgfHwgMTtcblxuICAgICAgLy8gYWRkIG9uQ2xpY2sgaGFuZGxlciB0byBwYXNzVGhyb3VnaFByb3BzIGlmIGl0J3MgcmVxdWlyZWRcbiAgICAgIGlmICh0aGlzLnNldENsaWNrTGlzdGVuZXIobWVyZ2VkUHJvcHMpKSBwYXNzVGhyb3VnaFByb3BzLm9uQ2xpY2sgPSB0aGlzLmhhbmRsZUV2ZW50O1xuXG4gICAgICAvLyAgYWRkIG9uVG91Y2hNb3ZlIGhhbmRsZXIgdG8gcGFzc1Rocm91Z2hQcm9wcyBpZiBpdCdzIHJlcXVpcmVkXG4gICAgICBpZiAoX2NvbnN0YW50cy5kZXZpY2VIYXNUb3VjaCAmJiAobWVyZ2VkUHJvcHMudG91Y2hBY3RpdmVUYXBPbmx5IHx8IG1lcmdlZFByb3BzLm9uTG9uZ1ByZXNzIHx8IG1lcmdlZFByb3BzLm9uVG91Y2hNb3ZlKSkge1xuICAgICAgICBwYXNzVGhyb3VnaFByb3BzLm9uVG91Y2hNb3ZlID0gdGhpcy5oYW5kbGVFdmVudDtcbiAgICAgIH1cblxuICAgICAgLy8gYWRkIG90aGVyIGV2ZW50IGhhbmRsZXJzIHRvIHBhc3NUaHJvdWdoUHJvcHNcbiAgICAgICgwLCBfb2JqZWN0QXNzaWduMi5kZWZhdWx0KShwYXNzVGhyb3VnaFByb3BzLCB0aGlzLmV2ZW50SGFuZGxlcnMpO1xuXG4gICAgICB0aGlzLnAubm9ybWFsU3R5bGUgPSAoMCwgX2V4dHJhY3RTdHlsZS5leHRyYWN0U3R5bGUpKG1lcmdlZFByb3BzLCAnbm9ybWFsJyk7XG4gICAgICB0aGlzLnAuaG92ZXJTdHlsZSA9ICgwLCBfZXh0cmFjdFN0eWxlLmV4dHJhY3RTdHlsZSkobWVyZ2VkUHJvcHMsICdob3ZlcicpO1xuICAgICAgdGhpcy5wLmhvdmVyQWN0aXZlU3R5bGUgPSAoMCwgX2V4dHJhY3RTdHlsZS5leHRyYWN0U3R5bGUpKG1lcmdlZFByb3BzLCAnaG92ZXJBY3RpdmUnKTtcbiAgICAgIHRoaXMucC50b3VjaEFjdGl2ZVN0eWxlID0gKDAsIF9leHRyYWN0U3R5bGUuZXh0cmFjdFN0eWxlKShtZXJnZWRQcm9wcywgJ3RvdWNoQWN0aXZlJyk7XG4gICAgICB0aGlzLnAua2V5QWN0aXZlU3R5bGUgPSAoMCwgX2V4dHJhY3RTdHlsZS5leHRyYWN0U3R5bGUpKG1lcmdlZFByb3BzLCAna2V5QWN0aXZlJyk7XG4gICAgICB0aGlzLnAudGFiRm9jdXNTdHlsZSA9ICgwLCBfZXh0cmFjdFN0eWxlLmV4dHJhY3RTdHlsZSkobWVyZ2VkUHJvcHMsICdmb2N1c0Zyb21UYWInKTtcbiAgICAgIHRoaXMucC5tb3VzZUZvY3VzU3R5bGUgPSAoMCwgX2V4dHJhY3RTdHlsZS5leHRyYWN0U3R5bGUpKG1lcmdlZFByb3BzLCAnZm9jdXNGcm9tTW91c2UnKTtcbiAgICAgIHRoaXMucC50b3VjaEZvY3VzU3R5bGUgPSAoMCwgX2V4dHJhY3RTdHlsZS5leHRyYWN0U3R5bGUpKG1lcmdlZFByb3BzLCAnZm9jdXNGcm9tVG91Y2gnKTtcbiAgICAgIHRoaXMucC5wYXNzVGhyb3VnaFByb3BzID0gcGFzc1Rocm91Z2hQcm9wcztcbiAgICAgIHRoaXMucC5wcm9wcyA9IG1lcmdlZFByb3BzO1xuICAgIH1cblxuICAgIC8vIGtlZXAgdHJhY2sgb2YgcnVubmluZyB0aW1lb3V0cyBzbyBjYW4gY2xlYXIgaW4gY29tcG9uZW50V2lsbFVubW91bnRcblxuICB9LCB7XG4gICAga2V5OiAnbWFuYWdlU2V0VGltZW91dCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1hbmFnZVNldFRpbWVvdXQodHlwZSwgY2IsIGRlbGF5KSB7XG4gICAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgICAgaWYgKHRoaXMudHJhY2sudGltZW91dElEc1t0eXBlXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGhpcy50cmFjay50aW1lb3V0SURzW3R5cGVdKTtcbiAgICAgIH1cbiAgICAgIHRoaXMudHJhY2sudGltZW91dElEc1t0eXBlXSA9IHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZGVsZXRlIF90aGlzNC50cmFjay50aW1lb3V0SURzW3R5cGVdO1xuICAgICAgICBjYigpO1xuICAgICAgfSwgZGVsYXkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NhbmNlbFRpbWVvdXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjYW5jZWxUaW1lb3V0KHR5cGUpIHtcbiAgICAgIGlmICh0aGlzLnRyYWNrLnRpbWVvdXRJRHNbdHlwZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMudHJhY2sudGltZW91dElEc1t0eXBlXSk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnRyYWNrLnRpbWVvdXRJRHNbdHlwZV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gZm9yY2Ugc2V0IHRoaXMudHJhY2sgcHJvcGVydGllcyBiYXNlZCBvbiBpU3RhdGVcblxuICB9LCB7XG4gICAga2V5OiAnZm9yY2VUcmFja0lTdGF0ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvcmNlVHJhY2tJU3RhdGUoaVN0YXRlKSB7XG4gICAgICBpZiAodGhpcy5jb21wdXRlU3RhdGUoKS5pU3RhdGUgIT09IGlTdGF0ZSkge1xuICAgICAgICB0aGlzLnRyYWNrLm1vdXNlT24gPSBpU3RhdGUgPT09ICdob3ZlcicgfHwgaVN0YXRlID09PSAnaG92ZXJBY3RpdmUnO1xuICAgICAgICB0aGlzLnRyYWNrLmJ1dHRvbkRvd24gPSBpU3RhdGUgPT09ICdob3ZlckFjdGl2ZSc7XG4gICAgICAgIHRoaXMudHJhY2sudG91Y2hEb3duID0gaVN0YXRlID09PSAndG91Y2hBY3RpdmUnO1xuICAgICAgICB0aGlzLnRyYWNrLnNwYWNlS2V5RG93biA9IGlTdGF0ZSA9PT0gJ2tleUFjdGl2ZSc7XG4gICAgICAgIHRoaXMudHJhY2suZW50ZXJLZXlEb3duID0gaVN0YXRlID09PSAna2V5QWN0aXZlJztcbiAgICAgICAgdGhpcy50cmFjay5kcmFnID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gZm9yY2Ugc2V0IG5ldyBzdGF0ZVxuXG4gIH0sIHtcbiAgICBrZXk6ICdmb3JjZVN0YXRlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9yY2VTdGF0ZShuZXdTdGF0ZSkge1xuICAgICAgLy8gc2V0IHRoaXMudHJhY2sgcHJvcGVydGllcyB0byBtYXRjaCBuZXcgaVN0YXRlXG4gICAgICBpZiAobmV3U3RhdGUuaVN0YXRlICE9PSB1bmRlZmluZWQpIHRoaXMuZm9yY2VUcmFja0lTdGF0ZShuZXdTdGF0ZS5pU3RhdGUpO1xuXG4gICAgICAvLyBpZiBuZXcgZm9jdXMgc3RhdGUsIGNhbGwgbWFuYWdlRm9jdXMgYW5kIHJldHVybiBiL2MgZm9jdXMgY2FsbHMgdXBkYXRlU3RhdGVcbiAgICAgIGlmIChuZXdTdGF0ZS5mb2N1cyAhPT0gdW5kZWZpbmVkICYmIG5ld1N0YXRlLmZvY3VzICE9PSB0aGlzLnRyYWNrLnN0YXRlLmZvY3VzKSB7XG4gICAgICAgIHRoaXMudHJhY2suZm9jdXMgPSBuZXdTdGF0ZS5mb2N1cztcbiAgICAgICAgdGhpcy5tYW5hZ2VGb2N1cyhuZXdTdGF0ZS5mb2N1cyA/ICdmb3JjZVN0YXRlRm9jdXNUcnVlJyA6ICdmb3JjZVN0YXRlRm9jdXNGYWxzZScpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIHVwZGF0ZSBzdGF0ZSB3aXRoIG5ldyBjb21wdXRlZCBzdGF0ZSBhbmQgZHVtbXkgJ2V2ZW50JyB0aGF0IGNhdXNlZCBzdGF0ZSBjaGFuZ2VcbiAgICAgIHRoaXMudXBkYXRlU3RhdGUodGhpcy5jb21wdXRlU3RhdGUoKSwgdGhpcy5wLnByb3BzLCAoMCwgX2NvbnN0YW50cy5kdW1teUV2ZW50KSgnZm9yY2VzdGF0ZScpKTtcbiAgICB9XG5cbiAgICAvLyBjb21wdXRlIHRoZSBzdGF0ZSBiYXNlZCBvbiB3aGF0J3Mgc2V0IGluIGB0aGlzLnRyYWNrYCwgcmV0dXJucyBhIG5ldyBzdGF0ZSBvYmplY3RcbiAgICAvLyBub3RlOiB1c2UgdGhlIHJlc3BlY3RpdmUgYWN0aXZlIHN0YXRlIHdoZW4gZHJhZyBpcyB0cnVlIChpLmUuIGRyYWdnaW5nIHRoZSBlbGVtZW50KVxuXG4gIH0sIHtcbiAgICBrZXk6ICdjb21wdXRlU3RhdGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wdXRlU3RhdGUoKSB7XG4gICAgICB2YXIgX3RyYWNrID0gdGhpcy50cmFjayxcbiAgICAgICAgICBtb3VzZU9uID0gX3RyYWNrLm1vdXNlT24sXG4gICAgICAgICAgYnV0dG9uRG93biA9IF90cmFjay5idXR0b25Eb3duLFxuICAgICAgICAgIHRvdWNoRG93biA9IF90cmFjay50b3VjaERvd24sXG4gICAgICAgICAgZm9jdXMgPSBfdHJhY2suZm9jdXMsXG4gICAgICAgICAgZHJhZyA9IF90cmFjay5kcmFnO1xuXG4gICAgICB2YXIgZm9jdXNLZXlEb3duID0gZm9jdXMgJiYgKHRoaXMudHJhY2suZW50ZXJLZXlEb3duICYmIHRoaXMuZW50ZXJLZXlUcmlnZ2VyIHx8IHRoaXMudHJhY2suc3BhY2VLZXlEb3duICYmIHRoaXMuc3BhY2VLZXlUcmlnZ2VyKTtcbiAgICAgIHZhciBuZXdTdGF0ZSA9IHsgZm9jdXM6IGZvY3VzIH07XG4gICAgICBpZiAoIW1vdXNlT24gJiYgIWJ1dHRvbkRvd24gJiYgIXRvdWNoRG93biAmJiAhZm9jdXNLZXlEb3duICYmICFkcmFnKSBuZXdTdGF0ZS5pU3RhdGUgPSAnbm9ybWFsJztlbHNlIGlmIChtb3VzZU9uICYmICFidXR0b25Eb3duICYmICF0b3VjaERvd24gJiYgIWZvY3VzS2V5RG93biAmJiAhZHJhZykge1xuICAgICAgICBuZXdTdGF0ZS5pU3RhdGUgPSAnaG92ZXInO1xuICAgICAgfSBlbHNlIGlmIChtb3VzZU9uICYmIGJ1dHRvbkRvd24gJiYgIXRvdWNoRG93biAmJiAhZm9jdXNLZXlEb3duIHx8IGRyYWcgJiYgIXRvdWNoRG93bikge1xuICAgICAgICBuZXdTdGF0ZS5pU3RhdGUgPSAnaG92ZXJBY3RpdmUnO1xuICAgICAgfSBlbHNlIGlmIChmb2N1c0tleURvd24gJiYgIXRvdWNoRG93bikgbmV3U3RhdGUuaVN0YXRlID0gJ2tleUFjdGl2ZSc7ZWxzZSBpZiAodG91Y2hEb3duIHx8IGRyYWcpIG5ld1N0YXRlLmlTdGF0ZSA9ICd0b3VjaEFjdGl2ZSc7XG4gICAgICByZXR1cm4gbmV3U3RhdGU7XG4gICAgfVxuXG4gICAgLy8gdGFrZXMgYSBuZXcgc3RhdGUsIGNhbGxzIHNldFN0YXRlIGFuZCB0aGUgc3RhdGUgY2hhbmdlIGNhbGxiYWNrc1xuXG4gIH0sIHtcbiAgICBrZXk6ICd1cGRhdGVTdGF0ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZVN0YXRlKG5ld1N0YXRlLCBwcm9wcywgZXZlbnQsIGRvbnRNYW5hZ2VOb3RpZnlPZk5leHQpIHtcbiAgICAgIGlmICghZG9udE1hbmFnZU5vdGlmeU9mTmV4dCkgdGhpcy5tYW5hZ2VOb3RpZnlPZk5leHQobmV3U3RhdGUpO1xuICAgICAgdmFyIHByZXZJU3RhdGUgPSB0aGlzLnRyYWNrLnN0YXRlLmlTdGF0ZTtcbiAgICAgIHZhciBuZXh0SVN0YXRlID0gbmV3U3RhdGUuaVN0YXRlO1xuICAgICAgdmFyIGlTdGF0ZUNoYW5nZSA9IG5leHRJU3RhdGUgIT09IHByZXZJU3RhdGU7XG4gICAgICB2YXIgZm9jdXNDaGFuZ2UgPSBuZXdTdGF0ZS5mb2N1cyAhPT0gdGhpcy50cmFjay5zdGF0ZS5mb2N1cztcblxuICAgICAgLy8gZWFybHkgcmV0dXJuIGlmIHN0YXRlIGRvZXNuJ3QgbmVlZCB0byBjaGFuZ2VcbiAgICAgIGlmICghaVN0YXRlQ2hhbmdlICYmICFmb2N1c0NoYW5nZSkgcmV0dXJuO1xuXG4gICAgICAvLyBjcmVhdGUgbmV3IHByZXYgYW5kIG5leHQgc3RhdGUgb2JqZWN0cyB3aXRoIGltbXV0YWJsZSB2YWx1ZXNcbiAgICAgIHZhciBwcmV2U3RhdGUgPSB7XG4gICAgICAgIGlTdGF0ZTogcHJldklTdGF0ZSxcbiAgICAgICAgZm9jdXM6IHRoaXMudHJhY2suc3RhdGUuZm9jdXNcbiAgICAgIH07XG4gICAgICB2YXIgbmV4dFN0YXRlID0ge1xuICAgICAgICBpU3RhdGU6IG5leHRJU3RhdGUsXG4gICAgICAgIGZvY3VzOiBuZXdTdGF0ZS5mb2N1c1xuICAgICAgfTtcblxuICAgICAgLy8gY2FsbCBvblN0YXRlQ2hhbmdlIHByb3AgY2FsbGJhY2tcbiAgICAgIHByb3BzLm9uU3RhdGVDaGFuZ2UgJiYgcHJvcHMub25TdGF0ZUNoYW5nZSh7IHByZXZTdGF0ZTogcHJldlN0YXRlLCBuZXh0U3RhdGU6IG5leHRTdGF0ZSwgZXZlbnQ6IGV2ZW50IH0pO1xuXG4gICAgICAvLyB0cmFjayBuZXcgc3RhdGUgYmVjYXVzZSBzZXRTdGF0ZSBpcyBhc3luY3JvdW5vdXNcbiAgICAgIHRoaXMudHJhY2suc3RhdGUgPSBuZXdTdGF0ZTtcblxuICAgICAgLy8gb25seSBwbGFjZSB0aGF0IHNldFN0YXRlIGlzIGNhbGxlZFxuICAgICAgdGhpcy5zZXRTdGF0ZShuZXdTdGF0ZSwgcHJvcHMuc2V0U3RhdGVDYWxsYmFjayAmJiBwcm9wcy5zZXRTdGF0ZUNhbGxiYWNrLmJpbmQodGhpcywgeyBwcmV2U3RhdGU6IHByZXZTdGF0ZSwgbmV4dFN0YXRlOiBuZXh0U3RhdGUgfSkpO1xuICAgIH1cblxuICAgIC8vIGhhbmRsZXMgYWxsIGV2ZW50cyAtIGZpcnN0IGNoZWNrcyBpZiBpdCdzIGEgdmFsaWQgZXZlbnQsIHRoZW4gY2FsbHMgdGhlIHNwZWNpZmljXG4gICAgLy8gdHlwZSBvZiBldmVudCBoYW5kbGVyICh0byBzZXQgdGhlIHByb3BlciB0aGlzLnRyYWNrIHByb3BlcnRpZXMpLFxuICAgIC8vIGFuZCBhdCB0aGUgZW5kIGNhbGxzIHRoaXMudXBkYXRlU3RhdGUoLi4uKVxuXG4gIH0sIHtcbiAgICBrZXk6ICdpc1ZhbGlkRXZlbnQnLFxuXG5cbiAgICAvLyBjaGVja3MgaWYgdGhlIGV2ZW50IGlzIGEgdmFsaWQgZXZlbnQgb3Igbm90LCByZXR1cm5zIHRydWUgLyBmYWxzZSByZXNwZWN0aXZseVxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc1ZhbGlkRXZlbnQoZSkge1xuICAgICAgLy8gaWYgaXQncyBhIGtub3duIGNsaWNrIGV2ZW50IHRoZW4gcmV0dXJuIHRydWVcbiAgICAgIGlmIChlLnR5cGUgPT09ICdjbGljaycgJiYgdGhpcy50cmFjay5jbGlja1R5cGUgIT09ICdyZXNldCcpIHJldHVybiB0cnVlO1xuICAgICAgLy8gaWYgaXQncyBhIGZvY3VzL2JsdXIgZXZlbnQgYW5kIHRoaXMgSW50ZXJhY3RpdmUgaW5zdGFuY2UgaXMgbm90IHRoZSB0YXJnZXQgdGhlbiByZXR1cm4gdHJ1ZVxuICAgICAgaWYgKChlLnR5cGUgPT09ICdmb2N1cycgfHwgZS50eXBlID09PSAnYmx1cicpICYmIGUudGFyZ2V0ICE9PSB0aGlzLnRvcE5vZGUpIHJldHVybiB0cnVlO1xuXG4gICAgICAvLyByZWZDYWxsYmFja0ZvY3VzIGNhbGxzIGZvY3VzIHdoZW4gdGhlcmUgaXMgYSBuZXcgdG9wIERPTSBub2RlIGFuZCBSSSBpcyBhbHJlYWR5IGluIHRoZVxuICAgICAgLy8gZm9jdXMgc3RhdGUgdG8ga2VlcCB0aGUgYnJvd3NlcidzIGZvY3VzIHN0YXRlIGluIHN5bmMgd2l0aCBSSSdzLCBzbyByZXNldCBhbmQgcmV0dXJuIGZhbHNlXG4gICAgICBpZiAoZS50eXBlID09PSAnZm9jdXMnICYmIHRoaXMudHJhY2suZm9jdXNUcmFuc2l0aW9uID09PSAncmVmQ2FsbGJhY2tGb2N1cycpIHtcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgdGhpcy50cmFjay5mb2N1c1RyYW5zaXRpb24gPSAncmVzZXQnO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8vIGlmIHRoZSBmb2N1c1RyYW5zaXRpb24gaXMgYSBmb3JjZSBibHVyIGFuZCBSSSBpcyBub3QgY3VycmVudGx5IGluIHRoZSBmb2N1cyBzdGF0ZSxcbiAgICAgIC8vIHRoZW4gdGhlIGZvcmNlIGJsdXIgaXMgdG8ga2VlcCB0aGUgYnJvd3NlciBmb2N1cyBzdGF0ZSBpbiBzeW5jIHdpdGggUkkncyBmb2N1cyBzdGF0ZSxcbiAgICAgIC8vIHNvIHJlc2V0IHRoZSBmb2N1c1RyYW5zaXRpb24gYW5kIHJldHVybiBmYWxzZSwgbm8gbmVlZCB0byBkbyBhbnl0aGluZ1xuICAgICAgLy8gZWxzZSBiZWNhdXNlIHRoZSBibHVyIGV2ZW50IHdhcyBvbmx5IGZvciB0aGUgYmVuZWZpdCBvZiB0aGUgYnJvd3Nlciwgbm90IFJJXG4gICAgICBpZiAoZS50eXBlID09PSAnYmx1cicgJiYgdGhpcy50cmFjay5mb2N1c1RyYW5zaXRpb24gPT09ICdmb2N1c0ZvcmNlQmx1cicgJiYgIXRoaXMudHJhY2suc3RhdGUuZm9jdXMpIHtcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgdGhpcy50cmFjay5mb2N1c1RyYW5zaXRpb24gPSAncmVzZXQnO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8vIGlmIHRoZSBkZXZpY2UgaXMgdG91Y2hPbmx5IG9yIGEgaHlicmlkXG4gICAgICBpZiAoX2NvbnN0YW50cy5kZXZpY2VIYXNUb3VjaCkge1xuICAgICAgICAvLyByZWplY3QgY2xpY2sgZXZlbnRzIHRoYXQgYXJlIGZyb20gdG91Y2ggaW50ZXJhY3Rpb25zLCB1bmxlc3Mgbm8gYWN0aXZlIG9yIHRvdWNoQWN0aXZlIHByb3BcbiAgICAgICAgLy8gaWYgbm8gYWN0aXZlIG9yIHRvdWNoQWN0aXZlIHByb3AsIHRoZW4gbGV0IHRoZSBicm93c2VyIGRldGVybWluZSB3aGF0IGlzIGEgY2xpY2sgZnJvbSB0b3VjaFxuICAgICAgICAvLyB0aGlzIGFsbG93cyBmb3IgZWRnZSB0YXBzIHRoYXQgZG9uJ3QgZmlyZSB0b3VjaCBldmVudHMgb24gUkkgKG9ubHkgY2xpY2sgZXZlbnRzKVxuICAgICAgICAvLyBzbyB0aGUgY2xpY2sgZXZlbnQgaXMgYWxsb3dlZCB0aHJvdWdoIHdoZW4gV2Via2l0VGFwSGlnaHRsaWdodENvbG9yIGluZGljYXRlcyBhIGNsaWNrXG4gICAgICAgIGlmIChlLnR5cGUgPT09ICdjbGljaycgJiYgKF9pbnB1dFRyYWNrZXIyLmRlZmF1bHQudG91Y2gucmVjZW50VG91Y2ggfHwgX2lucHV0VHJhY2tlcjIuZGVmYXVsdC50b3VjaC50b3VjaE9uU2NyZWVuKSAmJiAodGhpcy5wLnByb3BzLmFjdGl2ZSB8fCB0aGlzLnAucHJvcHMudG91Y2hBY3RpdmUpKSB7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJlamVjdCB1bmtub3duIGZvY3VzIGV2ZW50cyBmcm9tIHRvdWNoIGludGVyYWN0aW9uc1xuICAgICAgICBpZiAoZS50eXBlID09PSAnZm9jdXMnKSB7XG4gICAgICAgICAgaWYgKHRoaXMudHJhY2suZm9jdXNUcmFuc2l0aW9uID09PSAncmVzZXQnICYmIChfaW5wdXRUcmFja2VyMi5kZWZhdWx0LnRvdWNoLnJlY2VudFRvdWNoIHx8ICF0aGlzLnRyYWNrLnRvdWNoRG93biAmJiBfaW5wdXRUcmFja2VyMi5kZWZhdWx0LnRvdWNoLnRvdWNoT25TY3JlZW4pKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgdGhpcy5tYW5hZ2VGb2N1cygnZm9jdXNGb3JjZUJsdXInKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKF9jb25zdGFudHMuZGV2aWNlVHlwZSA9PT0gJ2h5YnJpZCcpIHtcbiAgICAgICAgLy8gcmVqZWN0IG1vdXNlIGV2ZW50cyBmcm9tIHRvdWNoIGludGVyYWN0aW9uc1xuICAgICAgICBpZiAoL21vdXNlLy50ZXN0KGUudHlwZSkgJiYgKF9pbnB1dFRyYWNrZXIyLmRlZmF1bHQudG91Y2gudG91Y2hPblNjcmVlbiB8fCBfaW5wdXRUcmFja2VyMi5kZWZhdWx0LnRvdWNoLnJlY2VudFRvdWNoKSkge1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBub3RpZnlPZk5leHQgcGx1Z3MgdGhlIGhvbGVzIGluIHRoZSBldmVudHMgZmlyZWQgYnkgdGhlIGJyb3dzZXIgb24gdGhlIFJJIGVsZW1lbnQsXG4gICAgLy8gaW4gc29tZSBzaXR1YXRpb25zIHRoZSBicm93c2VyIGZhaWxzIHRvIGZpcmUgdGhlIG5lY2Vzc2FyeSBldmVudCBsZWF2aW5nIFJJIHN0dWNrXG4gICAgLy8gaW4gdGhlIHdyb25nIHN0YXRlIChhIG5vdCBub3JtYWwgaVN0YXRlKSwgc28gc2lnbiB1cCB0byBiZSBub3RpZmllZCBvZiB0aGUgbmV4dCBnbG9iYWwgZXZlbnRcbiAgICAvLyBhbmQgZG8gc29tZSBjaGVja3MgKGluIGhhbmRsZU5vdGlmeU9mTmV4dCkgdG8gY29uZmlybSBSSSBpcyBpbiB0aGUgY29ycmVjdCBzdGF0ZSxcbiAgICAvLyBub3RlIHRoYXQgbm90aWZ5T2ZOZXh0IG9ubHkgd2hpbGUgbm90IGluIHRoZSBub3JtYWwgc3RhdGUgbWFrZXMgdGhlIG5vdGlmaWVyIE8oMSkgaW5zdGVhZCBvZlxuICAgIC8vIE8obiksIHdoZXJlIG4gaXMgdGhlIG51bWJlciBvZiBtb3VudGVkIFJJIGNvbXBvbmVudHNcblxuICB9LCB7XG4gICAga2V5OiAnbWFuYWdlTm90aWZ5T2ZOZXh0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWFuYWdlTm90aWZ5T2ZOZXh0KG5ld1N0YXRlKSB7XG4gICAgICB2YXIgX3RoaXM1ID0gdGhpcztcblxuICAgICAgLy8gc2V0IG5vdGlmeU9mTmV4dFxuICAgICAgdmFyIHNldE5PTiA9IGZ1bmN0aW9uIHNldE5PTihlVHlwZSkge1xuICAgICAgICBpZiAoIV90aGlzNS50cmFjay5ub3RpZnlPZk5leHRbZVR5cGVdKSB7XG4gICAgICAgICAgX3RoaXM1LnRyYWNrLm5vdGlmeU9mTmV4dFtlVHlwZV0gPSAoMCwgX25vdGlmaWVyLm5vdGlmeU9mTmV4dCkoZVR5cGUsIF90aGlzNS5oYW5kbGVOb3RpZnlPZk5leHQpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgLy8gY2FuY2VsIG5vdGlmeU9mTmV4dFxuICAgICAgdmFyIGNhbmNlbE5PTiA9IGZ1bmN0aW9uIGNhbmNlbE5PTihlVHlwZSkge1xuICAgICAgICBpZiAoX3RoaXM1LnRyYWNrLm5vdGlmeU9mTmV4dFtlVHlwZV0pIHtcbiAgICAgICAgICAoMCwgX25vdGlmaWVyLmNhbmNlbE5vdGlmeU9mTmV4dCkoZVR5cGUsIF90aGlzNS50cmFjay5ub3RpZnlPZk5leHRbZVR5cGVdKTtcbiAgICAgICAgICBkZWxldGUgX3RoaXM1LnRyYWNrLm5vdGlmeU9mTmV4dFtlVHlwZV07XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGlmIChfY29uc3RhbnRzLmRldmljZUhhc01vdXNlKSB7XG4gICAgICAgIC8vIGlmIG5vdCBpbiB0aGUgbm9ybWFsIHN0YXRlIGFuZCBub3QgZHJhZ2dpbmcsIHRoZW4gc2V0IG5vdGlmeU9mTmV4dCwgb3RoZXJ3aXNlIGNhbmNlbFxuICAgICAgICB2YXIgc2hvdWxkU2V0Tk9OID0gbmV3U3RhdGUuaVN0YXRlICE9PSAnbm9ybWFsJyAmJiAhdGhpcy50cmFjay5kcmFnO1xuXG4gICAgICAgIC8vIGNoZWNrIG1vdXNlIHBvc2l0aW9uIG9uIGRvY3VtZW50IG1vdXNlZW50ZXIgdG8gcHJldmVudCBmcm9tIHN0aWNraW5nIGluXG4gICAgICAgIC8vIHRoZSBob3ZlciBzdGF0ZSBhZnRlciBzd2l0Y2hpbmcgdG8gYW5vdGhlciBhcHAvd2luZG93LCBtb3ZpbmcgdGhlIG1vdXNlLFxuICAgICAgICAvLyBhbmQgdGhlbiBzd2l0Y2hpbmcgIGJhY2sgKHNvIHRoZSBtb3VzZSBpcyBubyBsb25nZXIgb3ZlciB0aGUgZWxlbWVudClcbiAgICAgICAgc2hvdWxkU2V0Tk9OID8gc2V0Tk9OKCdtb3VzZWVudGVyJykgOiBjYW5jZWxOT04oJ21vdXNlZW50ZXInKTtcblxuICAgICAgICAvLyB0aGUgZHJhZ3N0YXJ0IGV2ZW50IG9uIGFuIGVsZW1lbnQgZmlyZXMgYWZ0ZXIgYSBzaG9ydCBkZWxheSwgc28gaXQgaXMgcG9zc2libGUgdG9cbiAgICAgICAgLy8gc3RhcnQgZHJhZ2dpbmcgYW4gZWxlbWVudCBhbmQgaGF2ZSB0aGUgbW91c2VlbnRlciBhbm90aGVyIGVsZW1lbnQgcHV0dGluZyBpdCBpbiB0aGVcbiAgICAgICAgLy8gaG92ZXJBY3RpdmUgc3RhdGUgYmVmb3JlIHRoZSBkcmFnc3RhcnQgZXZlbnQgZmlyZXMgKGFmdGVyIHRoZSBkcmFnc3RhcnQgZXZlbnRcbiAgICAgICAgLy8gbm8gb3RoZXIgbW91c2UgZXZlbnRzIGFyZSBmaXJlZCksIHNvIHNpZ24gdXAgZm9yIG5leHQgZ2xvYmFsIGRyYWdzdGFydCB0byBmb3JjZSBpbnRyb1xuICAgICAgICAvLyBub3JtYWwgc3RhdGUgd2hpbGUgYW5vdGhlciBlbGVtZW50IGlzIGJlaW5nIGRyYWdnZWRcbiAgICAgICAgc2hvdWxkU2V0Tk9OID8gc2V0Tk9OKCdkcmFnc3RhcnQnKSA6IGNhbmNlbE5PTignZHJhZ3N0YXJ0Jyk7XG5cbiAgICAgICAgLy8gdGhlIHNjcm9sbCBsaXN0ZW5lciBwcm92aWRlcyBhIG1pbm9yIGltcHJvdmVtZW50IHRvIGFjY3VyYWN5IGJ5IGV4aXRpbmcgdGhlIGhvdmVyIHN0YXRlXG4gICAgICAgIC8vIGFzIHNvb24gYXMgdGhlIG1vdXNlIGlzIHNjcm9sbGVkIG9mZiBhbiBlbGVtZW50IGluc3RlYWQgb2Ygd2FpdGluZyBmb3IgdGhlIHNjcm9sbGluZyB0byBlbmRcbiAgICAgICAgLy8gb25seSBzZXQgYXMgYSBwYXNzaXZlIGxpc3RlbmVyIGFzIHRoZSBpbXByb3ZlbWVudCBpcyBub3Qgd29ydGggaXQgaWYgaXQgaHVydHMgcGVyZm9ybWFuY2VcbiAgICAgICAgaWYgKF9jb25zdGFudHMucGFzc2l2ZUV2ZW50U3VwcG9ydCkge1xuICAgICAgICAgIHNob3VsZFNldE5PTiA/IHNldE5PTignc2Nyb2xsJykgOiBjYW5jZWxOT04oJ3Njcm9sbCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgdGhlIG1vdXNlIGlzIG9uIFJJLCB0aGVuIHNpZ24gdXAgZm9yIG5leHQgRE9NIG11dGF0aW9uIGV2ZW50LCB3aGljaCBjb3VsZFxuICAgICAgICAvLyBtb3ZlIHRoZSBtb3VzZSBvZmYgb2YgUkkgKGJ5IGNoYW5naW5nIHRoZSBsYXlvdXQgb2YgdGhlIHBhZ2UpXG4gICAgICAgIC8vIHdpdGhvdXQgZmlyaW5nIGEgbW91c2VsZWF2ZSBldmVudCAoYmVjYXVzZSB0aGUgbW91c2UgbmV2ZXIgbW92ZWQpXG4gICAgICAgIHRoaXMudHJhY2subW91c2VPbiA/IHNldE5PTignbXV0YXRpb24nKSA6IGNhbmNlbE5PTignbXV0YXRpb24nKTtcbiAgICAgIH1cblxuICAgICAgaWYgKF9jb25zdGFudHMuZGV2aWNlSGFzVG91Y2gpIHtcbiAgICAgICAgLy8gY2FuY2VsIHRhcCB3aGVuIHRvdWNoIHNvbWVwbGFjZSBlbHNlIG9uIHRoZSBzY3JlZW5cbiAgICAgICAgbmV3U3RhdGUuaVN0YXRlID09PSAndG91Y2hBY3RpdmUnID8gdGhpcy5wLnByb3BzLmV4dHJhVG91Y2hOb1RhcCAmJiBzZXROT04oJ3RvdWNoc3RhcnQnKSA6IGNhbmNlbE5PTigndG91Y2hzdGFydCcpO1xuICAgICAgfVxuXG4gICAgICAvLyBub3RpZnkgb2YgbmV4dCBzZXR1cCBmb3IgbWFpbnRhaW5pbmcgY29ycmVjdCBmb2N1c0Zyb20gd2hlbiBzd2l0Y2hpbmcgYXBwcy93aW5kb3dzLFxuICAgICAgLy8gaWYgZXhpdGluZyB0aGUgZm9jdXMgc3RhdGUsIG5vdGlmeSBvZiB0aGUgbmV4dCB3aW5kb3cgYmx1ciAobGVhdmluZyB0aGUgYXBwL3dpbmRvdy90YWIpXG4gICAgICAvLyBldmVudCBpZiBpdCBpbW1lZGlhdGVseSBmb2xsb3dzIHRoaXMgZXZlbnQsIG90aGVyd2lzZSBjYW5jZWwgdGhlIG5vdGlmeSBvZiBuZXh0XG4gICAgICBpZiAodGhpcy50cmFjay5zdGF0ZS5mb2N1cyAmJiAhbmV3U3RhdGUuZm9jdXMpIHtcbiAgICAgICAgc2V0Tk9OKCdibHVyJyk7XG4gICAgICAgIHRoaXMubWFuYWdlU2V0VGltZW91dCgnZWxlbWVudEJsdXInLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3RoaXM1LnRyYWNrLnByZXZpb3VzRm9jdXMgPSBmYWxzZTtcbiAgICAgICAgICBjYW5jZWxOT04oJ2JsdXInKTtcbiAgICAgICAgfSwgX2NvbnN0YW50cy5xdWV1ZVRpbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NoZWNrTW91c2VQb3NpdGlvbicsXG5cblxuICAgIC8vIGNoZWNrIHRoZSBtb3VzZSBwb3NpdGlvbiByZWxhdGl2ZSB0byB0aGUgUkkgZWxlbWVudCBvbiB0aGUgcGFnZVxuICAgIHZhbHVlOiBmdW5jdGlvbiBjaGVja01vdXNlUG9zaXRpb24oZSkge1xuICAgICAgaWYgKCFfY29uc3RhbnRzLmRldmljZUhhc01vdXNlKSByZXR1cm4gbnVsbDtcblxuICAgICAgdmFyIG1vdXNlWCA9IGUgJiYgZS5jbGllbnRYIHx8IF9pbnB1dFRyYWNrZXIyLmRlZmF1bHQubW91c2UuY2xpZW50WDtcbiAgICAgIHZhciBtb3VzZVkgPSBlICYmIGUuY2xpZW50WSB8fCBfaW5wdXRUcmFja2VyMi5kZWZhdWx0Lm1vdXNlLmNsaWVudFk7XG4gICAgICBmdW5jdGlvbiBtb3VzZU9uTm9kZShub2RlKSB7XG4gICAgICAgIHZhciByZWN0ID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgcmV0dXJuIG1vdXNlWCA+PSByZWN0LmxlZnQgLSAxICYmIG1vdXNlWCA8PSByZWN0LnJpZ2h0ICsgMSAmJiBtb3VzZVkgPj0gcmVjdC50b3AgLSAxICYmIG1vdXNlWSA8PSByZWN0LmJvdHRvbSArIDE7XG4gICAgICB9XG5cbiAgICAgIHZhciBtb3VzZU9uID0gdHJ1ZTtcblxuICAgICAgaWYgKCFfaW5wdXRUcmFja2VyMi5kZWZhdWx0Lm1vdXNlLm1vdXNlT25Eb2N1bWVudCkge1xuICAgICAgICBtb3VzZU9uID0gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKCF0aGlzLnAucHJvcHMubm9uQ29udGFpbmVkQ2hpbGQpIHtcbiAgICAgICAgbW91c2VPbiA9IG1vdXNlT25Ob2RlKHRoaXMudG9wTm9kZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBpZiB0aGUgbm9uQ29udGFpbmVkQ2hpbGQgcHJvcCBpcyBwcmVzZW50LCB0aGVuIGRvIGEgcmVjdXJzaXZlIGNoZWNrIG9mIHRoZSBub2RlIGFuZCBpdHNcbiAgICAgICAgLy8gY2hpbGRyZW4gdW50aWwgdGhlIG1vdXNlIGlzIG9uIGEgbm9kZSBvciBhbGwgY2hpbGRyZW4gYXJlIGNoZWNrZWQsXG4gICAgICAgIC8vIHRoaXMgaXMgdXNlZnVsIHdoZW4gdGhlIGNoaWxkcmVuIGFyZW4ndCBpbnNpZGUgb2YgdGhlIHBhcmVudCBvbiB0aGUgcGFnZVxuICAgICAgICBtb3VzZU9uID0gKDAsIF9yZWN1cnNpdmVOb2RlQ2hlY2syLmRlZmF1bHQpKHRoaXMudG9wTm9kZSwgbW91c2VPbk5vZGUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbW91c2VPbiA/ICdtb3VzZU9uJyA6ICdtb3VzZU9mZic7XG4gICAgfVxuXG4gICAgLy8gY2hlY2sgdG8gc2VlIGlmIGEgZm9jdXNUcmFuc2l0aW9uIGlzIG5lY2Vzc2FyeSBhbmQgdXBkYXRlIHRoaXMudHJhY2suZm9jdXNUcmFuc2l0aW9uXG4gICAgLy8gcmV0dXJucyAndGVybWluYXRlJyBpZiBoYW5kbGVFdmVudCBzaG91bGQgdGVybWluYXRlLCByZXR1cm5zICd1cGRhdGVTdGF0ZSdcbiAgICAvLyBpZiBoYW5kbGVFdmVudCBzaG91bGQgY29udGludWUgYW5kIGNhbGwgdXBkYXRlU3RhdGUgdGhpcyB0aW1lIHRocm91Z2hcbiAgICAvLyBmb2N1cyBldmVudCBsaWZlY3ljbGU6XG4gICAgLy8gLSBicm93c2VyIGNhbGxzIGZvY3VzIC0+IG9uRm9jdXMgbGlzdGVuZXIgdHJpZ2dlcmVkXG4gICAgLy8gLSBSSSBjYWxscyBmb2N1cyAodXNpbmcgbWFuYWdlRm9jdXMpIC0+IHNldCBmb2N1c1RyYW5zaXRpb24gLT4gb25Gb2N1cyBsaXN0ZW5lciB0cmlnZ2VyZWRcbiAgICAvLyAtIFJJIGV2ZW50IGhhbmRsZXIgdXNlcyB0cmFjay5mb2N1c1RyYW5zaXRpb24gdG8gZGV0ZXJtaW5lIGlmIHRoZSBmb2N1cyBldmVudCBpczpcbiAgICAvLyAgIC0gbm90IGEgdmFsaWQgZXZlbnQgKGluIGlzVmFsaWRFdmVudClcbiAgICAvLyAgICAgLSBzZW50IGZyb20gUkkgdG8ga2VlcCBicm93c2VyIGZvY3VzIGluIHN5bmMgd2l0aCBSSSAtPiByZXNldCBmb2N1c1RyYW5zaXRpb24gLT4gZW5kXG4gICAgLy8gICAgIC0gZXJyYW50IC0+IGNhbGwgYmx1ciB0byBrZWVwIGJyb3dzZXIgaW4gc3luYywgc2V0IGZvY3VzVHJhbnNpdGlvbiB0byBmb2N1c0ZvcmNlQmx1ciAtPiBlbmRcbiAgICAvLyAgIC0gYSB2YWxpZCBldmVudFxuICAgIC8vICAgICAtIHNlbnQgZnJvbSBSSSAtPiByZXNldCBmb2N1c1RyYW5zaXRpb24gLT4gUkkgZW50ZXJzIHRoZSBmb2N1cyBzdGF0ZSB3LyBmb2N1c1xuICAgIC8vICAgICAgIGJhc2VkIG9uIHRoZSBmb2N1c1RyYW5zaXRpb25cbiAgICAvLyAgICAgLSBzZW50IGZyb20gYnJvd3NlciAtPiBSSSBlbnRlcnMgdGhlIGZvY3VzIHN0YXRlIHcvIGZvY3VzIHNldCB0byAndGFiJ1xuICAgIC8vIC0gYnJvd3NlciBjYWxscyBibHVyIC0+IG9uQmx1ciBsaXN0ZW5lciB0cmlnZ2VyZWRcbiAgICAvLyAtIFJJIGNhbGxzIGJsdXIgKHVzaW5nIG1hbmFnZUZvY3VzKSAtPiBzZXQgZm9jdXNUcmFuc2l0aW9uIC0+IG9uQmx1ciBsaXN0ZW5lciB0cmlnZ2VyZWRcbiAgICAvLyAtIFJJIGV2ZW50IGhhbmRsZXIgdXNlcyB0cmFjay5mb2N1c1RyYW5zaXRpb24gdG8gZGV0ZXJtaW5lIGlmIHRoZSBibHVyIGV2ZW50IGlzOlxuICAgIC8vICAgLSBub3QgYSB2YWxpZCBldmVudCAoaW4gaXNWYWxpZEV2ZW50KVxuICAgIC8vICAgICAtIGEgZm9yY2UgYmx1ciB0byBrZWVwIHRoZSBicm93c2VyIGZvY3VzIHN0YXRlIGluIHN5bmMgLT4gcmVzZXQgZm9jdXNUcmFuc2l0aW9uIC0+IGVuZFxuICAgIC8vICAgICAgIChpZiBpdCdzIGEgZm9yY2UgYmx1ciBtZWFudCBmb3IgYm90aCBSSSBhbmQgdGhlIGJyb3dzZXIsIHRoZW4gaXQncyBhIHZhbGlkIGV2ZW50KVxuICAgIC8vICAgLSBldmV5dGhpbmcgZWxzZSAtPiByZXNldCBmb2N1c1RyYW5zaXRpb24gLT4gUkkgbGVhdmVzIGZvY3VzIHN0YXRlXG5cbiAgfSwge1xuICAgIGtleTogJ21hbmFnZUZvY3VzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWFuYWdlRm9jdXModHlwZSwgZSkge1xuICAgICAgdmFyIF90aGlzNiA9IHRoaXM7XG5cbiAgICAgIC8vIGlmIHRoaXMgZXhhY3QgZXZlbnQgaGFzIGFscmVhZHkgYmVlbiB1c2VkIGZvciBmb2N1cy9ibHVyIGJ5IGFub3RoZXIgaW5zdGFuY2Ugb2YgSW50ZXJhY3RpdmVcbiAgICAgIC8vIGkuZS4gYSBjaGlsZCBhbmQgdGhlIGV2ZW50IGlzIGJ1YmJsaW5nLCB0aGVuIGRvbid0IG1hbmFnZSBmb2N1cyBhbmQgcmV0dXJuIHVwZGF0ZVN0YXRlXG4gICAgICBpZiAoZSAmJiAoX2lucHV0VHJhY2tlci5mb2N1c1JlZ2lzdHJ5LmZvY3VzID09PSBlIHx8IF9pbnB1dFRyYWNrZXIuZm9jdXNSZWdpc3RyeS5ibHVyID09PSBlKSkgcmV0dXJuICd1cGRhdGVTdGF0ZSc7XG5cbiAgICAgIC8vIGlzIHRoZSBET00gbm9kZSB0YWcgYmx1cmFibGUgZm9yIHRvZ2dsZSBmb2N1c1xuICAgICAgdmFyIHRhZ0lzQmx1cmFibGUgPSAhX2NvbnN0YW50cy5ub25CbHVycmFibGVUYWdzW3RoaXMudGFnTmFtZV0gJiYgIXRoaXMucC5wcm9wcy5mb2N1c1RvZ2dsZU9mZjtcbiAgICAgIC8vIGlzIHRoZSBub2RlIGZvY3VzYWJsZSwgaWYgdGhlcmUgaXMgYSBmb2N1cyBvciB0YWJJbmRleCBwcm9wLCBvciBpdCdzIG5vbi1ibHVyYWJsZSwgdGhlbiBpdCBpc1xuICAgICAgdmFyIHRhZ0lzRm9jdXNhYmxlID0gdGhpcy5wLnByb3BzLnRhYkluZGV4IHx8IF9jb25zdGFudHMua25vd25Sb2xlVGFnc1t0aGlzLnRhZ05hbWVdO1xuXG4gICAgICAvLyBjYWxscyBmb2N1cy9ibHVyIHRvIHRyYW5zaXRpb24gZm9jdXMsIHJldHVybnMgJ3Rlcm1pbmF0ZScgaWYgZm9jdXMvYmx1ciBjYWxsIGlzIG1hZGVcbiAgICAgIC8vIGJlY2F1c2UgZm9jdXMvYmx1ciBldmVudCBoYW5kbGVyIGNhbGxlZCB1cGRhdGVTdGF0ZSxcbiAgICAgIC8vIHJldHVybnMgJ3VwZGF0ZVN0YXRlJyBpZiBub3QgYWxsb3dlZCB0byBtYWtlIHNwZWNpZmllZCB0cmFuc2l0aW9uLCBzbyBSSSB3aWxsIGNvbnRpbnVlXG4gICAgICAvLyB0byB1cGRhdGVTdGF0ZSB0aGlzIHRpbWUgdGhyb3VnaCBoYW5kbGVFdmVudFxuICAgICAgdmFyIGZvY3VzVHJhbnNpdGlvbiA9IGZ1bmN0aW9uIGZvY3VzVHJhbnNpdGlvbihldmVudCwgdHJhbnNpdGlvbkFzLCBmb3JjZSkge1xuICAgICAgICBpZiAoZm9yY2UgPT09ICdmb3JjZScgfHwgZXZlbnQgPT09ICdmb2N1cycgJiYgdGFnSXNGb2N1c2FibGUgfHwgZXZlbnQgPT09ICdibHVyJyAmJiB0YWdJc0JsdXJhYmxlKSB7XG4gICAgICAgICAgLy8gaWYgdGhlIG1hbmFnZUZvY3VzIGNhbGwgaXMgZnJvbSBhIGJyb3dzZXIgZXZlbnQgKGkuZS4gd2lsbCBidWJibGUpLCByZWdpc3RlciBpdFxuICAgICAgICAgIGlmIChlKSB7XG4gICAgICAgICAgICBfaW5wdXRUcmFja2VyLmZvY3VzUmVnaXN0cnlbZXZlbnRdID0gZTtcbiAgICAgICAgICAgIC8vIHJlc2V0IGV2ZW50IHJlZ2lzdHJ5IGFmdGVyIGJ1YmJsaW5nIGhhcyBmaW5pc2hlZCBiZWNhdXNlIFJlYWN0IHJldXNlcyBldmVudHMgc29cbiAgICAgICAgICAgIC8vIGZ1dHVyZSBldmVudCBlcXVhbGl0eSBjaGVja3MgbWF5IGdpdmUgYSBmYWxzZSBwb3NpdGl2ZSBpZiBub3QgcmVzZXRcbiAgICAgICAgICAgIF90aGlzNi5tYW5hZ2VTZXRUaW1lb3V0KCdmb2N1c1JlZ2lzdHJ5JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBfaW5wdXRUcmFja2VyLmZvY3VzUmVnaXN0cnlbZXZlbnRdID0gbnVsbDtcbiAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBfdGhpczYudHJhY2suZm9jdXNUcmFuc2l0aW9uID0gdHJhbnNpdGlvbkFzO1xuICAgICAgICAgIF90aGlzNi50b3BOb2RlW2V2ZW50XSgpO1xuICAgICAgICAgIC8vIGlmIGZvY3VzVHJhbnNpdGlvbiBoYXMgY2hhbmdlZCwgdGhlbiB0aGUgZm9jdXMvYmx1ciBjYWxsIHdhcyBzdWNlc3NmdWwgc28gdGVybWluYXRlXG4gICAgICAgICAgaWYgKF90aGlzNi50cmFjay5mb2N1c1RyYW5zaXRpb24gIT09IHRyYW5zaXRpb25Bcykge1xuICAgICAgICAgICAgcmV0dXJuICd0ZXJtaW5hdGUnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBfdGhpczYudHJhY2suZm9jdXNUcmFuc2l0aW9uID0gJ3Jlc2V0JztcbiAgICAgICAgcmV0dXJuICd1cGRhdGVTdGF0ZSc7XG4gICAgICB9O1xuXG4gICAgICAvLyB0b2dnbGVzIGZvY3VzIGJ5IGNhbGxpbmcgZm9jdXNUcmFuc2l0aW9uLCByZXR1cm5zIGZvY3VzVHJhbnNpdGlvbidzIHJldHVyblxuICAgICAgdmFyIHRvZ2dsZUZvY3VzID0gZnVuY3Rpb24gdG9nZ2xlRm9jdXModG9nZ2xlQXMsIGZvcmNlKSB7XG4gICAgICAgIGlmIChfdGhpczYudHJhY2suc3RhdGUuZm9jdXMpIHJldHVybiBmb2N1c1RyYW5zaXRpb24oJ2JsdXInLCB0b2dnbGVBcyArICdCbHVyJywgZm9yY2UpO1xuICAgICAgICByZXR1cm4gZm9jdXNUcmFuc2l0aW9uKCdmb2N1cycsIHRvZ2dsZUFzICsgJ0ZvY3VzJywgZm9yY2UpO1xuICAgICAgfTtcblxuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgJ21vdXNlZG93bic6XG4gICAgICAgICAgcmV0dXJuIGZvY3VzVHJhbnNpdGlvbignZm9jdXMnLCAnbW91c2VEb3duRm9jdXMnKTtcbiAgICAgICAgY2FzZSAnbW91c2V1cCc6XG4gICAgICAgICAgLy8gYmx1ciBvbmx5IGlmIGZvY3VzIHdhcyBub3QgaW5pdGlhdGVkIG9uIHRoZSBwcmVjZWRpbmcgbW91c2Vkb3duLFxuICAgICAgICAgIGlmICh0aGlzLnRyYWNrLmZvY3VzU3RhdGVPbk1vdXNlRG93bikgcmV0dXJuIGZvY3VzVHJhbnNpdGlvbignYmx1cicsICdtb3VzZVVwQmx1cicpO1xuICAgICAgICAgIHRoaXMudHJhY2suZm9jdXNUcmFuc2l0aW9uID0gJ3Jlc2V0JztcbiAgICAgICAgICByZXR1cm4gJ3VwZGF0ZVN0YXRlJztcbiAgICAgICAgY2FzZSAndG91Y2hjbGljayc6XG4gICAgICAgICAgcmV0dXJuIHRvZ2dsZUZvY3VzKCd0b3VjaENsaWNrJyk7XG4gICAgICAgIGNhc2UgJ2ZvcmNlU3RhdGVGb2N1c1RydWUnOlxuICAgICAgICAgIC8vIHNldFRpbWVvdXQgYmVjYXVzZSBSZWFjdCBtaXNzZXMgZm9jdXMgY2FsbHMgbWFkZSBkdXJpbmcgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyxcbiAgICAgICAgICAvLyB3aGljaCBpcyB3aGVyZSBmb3JjZVN0YXRlIGNhbGxzIGNvbWUgZnJvbSAodGhlIGJyb3dzZXIgcmVjZWl2ZXMgdGhlIGZvY3VzIGNhbGxcbiAgICAgICAgICAvLyBidXQgbm90IFJlYWN0KSwgc28gaGF2ZSB0byBjYWxsIGZvY3VzIGFzeW5jcm91bnNseSBzbyBSZWFjdCByZWNlaXZlcyBpdFxuICAgICAgICAgIHRoaXMubWFuYWdlU2V0VGltZW91dCgnZm9yY2VTdGF0ZUZvY3VzVHJ1ZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICFfdGhpczYudHJhY2suc3RhdGUuZm9jdXMgJiYgZm9jdXNUcmFuc2l0aW9uKCdmb2N1cycsICdmb3JjZVN0YXRlRm9jdXMnLCAnZm9yY2UnKTtcbiAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICByZXR1cm4gJ3Rlcm1pbmF0ZSc7XG4gICAgICAgIGNhc2UgJ2ZvcmNlU3RhdGVGb2N1c0ZhbHNlJzpcbiAgICAgICAgICAvLyBzYW1lIGFzIGZvcmNlU3RhdGVGb2N1c1RydWUsIGJ1dCBmb3IgZm9jdXMgZmFsc2VcbiAgICAgICAgICB0aGlzLm1hbmFnZVNldFRpbWVvdXQoJ2ZvcmNlU3RhdGVGb2N1c0ZhbHNlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXM2LnRyYWNrLnN0YXRlLmZvY3VzICYmIGZvY3VzVHJhbnNpdGlvbignYmx1cicsICdmb3JjZVN0YXRlQmx1cicsICdmb3JjZScpO1xuICAgICAgICAgIH0sIDApO1xuICAgICAgICAgIHJldHVybiAndGVybWluYXRlJztcbiAgICAgICAgY2FzZSAncmVmQ2FsbGJhY2snOlxuICAgICAgICAgIC8vIGlmIGluIHRoZSBmb2N1cyBzdGF0ZSBhbmQgUkkgaGFzIGEgbmV3IHRvcERPTU5vZGUsIHRoZW4gY2FsbCBmb2N1cygpIG9uIGB0aGlzLnRvcE5vZGVgXG4gICAgICAgICAgLy8gdG8ga2VlcCB0aGUgYnJvd3NlciBmb2N1cyBzdGF0ZSBpbiBzeW5jIHdpdGggUkkncyBmb2N1cyBzdGF0ZVxuICAgICAgICAgIGlmICh0aGlzLnRyYWNrLnN0YXRlLmZvY3VzKSByZXR1cm4gZm9jdXNUcmFuc2l0aW9uKCdmb2N1cycsICdyZWZDYWxsYmFja0ZvY3VzJywgJ2ZvcmNlJyk7XG4gICAgICAgICAgdGhpcy50cmFjay5mb2N1c1RyYW5zaXRpb24gPSAncmVzZXQnO1xuICAgICAgICAgIHJldHVybiAndGVybWluYXRlJztcbiAgICAgICAgY2FzZSAnZm9jdXNGb3JjZUJsdXInOlxuICAgICAgICAgIHJldHVybiBmb2N1c1RyYW5zaXRpb24oJ2JsdXInLCAnZm9jdXNGb3JjZUJsdXInLCAnZm9yY2UnKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gJ3VwZGF0ZVN0YXRlJztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyByZXR1cm5zICd0ZXJtaW5hdGUnIGlmIHRoZSBjYWxsZXIgKHRoaXMuaGFuZGxlRXZlbnQpIHNob3VsZCBub3QgY2FsbCB1cGRhdGVTdGF0ZSguLi4pXG5cbiAgfSwge1xuICAgIGtleTogJ2hhbmRsZU1vdXNlRXZlbnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVNb3VzZUV2ZW50KGUpIHtcbiAgICAgIHN3aXRjaCAoZS50eXBlKSB7XG4gICAgICAgIGNhc2UgJ21vdXNlZW50ZXInOlxuICAgICAgICAgICgwLCBfaW5wdXRUcmFja2VyLnVwZGF0ZU1vdXNlRnJvbVJJKShlKTtcbiAgICAgICAgICB0aGlzLnAucHJvcHMub25Nb3VzZUVudGVyICYmIHRoaXMucC5wcm9wcy5vbk1vdXNlRW50ZXIoZSk7XG4gICAgICAgICAgdGhpcy50cmFjay5tb3VzZU9uID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLnRyYWNrLmJ1dHRvbkRvd24gPSBlLmJ1dHRvbnMgPT09IDE7XG4gICAgICAgICAgcmV0dXJuICd1cGRhdGVTdGF0ZSc7XG4gICAgICAgIGNhc2UgJ21vdXNlbGVhdmUnOlxuICAgICAgICAgICgwLCBfaW5wdXRUcmFja2VyLnVwZGF0ZU1vdXNlRnJvbVJJKShlKTtcbiAgICAgICAgICB0aGlzLnAucHJvcHMub25Nb3VzZUxlYXZlICYmIHRoaXMucC5wcm9wcy5vbk1vdXNlTGVhdmUoZSk7XG4gICAgICAgICAgdGhpcy50cmFjay5tb3VzZU9uID0gZmFsc2U7XG4gICAgICAgICAgdGhpcy50cmFjay5idXR0b25Eb3duID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuICd1cGRhdGVTdGF0ZSc7XG4gICAgICAgIGNhc2UgJ21vdXNlbW92ZSc6XG4gICAgICAgICAgdGhpcy5wLnByb3BzLm9uTW91c2VNb3ZlICYmIHRoaXMucC5wcm9wcy5vbk1vdXNlTW92ZShlKTtcbiAgICAgICAgICAvLyBlYXJseSByZXR1cm4gZm9yIG1vdXNlIG1vdmVcbiAgICAgICAgICBpZiAodGhpcy50cmFjay5tb3VzZU9uICYmIHRoaXMudHJhY2suYnV0dG9uRG93biA9PT0gKGUuYnV0dG9ucyA9PT0gMSkpIHJldHVybiAndGVybWluYXRlJztcbiAgICAgICAgICB0aGlzLnRyYWNrLm1vdXNlT24gPSB0cnVlO1xuICAgICAgICAgIHRoaXMudHJhY2suYnV0dG9uRG93biA9IGUuYnV0dG9ucyA9PT0gMTtcbiAgICAgICAgICByZXR1cm4gJ3VwZGF0ZVN0YXRlJztcbiAgICAgICAgY2FzZSAnbW91c2Vkb3duJzpcbiAgICAgICAgICB0aGlzLnAucHJvcHMub25Nb3VzZURvd24gJiYgdGhpcy5wLnByb3BzLm9uTW91c2VEb3duKGUpO1xuICAgICAgICAgIHRoaXMudHJhY2subW91c2VPbiA9IHRydWU7XG4gICAgICAgICAgdGhpcy50cmFjay5idXR0b25Eb3duID0gdHJ1ZTtcbiAgICAgICAgICAvLyB0cmFjayBmb2N1cyBzdGF0ZSBvbiBtb3VzZWRvd24gdG8ga25vdyBpZiBzaG91bGQgYmx1ciBvbiBtb3VzZXVwXG4gICAgICAgICAgdGhpcy50cmFjay5mb2N1c1N0YXRlT25Nb3VzZURvd24gPSB0aGlzLnRyYWNrLnN0YXRlLmZvY3VzO1xuICAgICAgICAgIHJldHVybiB0aGlzLm1hbmFnZUZvY3VzKCdtb3VzZWRvd24nLCBlKTtcbiAgICAgICAgY2FzZSAnbW91c2V1cCc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5wLnByb3BzLm9uTW91c2VVcCAmJiB0aGlzLnAucHJvcHMub25Nb3VzZVVwKGUpO1xuICAgICAgICAgICAgdGhpcy50cmFjay5idXR0b25Eb3duID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgbWFuYWdlRm9jdXNSZXR1cm4gPSB0aGlzLm1hbmFnZUZvY3VzKCdtb3VzZXVwJywgZSk7XG4gICAgICAgICAgICB0aGlzLm1hbmFnZUNsaWNrKCdtb3VzZUNsaWNrJyk7XG4gICAgICAgICAgICByZXR1cm4gbWFuYWdlRm9jdXNSZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiAndGVybWluYXRlJztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyByZXR1cm5zICd0ZXJtaW5hdGUnIGlmIHRoZSBjYWxsZXIgKHRoaXMuaGFuZGxlRXZlbnQpIHNob3VsZCBub3QgY2FsbCB1cGRhdGVTdGF0ZSguLi4pXG4gICAgLy8gbm90ZSB0aGF0IGEgdG91Y2ggaW50ZXJhY3Rpb24gbGFzdHMgZnJvbSB0aGUgc3RhcnQgb2YgdGhlIGZpcnN0IHRvdWNoIHBvaW50IG9uIFJJLFxuICAgIC8vIHVudGlsIHJlbW92YWwgb2YgdGhlIGxhc3QgdG91Y2ggcG9pbnQgb24gUkksIGFuZCB0aGVuIHRoZSB0b3VjaCBpbnRlcmFjdGlvbiBpcyByZXNldFxuXG4gIH0sIHtcbiAgICBrZXk6ICdoYW5kbGVUb3VjaEV2ZW50JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlVG91Y2hFdmVudChlKSB7XG4gICAgICB2YXIgX3RoaXM3ID0gdGhpcztcblxuICAgICAgLy8gcmVzZXQgbW91c2UgdHJhY2tlcnNcbiAgICAgIHRoaXMudHJhY2subW91c2VPbiA9IGZhbHNlO1xuICAgICAgdGhpcy50cmFjay5idXR0b25Eb3duID0gZmFsc2U7XG5cbiAgICAgIC8vIHJlc2V0IHRvdWNoIGludGVyYWN0aW9uIHRyYWNraW5nLCBjYWxsZWQgd2hlbiB0aGVyZSBhcmUgbm8gbW9yZSB0b3VjaGVzIG9uIHRoZSB0YXJnZXRcbiAgICAgIHZhciByZXNldFRvdWNoSW50ZXJhY3Rpb24gPSBmdW5jdGlvbiByZXNldFRvdWNoSW50ZXJhY3Rpb24oKSB7XG4gICAgICAgIF90aGlzNy50cmFjay50b3VjaERvd24gPSBmYWxzZTtcbiAgICAgICAgX3RoaXM3LnRyYWNrLnRvdWNoZXMgPSB7IHBvaW50czoge30sIGFjdGl2ZTogMCB9O1xuICAgICAgICAvLyBjbGVhciB0aGUgdG91Y2hUYXBUaW1lciBpZiBpdCdzIHJ1bm5pbmdcbiAgICAgICAgX3RoaXM3LmNhbmNlbFRpbWVvdXQoJ3RvdWNoVGFwVGltZXInKTtcbiAgICAgIH07XG5cbiAgICAgIC8vIHRyYWNrIHJlY2VudCB0b3VjaCwgY2FsbGVkIGZyb20gdG91Y2hlbmQgYW5kIHRvdWNoY2FuY2VsXG4gICAgICB2YXIgcmVjZW50VG91Y2ggPSBmdW5jdGlvbiByZWNlbnRUb3VjaCgpIHtcbiAgICAgICAgX3RoaXM3LnRyYWNrLnJlY2VudFRvdWNoID0gdHJ1ZTtcbiAgICAgICAgX3RoaXM3Lm1hbmFnZVNldFRpbWVvdXQoJ3JlY2VudFRvdWNoVGltZXInLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3RoaXM3LnRyYWNrLnJlY2VudFRvdWNoID0gZmFsc2U7XG4gICAgICAgIH0sIF9jb25zdGFudHMucXVldWVUaW1lKTtcbiAgICAgIH07XG5cbiAgICAgIC8vIHJldHVybnMgdHJ1ZSBpZiB0aGVyZSBhcmUgZXh0cmEgdG91Y2hlcyBvbiB0aGUgc2NyZWVuXG4gICAgICB2YXIgZXh0cmFUb3VjaGVzID0gZnVuY3Rpb24gZXh0cmFUb3VjaGVzKCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIC8vIGlmIGV4dHJhVG91Y2hOb1RhcCBwcm9wIGFuZCBhbHNvIHRvdWNoaW5nIHNvbWVwbGFjZSBlbHNlIG9uIHRoZSBzY3JlZW4sIG9yXG4gICAgICAgICAgX3RoaXM3LnAucHJvcHMuZXh0cmFUb3VjaE5vVGFwICYmIGUudG91Y2hlcy5sZW5ndGggIT09IF90aGlzNy50cmFjay50b3VjaGVzLmFjdGl2ZSB8fFxuICAgICAgICAgIC8vIG1vcmUgdG91Y2hlcyBvbiBSSSB0aGFuIG1heFRhcFBvaW50c1xuICAgICAgICAgIF90aGlzNy50cmFjay50b3VjaGVzLmFjdGl2ZSA+IF90aGlzNy5tYXhUYXBQb2ludHNcbiAgICAgICAgKTtcbiAgICAgIH07XG5cbiAgICAgIC8vIHJldHVybnMgdHJ1ZSBpZiBhIHRvdWNoIHBvaW50IGhhcyBtb3ZlZCBtb3JlIHRoYW4gaXMgYWxsb3dlZCBmb3IgYSB0YXBcbiAgICAgIHZhciB0b3VjaE1vdmVkID0gZnVuY3Rpb24gdG91Y2hNb3ZlZChlbmRUb3VjaCwgc3RhcnRUb3VjaCwgbnVtYmVyT2ZQb2ludHMpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguYWJzKGVuZFRvdWNoLmNsaWVudFggLSBzdGFydFRvdWNoLnN0YXJ0WCkgPj0gMTUgKyAzICogbnVtYmVyT2ZQb2ludHMgfHwgTWF0aC5hYnMoZW5kVG91Y2guY2xpZW50WSAtIHN0YXJ0VG91Y2guc3RhcnRZKSA+PSAxNSArIDMgKiBudW1iZXJPZlBvaW50cztcbiAgICAgIH07XG5cbiAgICAgIC8vIGxvZyB0b3VjaCBwb3NpdGlvbiBmb3IgZWFjaCB0b3VjaCBwb2ludCB0aGF0IGlzIHBhcnQgb2YgdGhlIHRvdWNoIGV2ZW50XG4gICAgICB2YXIgbG9nVG91Y2hDb29yZHNBcyA9IGZ1bmN0aW9uIGxvZ1RvdWNoQ29vcmRzQXMobG9nQXMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlLmNoYW5nZWRUb3VjaGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHBvaW50ID0gX3RoaXM3LnRyYWNrLnRvdWNoZXMucG9pbnRzW2UuY2hhbmdlZFRvdWNoZXNbaV0uaWRlbnRpZmllcl0gfHwge307XG4gICAgICAgICAgcG9pbnRbbG9nQXMgKyAnWCddID0gZS5jaGFuZ2VkVG91Y2hlc1tpXS5jbGllbnRYO1xuICAgICAgICAgIHBvaW50W2xvZ0FzICsgJ1knXSA9IGUuY2hhbmdlZFRvdWNoZXNbaV0uY2xpZW50WTtcbiAgICAgICAgICBfdGhpczcudHJhY2sudG91Y2hlcy5wb2ludHNbZS5jaGFuZ2VkVG91Y2hlc1tpXS5pZGVudGlmaWVyXSA9IHBvaW50O1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBzd2l0Y2ggKGUudHlwZSkge1xuICAgICAgICBjYXNlICd0b3VjaHN0YXJ0JzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnAucHJvcHMub25Ub3VjaFN0YXJ0ICYmIHRoaXMucC5wcm9wcy5vblRvdWNoU3RhcnQoZSk7XG4gICAgICAgICAgICAvLyB1cGRhdGUgbnVtYmVyIG9mIGFjdGl2ZSB0b3VjaGVzXG4gICAgICAgICAgICB0aGlzLnRyYWNrLnRvdWNoZXMuYWN0aXZlICs9IGUuY2hhbmdlZFRvdWNoZXMubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKHRoaXMudHJhY2sudG91Y2hlcy50YXBDYW5jZWxlZCkgcmV0dXJuICd0ZXJtaW5hdGUnO1xuICAgICAgICAgICAgdmFyIG5ld1RvdWNoRG93biA9ICF0aGlzLnRyYWNrLnRvdWNoRG93bjtcbiAgICAgICAgICAgIHRoaXMudHJhY2sudG91Y2hEb3duID0gdHJ1ZTtcbiAgICAgICAgICAgIC8vIGNhbmNlbCB0YXAgaWYgdGhlcmUgd2FzIGFscmVhZHkgYSB0b3VjaGVuZCBpbiB0aGlzIGludGVyYWN0aW9uIG9yIHRoZXJlIGFyZSBleHRyYSB0b3VjaGVzXG4gICAgICAgICAgICBpZiAodGhpcy50cmFjay50b3VjaGVzLnRvdWNoZW5kIHx8IGV4dHJhVG91Y2hlcygpKSB7XG4gICAgICAgICAgICAgIC8vIHJlY3Vyc2l2ZWx5IGNhbGwgaGFuZGxlVG91Y2hFdmVudCB3aXRoIGEgdG91Y2h0YXBjYW5jZWwgZXZlbnQgdG8gc2V0IHRyYWNrIHByb3BlcnRpZXMsXG4gICAgICAgICAgICAgIC8vIGNhbGwgaGFuZGxlVG91Y2hFdmVudCBkaXJlY3RseSBkb24ndCBnbyB0aHJvdWdoIGhhbmRsZUV2ZW50IHNvIHVwZGF0ZVN0YXRlIGlzbid0IGNhbGxlZFxuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVUb3VjaEV2ZW50KHsgdHlwZTogJ3RvdWNodGFwY2FuY2VsJyB9KSA9PT0gJ3VwZGF0ZVN0YXRlJyB8fCBuZXdUb3VjaERvd24gPyAndXBkYXRlU3RhdGUnIDogJ3Rlcm1pbmF0ZSc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGlmIGdvaW5nIGZyb20gbm8gdG91Y2ggdG8gdG91Y2gsIHNldCB0b3VjaFRhcFRpbWVyXG4gICAgICAgICAgICBpZiAobmV3VG91Y2hEb3duKSB7XG4gICAgICAgICAgICAgIGUucGVyc2lzdCgpO1xuICAgICAgICAgICAgICB0aGlzLm1hbmFnZVNldFRpbWVvdXQoJ3RvdWNoVGFwVGltZXInLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIHRpbWVyIGZpbmlzaGVzIHRoZW4gY2FsbCBvbkxvbmdQcmVzcyBjYWxsYmFjayBhbmRcbiAgICAgICAgICAgICAgICAvLyBmaXJlIGEgdG91Y2h0YXBjYW5jZWwgZXZlbnQgdG8gY2FuY2VsIHRoZSB0YXAsXG4gICAgICAgICAgICAgICAgLy8gYmVjYXVzZSB0aGlzIGdvZXMgdGhyb3VnaCBoYW5kbGVFdmVudCwgdXBkYXRlU3RhdGUgd2lsbCBiZSBjYWxsZWQgaWYgbmVlZGVkXG4gICAgICAgICAgICAgICAgX3RoaXM3LnAucHJvcHMub25Mb25nUHJlc3MgJiYgX3RoaXM3LnAucHJvcHMub25Mb25nUHJlc3MoZSk7XG4gICAgICAgICAgICAgICAgX3RoaXM3LmhhbmRsZUV2ZW50KCgwLCBfY29uc3RhbnRzLmR1bW15RXZlbnQpKCd0b3VjaHRhcGNhbmNlbCcpKTtcbiAgICAgICAgICAgICAgfSwgdGhpcy5wLnByb3BzLnRhcFRpbWVDdXRvZmYpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBsb2cgdG91Y2ggc3RhcnQgcG9zaXRpb25cbiAgICAgICAgICAgIGxvZ1RvdWNoQ29vcmRzQXMoJ3N0YXJ0Jyk7XG4gICAgICAgICAgICByZXR1cm4gJ3VwZGF0ZVN0YXRlJztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAndG91Y2htb3ZlJzpcbiAgICAgICAgICB0aGlzLnAucHJvcHMub25Ub3VjaE1vdmUgJiYgdGhpcy5wLnByb3BzLm9uVG91Y2hNb3ZlKGUpO1xuICAgICAgICAgIGlmICh0aGlzLnRyYWNrLnRvdWNoZXMudGFwQ2FuY2VsZWQpIHJldHVybiAndGVybWluYXRlJztcbiAgICAgICAgICAvLyBjYW5jZWwgdGFwIGlmIHRoZXJlIGFyZSBleHRyYSB0b3VjaGVzXG4gICAgICAgICAgaWYgKGV4dHJhVG91Y2hlcygpKSByZXR1cm4gdGhpcy5oYW5kbGVUb3VjaEV2ZW50KHsgdHlwZTogJ3RvdWNodGFwY2FuY2VsJyB9KTtcblxuICAgICAgICAgIC8vIGlmIHRvdWNoQWN0aXZlVGFwT25seSBvciBvbkxvbmdQcmVzcyBwcm9wLFxuICAgICAgICAgIC8vIGNoZWNrIHRvIHNlZSBpZiB0aGUgdG91Y2ggbW92ZWQgZW5vdWdoIHRvIGNhbmNlbCB0YXBcbiAgICAgICAgICBpZiAodGhpcy5wLnByb3BzLnRvdWNoQWN0aXZlVGFwT25seSB8fCB0aGlzLnAucHJvcHMub25Mb25nUHJlc3MpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZS5jaGFuZ2VkVG91Y2hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICB2YXIgdG91Y2ggPSB0aGlzLnRyYWNrLnRvdWNoZXMucG9pbnRzW2UuY2hhbmdlZFRvdWNoZXNbaV0uaWRlbnRpZmllcl07XG4gICAgICAgICAgICAgIGlmICh0b3VjaCAmJiB0b3VjaE1vdmVkKGUuY2hhbmdlZFRvdWNoZXNbaV0sIHRvdWNoLCB0aGlzLm1heFRhcFBvaW50cykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVUb3VjaEV2ZW50KHsgdHlwZTogJ3RvdWNodGFwY2FuY2VsJyB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gJ3Rlcm1pbmF0ZSc7XG5cbiAgICAgICAgY2FzZSAndG91Y2hlbmQnOlxuICAgICAgICAgIC8vIHN0YXJ0IHJlY2VudCB0b3VjaCB0aW1lclxuICAgICAgICAgIHJlY2VudFRvdWNoKCk7XG4gICAgICAgICAgdGhpcy5wLnByb3BzLm9uVG91Y2hFbmQgJiYgdGhpcy5wLnByb3BzLm9uVG91Y2hFbmQoZSk7XG4gICAgICAgICAgLy8gdXBkYXRlIG51bWJlciBvZiBhY3RpdmUgdG91Y2hlc1xuICAgICAgICAgIHRoaXMudHJhY2sudG91Y2hlcy5hY3RpdmUgLT0gZS5jaGFuZ2VkVG91Y2hlcy5sZW5ndGg7XG4gICAgICAgICAgLy8gaWYgYSB0b3VjaCBldmVudCB3YXMgZHJvcHBlZCBzb21ld2hlcmUsIGkuZS5cbiAgICAgICAgICAvLyBjdW11bGF0aXZlIGxlbmd0aCBvZiBjaGFuZ2VkIHRvdWNoZXMgZm9yIHRvdWNoc3RhcnRzICE9PSB0b3VjaGVuZHMsIHRoZW4gcmVzZXRcbiAgICAgICAgICBpZiAodGhpcy50cmFjay50b3VjaGVzLmFjdGl2ZSA8IDAgfHwgZS50b3VjaGVzLmxlbmd0aCA9PT0gMCAmJiB0aGlzLnRyYWNrLnRvdWNoZXMuYWN0aXZlID4gMCkge1xuICAgICAgICAgICAgcmVzZXRUb3VjaEludGVyYWN0aW9uKCk7XG4gICAgICAgICAgICByZXR1cm4gJ3VwZGF0ZVN0YXRlJztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyB0cmFjayB0aGF0IHRoZXJlIGhhcyBiZWVuIGEgdG91Y2hlbmQgaW4gdGhpcyB0b3VjaCBpbnRlcmFjdGlvblxuICAgICAgICAgIHRoaXMudHJhY2sudG91Y2hlcy50b3VjaGVuZCA9IHRydWU7XG5cbiAgICAgICAgICAvLyBjaGVjayB0byBzZWUgaWYgdGFwIGlzIGFscmVhZHkgY2FuY2VsZWQgb3Igc2hvdWxkIGJlIGNhbmNlbGVkXG4gICAgICAgICAgaWYgKHRoaXMudHJhY2sudG91Y2hlcy5hY3RpdmUgPT09IDAgJiYgKHRoaXMudHJhY2sudG91Y2hlcy50YXBDYW5jZWxlZCB8fCBleHRyYVRvdWNoZXMoKSkpIHtcbiAgICAgICAgICAgIHJlc2V0VG91Y2hJbnRlcmFjdGlvbigpO1xuICAgICAgICAgICAgcmV0dXJuICd1cGRhdGVTdGF0ZSc7XG4gICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnRyYWNrLnRvdWNoZXMudGFwQ2FuY2VsZWQpIHJldHVybiAndGVybWluYXRlJztlbHNlIGlmIChleHRyYVRvdWNoZXMoKSkgcmV0dXJuIHRoaXMuaGFuZGxlVG91Y2hFdmVudCh7IHR5cGU6ICd0b3VjaHRhcGNhbmNlbCcgfSk7XG5cbiAgICAgICAgICAvLyBsb2cgdG91Y2ggZW5kIHBvc2l0aW9uXG4gICAgICAgICAgbG9nVG91Y2hDb29yZHNBcygnY2xpZW50Jyk7XG5cbiAgICAgICAgICAvLyBpZiB0aGVyZSBhcmUgbm8gcmVtYWluaW5nIHRvdWNoZXMsIHRoZW4gcHJvY2VzcyB0aGUgdG91Y2ggaW50ZXJhY3Rpb25cbiAgICAgICAgICBpZiAodGhpcy50cmFjay50b3VjaGVzLmFjdGl2ZSA9PT0gMCkge1xuICAgICAgICAgICAgdmFyIHRvdWNoZXMgPSB0aGlzLnRyYWNrLnRvdWNoZXMucG9pbnRzO1xuICAgICAgICAgICAgdmFyIHRvdWNoS2V5cyA9IE9iamVjdC5rZXlzKHRvdWNoZXMpO1xuICAgICAgICAgICAgdmFyIGNvdW50ID0gdG91Y2hLZXlzLmxlbmd0aDtcblxuICAgICAgICAgICAgLy8gZGV0ZXJtaW5lIGlmIHRoZXJlIHdhcyBhIHRhcCBhbmQgbnVtYmVyIG9mIHRvdWNoIHBvaW50cyBmb3IgdGhlIHRhcFxuICAgICAgICAgICAgLy8gaWYgZXZlcnkgdG91Y2ggcG9pbnQgaGFzbid0IG1vdmVkLCBzZXQgdGFwVG91Y2hQb2ludHMgdG8gY291bnRcbiAgICAgICAgICAgIHZhciB0YXBUb3VjaFBvaW50cyA9IHRvdWNoS2V5cy5ldmVyeShmdW5jdGlvbiAodG91Y2gpIHtcbiAgICAgICAgICAgICAgcmV0dXJuICF0b3VjaE1vdmVkKHRvdWNoZXNbdG91Y2hdLCB0b3VjaGVzW3RvdWNoXSwgY291bnQpO1xuICAgICAgICAgICAgfSkgPyBjb3VudCA6IDA7XG5cbiAgICAgICAgICAgIC8vIHJlc2V0IHRoZSB0b3VjaCBpbnRlcmFjdGlvblxuICAgICAgICAgICAgcmVzZXRUb3VjaEludGVyYWN0aW9uKCk7XG5cbiAgICAgICAgICAgIHN3aXRjaCAodGFwVG91Y2hQb2ludHMpIHtcbiAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIHZhciBtYW5hZ2VGb2N1c1JldHVybiA9ICd1cGRhdGVTdGF0ZSc7XG4gICAgICAgICAgICAgICAgICAvLyBpZiBubyBhY3RpdmUgb3IgdG91Y2hBY3RpdmUgcHJvcCwgbGV0IHRoZSBicm93c2VyIGhhbmRsZSBjbGljayBldmVudHNcbiAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnAucHJvcHMuYWN0aXZlIHx8IHRoaXMucC5wcm9wcy50b3VjaEFjdGl2ZSkge1xuICAgICAgICAgICAgICAgICAgICBtYW5hZ2VGb2N1c1JldHVybiA9IHRoaXMubWFuYWdlRm9jdXMoJ3RvdWNoY2xpY2snLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYW5hZ2VDbGljaygndGFwQ2xpY2snKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHJldHVybiBtYW5hZ2VGb2N1c1JldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICB0aGlzLnAucHJvcHMub25UYXBUd28gJiYgdGhpcy5wLnByb3BzLm9uVGFwVHdvKGUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgdGhpcy5wLnByb3BzLm9uVGFwVGhyZWUgJiYgdGhpcy5wLnByb3BzLm9uVGFwVGhyZWUoZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICB0aGlzLnAucHJvcHMub25UYXBGb3VyICYmIHRoaXMucC5wcm9wcy5vblRhcEZvdXIoZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiAndXBkYXRlU3RhdGUnO1xuXG4gICAgICAgIGNhc2UgJ3RvdWNoY2FuY2VsJzpcbiAgICAgICAgICByZWNlbnRUb3VjaCgpO1xuICAgICAgICAgIHRoaXMucC5wcm9wcy5vblRvdWNoQ2FuY2VsICYmIHRoaXMucC5wcm9wcy5vblRvdWNoQ2FuY2VsKGUpO1xuICAgICAgICAgIHRoaXMudHJhY2sudG91Y2hlcy5hY3RpdmUgLT0gZS5jaGFuZ2VkVG91Y2hlcy5sZW5ndGg7XG5cbiAgICAgICAgICAvLyBpZiB0aGVyZSBhcmUgbm8gcmVtYWluaW5nIHRvdWNoZXMsIHRoZW4gcmVzZXQgdGhlIHRvdWNoIGludGVyYWN0aW9uXG4gICAgICAgICAgaWYgKHRoaXMudHJhY2sudG91Y2hlcy5hY3RpdmUgPT09IDApIHtcbiAgICAgICAgICAgIHJlc2V0VG91Y2hJbnRlcmFjdGlvbigpO1xuICAgICAgICAgICAgcmV0dXJuICd1cGRhdGVTdGF0ZSc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gY2FuY2VsIHRhcCBhbmQgcmV0dXJuIHdoYXRldmVyIHRvdWNodGFwY2FuY2VsIHNheXMgdG9kb1xuICAgICAgICAgIHJldHVybiB0aGlzLmhhbmRsZVRvdWNoRXZlbnQoeyB0eXBlOiAndG91Y2h0YXBjYW5jZWwnIH0pO1xuXG4gICAgICAgIC8vIGNhbmNlbCB0YXAgZm9yIHRoaXMgdG91Y2ggaW50ZXJhY3Rpb25cbiAgICAgICAgY2FzZSAndG91Y2h0YXBjYW5jZWwnOlxuICAgICAgICAgIC8vIGNsZWFyIHRoZSB0b3VjaFRhcFRpbWVyIGlmIGl0J3MgcnVubmluZ1xuICAgICAgICAgIHRoaXMuY2FuY2VsVGltZW91dCgndG91Y2hUYXBUaW1lcicpO1xuICAgICAgICAgIGlmICh0aGlzLnRyYWNrLnRvdWNoRG93bikge1xuICAgICAgICAgICAgLy8gc2V0IHRoZSB0YXAgZXZlbnQgdG8gY2FuY2VsZWRcbiAgICAgICAgICAgIHRoaXMudHJhY2sudG91Y2hlcy50YXBDYW5jZWxlZCA9IHRydWU7XG4gICAgICAgICAgICBpZiAodGhpcy5wLnByb3BzLnRvdWNoQWN0aXZlVGFwT25seSkge1xuICAgICAgICAgICAgICAvLyBpZiB0b3VjaEFjdGl2ZVRhcE9ubHkgcHJvcCwgZXhpdCB0aGUgdG91Y2hBY3RpdmUgc3RhdGUgYW5kIHVwZGF0ZVN0YXRlXG4gICAgICAgICAgICAgIHRoaXMudHJhY2sudG91Y2hEb3duID0gZmFsc2U7XG4gICAgICAgICAgICAgIHJldHVybiAndXBkYXRlU3RhdGUnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gJ3Rlcm1pbmF0ZSc7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuICd0ZXJtaW5hdGUnO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNhbGxlZCBpbiBhbnRpY2lwYXRpb24gb2YgYSBjbGljayBldmVudCAoYmVmb3JlIGl0J3MgZmlyZWQpIHRvIHRyYWNrIHRoZSBzb3VyY2VcbiAgICAvLyBvZiB0aGUgY2xpY2sgZXZlbnQgKG1vdXNlLCB0b3VjaCwga2V5KSwgYW5kIHN5bnRoZXRpY2FsbHkgY2FsbCBub2RlLmNsaWNrKCkgaWYgbmVlZGVkXG5cbiAgfSwge1xuICAgIGtleTogJ21hbmFnZUNsaWNrJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWFuYWdlQ2xpY2sodHlwZSkge1xuICAgICAgdmFyIF90aGlzOCA9IHRoaXM7XG5cbiAgICAgIC8vIGNsZWFyIGNsaWNrVHlwZSB0aW1lciBpZiBpdCdzIHJ1bm5pbmdcbiAgICAgIHRoaXMuY2FuY2VsVGltZW91dCgnY2xpY2tUeXBlJyk7XG5cbiAgICAgIC8vIHRpbWVyIHRvIHJlc2V0IHRoZSBjbGlja1R5cGUsXG4gICAgICAvLyB3aGVuIGl0J3MgbGVmdCB0byB0aGUgYnJvd3NlciB0byBjYWxsIGNsaWNrKCksIHRoZSBicm93c2VyIGhhcyBxdWV1ZVRpbWVcbiAgICAgIC8vIHRvIGFkZCB0aGUgY2xpY2sgZXZlbnQgdG8gdGhlIHF1ZXVlIGZvciBpdCB0byBiZSByZWNvZ25pemVkIGFzIGEga25vd24gY2xpY2sgZXZlbnRcbiAgICAgIHZhciBzZXRDbGlja1R5cGVUaW1lciA9IGZ1bmN0aW9uIHNldENsaWNrVHlwZVRpbWVyKCkge1xuICAgICAgICBfdGhpczgubWFuYWdlU2V0VGltZW91dCgnY2xpY2tUeXBlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzOC50cmFjay5jbGlja1R5cGUgPSAncmVzZXQnO1xuICAgICAgICB9LCBfY29uc3RhbnRzLnF1ZXVlVGltZSk7XG4gICAgICB9O1xuXG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAnbW91c2VDbGljayc6XG4gICAgICAgICAgdGhpcy50cmFjay5jbGlja1R5cGUgPSAnbW91c2VDbGljayc7XG4gICAgICAgICAgLy8gbGV0IHRoZSBicm93c2VyIGNhbGwgY2xpY2soKSBmb3IgbW91c2UgaW50ZXJhY3Rpb25zXG4gICAgICAgICAgc2V0Q2xpY2tUeXBlVGltZXIoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAndGFwQ2xpY2snOlxuICAgICAgICAgIHRoaXMudHJhY2suY2xpY2tUeXBlID0gJ3RhcENsaWNrJztcbiAgICAgICAgICAvLyBmb3IgdG91Y2ggaW50ZXJhY3Rpb25zLCB1c2Ugc3ludGhldGljQ2xpY2sgdG8gY2FsbCBub2RlLmNsaWNrKCkgbm93IGFuZFxuICAgICAgICAgIC8vIGJsb2NrIHRoZSBzdWJzZXF1ZW50IGNsaWNrIGV2ZW50IGNyZWF0ZWQgYnkgdGhlIGJyb3dzZXIgaWYgdGhlcmUgaXMgb25lXG4gICAgICAgICAgKDAsIF9zeW50aGV0aWNDbGljazIuZGVmYXVsdCkodGhpcy50b3BOb2RlKTtcbiAgICAgICAgICB0aGlzLnRyYWNrLmNsaWNrVHlwZSA9ICdyZXNldCc7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2tleUNsaWNrJzpcbiAgICAgICAgICB0aGlzLnRyYWNrLmNsaWNrVHlwZSA9ICdrZXlDbGljayc7XG4gICAgICAgICAgLy8gaWYgdGhlIGVsZW1lbnQgaGFzIGEga25vd24gaW50ZXJhY3RpdmUgcm9sZSAoYSwgYnV0dG9uLCBpbnB1dCwgZXRjKSxcbiAgICAgICAgICAvLyB0aGVuIGxldCB0aGUgYnJvd3NlciBjYWxsIGNsaWNrKCkgZm9yIGtleUNsaWNrIGludGVyYWN0aW9ucyAoZW50ZXIga2V5IGFuZC9vciBzcGFjZSBiYXIpXG4gICAgICAgICAgaWYgKF9jb25zdGFudHMua25vd25Sb2xlVGFnc1t0aGlzLnRhZ05hbWVdKSB7XG4gICAgICAgICAgICBzZXRDbGlja1R5cGVUaW1lcigpO1xuXG4gICAgICAgICAgICAvLyBpZiB0aGUgZWxlbWVudCBkb2Vzbid0IGhhdmUgYSBrbm93biBpbnRlcmFjdGl2ZSByb2xlLCBidXQgdGhlcmUgaXMgYW4gb25DbGljayBwcm9wLFxuICAgICAgICAgICAgLy8gdGhlbiBjYWxsIG5vZGUuY2xpY2soKSBkaXJlY3RseSBhcyB0aGUgYnJvd3NlciB3b24ndCBmaXJlIGEgY2xpY2sgZXZlbnRcbiAgICAgICAgICAgIC8vIGZyb20gYSBrZXlDbGljayBpbnRlcmFjdGlvblxuICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5wLnByb3BzLm9uQ2xpY2spIHtcbiAgICAgICAgICAgIHRoaXMudG9wTm9kZS5jbGljaygpO1xuICAgICAgICAgICAgdGhpcy50cmFjay5jbGlja1R5cGUgPSAncmVzZXQnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyByZXR1cm5zICd0ZXJtaW5hdGUnIGlmIHRoZSBjYWxsZXIgKHRoaXMuaGFuZGxlRXZlbnQpIHNob3VsZCBub3QgY2FsbCB1cGRhdGVTdGF0ZSguLi4pXG4gICAgLy8gaW4gYWxtb3N0IGNhc2VzIHRoaXMgd2lsbCByZXR1cm4gdGVybWluYXRlIGFzIGNsaWNrIGV2ZW50cyBkb24ndCBjaGFuZ2Ugc3RhdGUsXG4gICAgLy8gdGhlIG9uZSBleGNlcHRpb24gaXMgYW4gdW5rbm93biBidXQgdmFsaWQgY2xpY2sgZXZlbnQgZnJvbSBhIHRvdWNoIGludGVyYWN0aW9uLFxuICAgIC8vIHdoaWNoIHdpbGwgbmVlZCB0byBtYW5hZ2VGb2N1cywgYW5kIHRoZW4gcmV0dXJuIHdoYXRldmVyIG1hbmFnZUZvY3VzIHNheXMgdG8gZG9cblxuICB9LCB7XG4gICAga2V5OiAnaGFuZGxlQ2xpY2tFdmVudCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZUNsaWNrRXZlbnQoZSkge1xuICAgICAgLy8gY2xlYXIgY2xpY2tUeXBlIHRpbWVyIGlmIHJ1bm5pbmdcbiAgICAgIHRoaXMuY2FuY2VsVGltZW91dCgnY2xpY2tUeXBlJyk7XG4gICAgICB2YXIgcmV0dXJuVmFsdWUgPSAndGVybWluYXRlJztcbiAgICAgIC8vIGlmIHRoaXMgaXMgYW4gdW5rbm93biBjbGljayBldmVudCwgbWFrZSBzb21lIGFzc3VtcHRpb25zXG4gICAgICBpZiAodGhpcy50cmFjay5jbGlja1R5cGUgPT09ICdyZXNldCcpIHtcbiAgICAgICAgLy8gdW5rbm93biBjbGljayBldmVudCBvbiBhIGZvcm0gc3VibWl0IGlucHV0IHdpdGggYSByZWNlbnRFbnRlcktleURvd24gb24gdGhlIGRvY3VtZW50XG4gICAgICAgIC8vIGlzIGNvbnNpZGVyZWQgdG8gYmUgYSBrZXlDbGljayAod2hlbiB5b3UgcHJlc3MgZW50ZXIgdG8gc3VibWl0IGEgZm9ybVxuICAgICAgICAvLyBidXQgZm9jdXMgaXMgbm90IG9uIHRoZSBzdWJtaXQgYnV0dG9uKVxuICAgICAgICB2YXIgZW50ZXJLZXlGb3JtU3VibWl0ID0gdGhpcy50YWdOYW1lID09PSAnaW5wdXQnICYmIHRoaXMudHlwZSA9PT0gJ3N1Ym1pdCcgJiYgX2lucHV0VHJhY2tlcjIuZGVmYXVsdC5rZXkucmVjZW50RW50ZXJLZXlEb3duO1xuICAgICAgICBpZiAoZW50ZXJLZXlGb3JtU3VibWl0KSB0aGlzLnRyYWNrLmNsaWNrVHlwZSA9ICdrZXlDbGljayc7ZWxzZSBpZiAoX2lucHV0VHJhY2tlcjIuZGVmYXVsdC50b3VjaC5yZWNlbnRUb3VjaCB8fCBfaW5wdXRUcmFja2VyMi5kZWZhdWx0LnRvdWNoLnRvdWNoT25TY3JlZW4gfHwgX2NvbnN0YW50cy5kZXZpY2VUeXBlID09PSAndG91Y2hPbmx5Jykge1xuICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIGEgcmVjZW50IHRvdWNoIG9uIHRoZSBkb2N1bWVudCxcbiAgICAgICAgICAvLyBvciB0aGlzIGlzIGEgdW5rbm93biBzeW50aGV0aWMgY2xpY2sgZXZlbnQgb24gYSB0b3VjaE9ubHkgZGV2aWNlXG4gICAgICAgICAgcmV0dXJuVmFsdWUgPSB0aGlzLm1hbmFnZUZvY3VzKCd0b3VjaGNsaWNrJywgZSk7XG4gICAgICAgICAgdGhpcy50cmFjay5rZXlDbGljayA9ICd0YXBDbGljayc7XG4gICAgICAgICAgLy8gZWxzZSB0aGlzIGlzIGEgdW5rbm93biBzeW50aGV0aWMgY2xpY2sgZXZlbnQgb24gYSBtb3VzZU9ubHkgb3IgaHlicmlkIGRldmljZVxuICAgICAgICB9IGVsc2UgdGhpcy50cmFjay5rZXlDbGljayA9ICdtb3VzZUNsaWNrJztcbiAgICAgIH1cblxuICAgICAgLy8gZm9jdXMgaXMgbm90IGNhbGxlZCBvbiB0b3VjaCB0YXAgd2l0aCBsaW5rcyB0aGF0IG9wZW4gaW4gYSBuZXcgd2luZG93XG4gICAgICAvLyBvbiBwYWdlcyB0aGF0IGhhdmUgYmVlbiBuYXZpZ2F0ZWQgdG8gd2l0aCBwdXNoU3RhdGUgKG9ubHkgdGVzdGVkIHJlYWN0IHJvdXRlcikuXG4gICAgICAvLyBTbyBuZWVkIHRvIHNpbXVsYXRlIGEgcHJldmlvdXMgZm9jdXMgc3RhdGUgb2YgdG91Y2ggYW5kIGEgd2luZG93IGJsdXIgZXZlbnQgYnlcbiAgICAgIC8vIHNpZ25pbmcgdXAgdG8gYmUgbm90aWZpZWQgb2YgbmV4dCB3aW5kb3cgZm9jdXMgZXZlbnQuXG4gICAgICAvLyBOb3RlIHRoYXQgaWYgbmF2aWdhdGVkIHRvIHd3dy5leGFtcGxlLnRsZC9zb21lLXBhZ2Ugd2l0aCBwdXNoU3RhdGUgbGluayAoZS5nLiBSUiBMaW5rKVxuICAgICAgLy8gdGhlbiBmb2N1cyBpcyBub3QgY2FsbGVkIG9uIHRhcCwgYnV0IGlmIGRvIGEgZnJlc2ggcGFnZSBsb2FkIGZvciB3d3cuZXhhbXBsZS50bGQvc29tZS1wYWdlXG4gICAgICAvLyB0aGVuIGZvY3VzIGlzIGNhbGxlZCBvbiB0YXAgYmVmb3JlIG9wZW5pbmcgdGhlIGxpbmsgaW4gYSBuZXcgd2luZG93ICh3aGljaCBpcyByZWFsbHkgd2VpcmQpLlxuICAgICAgLy8gTm90ZSB0aGF0IGZvY3VzIG5vdCBjYWxsZWQgbWVhbnMgdGhlIGJyb3dzZXIgZG9lc24ndCByZXNwZWN0IGZvY3VzIGNhbGxzIGdlbmVyYXRlZCBieSBSSVxuICAgICAgLy8gKGFuZCB0aGUgYnJvd3NlciBtYXkgbm90IGdlbmVyYXRlIGEgZm9jdXMgY2FsbCBpdHNlbGYsIHJlc3VsdHMgdmFyaWVkIGJ5IGJyb3dzZXIpLlxuICAgICAgLy8gVGhpcyBpcyBvbmx5IGEgcHJvYmxlbSBvbiBBbmRyb2lkIENocm9tZSBiZWNhdXNlIGRlc3BpdGUgbm90IGNhbGxpbmcgZm9jdXMgb24gbGluayB0YXAsXG4gICAgICAvLyB1cG9uIHJldHVybmluZyB0byB0aGUgd2luZG93LCBmb2N1cyBpcyBjYWxsZWQgb24gdGhlIGVsZW1lbnQgcHV0dGluZyBpdFxuICAgICAgLy8gaW50byB0aGUgZm9jdXNGcm9tVGFiIHN0YXRlLCB3aGVuIGl0IHNob3VsZCBiZSBpbiB0aGUgZm9jdXNGcm9tVG91Y2ggc3RhdGUuXG4gICAgICBpZiAodGhpcy5wLnByb3BzLnRhcmdldCA9PT0gJ19ibGFuaycgJiYgdGhpcy50cmFjay5jbGlja1R5cGUgPT09ICd0YXBDbGljaycgJiYgIXRoaXMudHJhY2subm90aWZ5T2ZOZXh0LmZvY3VzKSB7XG4gICAgICAgIHRoaXMudHJhY2sucHJldmlvdXNGb2N1cyA9ICd0b3VjaCc7XG4gICAgICAgIHRoaXMudHJhY2subm90aWZ5T2ZOZXh0LmZvY3VzID0gKDAsIF9ub3RpZmllci5ub3RpZnlPZk5leHQpKCdmb2N1cycsIHRoaXMuaGFuZGxlTm90aWZ5T2ZOZXh0KTtcbiAgICAgIH1cblxuICAgICAgLy8gY2FsbCBvbkNsaWNrIGhhbmRsZXIgYW5kIHBhc3MgaW4gY2xpY2tUeXBlIChtb3VzZUNsaWNrLCB0YXBDbGljaywga2V5Q2xpY2spIGFzIDJuZCBhcmd1bWVudFxuICAgICAgdGhpcy5wLnByb3BzLm9uQ2xpY2sgJiYgdGhpcy5wLnByb3BzLm9uQ2xpY2soZSwgdGhpcy50cmFjay5jbGlja1R5cGUpO1xuICAgICAgdGhpcy50cmFjay5jbGlja1R5cGUgPSAncmVzZXQnO1xuICAgICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICAgIH1cblxuICAgIC8vIHJldHVybnMgJ3Rlcm1pbmF0ZScgaWYgdGhlIGNhbGxlciAodGhpcy5oYW5kbGVFdmVudCkgc2hvdWxkIG5vdCBjYWxsIHVwZGF0ZVN0YXRlKC4uLilcblxuICB9LCB7XG4gICAga2V5OiAnaGFuZGxlT3RoZXJFdmVudCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZU90aGVyRXZlbnQoZSkge1xuICAgICAgc3dpdGNoIChlLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnZm9jdXMnOlxuICAgICAgICAgIHRoaXMucC5wcm9wcy5vbkZvY3VzICYmIHRoaXMucC5wcm9wcy5vbkZvY3VzKGUpO1xuXG4gICAgICAgICAgLy8gaWYgdGhpcyBpbnN0YW5jZSBvZiBSSSBpcyBub3QgdGhlIGZvY3VzIHRhcmdldCwgdGhlbiBkb24ndCBlbnRlciB0aGUgZm9jdXMgc3RhdGVcbiAgICAgICAgICBpZiAoZS50YXJnZXQgIT09IHRoaXMudG9wTm9kZSkgcmV0dXJuICd0ZXJtaW5hdGUnO1xuXG4gICAgICAgICAgLy8gaWYgdGhpcyBpcyBhIGtub3duIGZvY3VzVHJhbnNpdGlvbiBvciBmb2N1cyBpcyBmYWxzZSxcbiAgICAgICAgICAvLyB0aGVuIHNldCBmb2N1cyBiYXNlZCBvbiB0aGUgdHlwZSBvZiBmb2N1c1RyYW5zaXRpb24sXG4gICAgICAgICAgaWYgKHRoaXMudHJhY2suZm9jdXNUcmFuc2l0aW9uICE9PSAncmVzZXQnIHx8ICF0aGlzLnRyYWNrLmZvY3VzKSB7XG4gICAgICAgICAgICB2YXIgZm9jdXNUcmFuc2l0aW9uID0gdGhpcy50cmFjay5mb2N1c1RyYW5zaXRpb24udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGlmICgvbW91c2UvLnRlc3QoZm9jdXNUcmFuc2l0aW9uKSkge1xuICAgICAgICAgICAgICB0aGlzLnRyYWNrLmZvY3VzID0gJ21vdXNlJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoL3RvdWNoLy50ZXN0KGZvY3VzVHJhbnNpdGlvbikgfHwgdGhpcy50cmFjay50b3VjaERvd24pIHtcbiAgICAgICAgICAgICAgdGhpcy50cmFjay5mb2N1cyA9ICd0b3VjaCc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMudHJhY2sucmVpbnN0YXRlRm9jdXMpIHtcbiAgICAgICAgICAgICAgdGhpcy50cmFjay5mb2N1cyA9IHRoaXMudHJhY2sucHJldmlvdXNGb2N1cztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIS9mb3JjZXN0YXRlLy50ZXN0KGZvY3VzVHJhbnNpdGlvbikpIHtcbiAgICAgICAgICAgICAgdGhpcy50cmFjay5mb2N1cyA9ICd0YWInO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGlmIHRoZXJlIHdhcyBhIHRpbWVyIHNldCBieSBhIHJlY2VudCB3aW5kb3cgZm9jdXMgZXZlbnQsIGNsZWFyIGl0XG4gICAgICAgICAgdGhpcy5jYW5jZWxUaW1lb3V0KCd3aW5kb3dGb2N1cycpO1xuICAgICAgICAgIC8vIG9ubHkgcmVpbnN0YXRlIGZvY3VzIGZyb20gd2luZG93IGJsdXIvZm9jdXMgZm9yIG5leHQgZm9jdXMgZXZlbnRcbiAgICAgICAgICB0aGlzLnRyYWNrLnJlaW5zdGF0ZUZvY3VzID0gZmFsc2U7XG5cbiAgICAgICAgICB0aGlzLnRyYWNrLmZvY3VzVHJhbnNpdGlvbiA9ICdyZXNldCc7XG4gICAgICAgICAgcmV0dXJuICd1cGRhdGVTdGF0ZSc7XG4gICAgICAgIGNhc2UgJ2JsdXInOlxuICAgICAgICAgIHRoaXMucC5wcm9wcy5vbkJsdXIgJiYgdGhpcy5wLnByb3BzLm9uQmx1cihlKTtcbiAgICAgICAgICBpZiAoZS50YXJnZXQgIT09IHRoaXMudG9wTm9kZSkgcmV0dXJuICd0ZXJtaW5hdGUnO1xuICAgICAgICAgIHRoaXMudHJhY2suZm9jdXNUcmFuc2l0aW9uID0gJ3Jlc2V0JztcbiAgICAgICAgICB0aGlzLnRyYWNrLnByZXZpb3VzRm9jdXMgPSB0aGlzLnRyYWNrLmZvY3VzO1xuICAgICAgICAgIHRoaXMudHJhY2suZm9jdXMgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLnRyYWNrLnNwYWNlS2V5RG93biA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMudHJhY2suZW50ZXJLZXlEb3duID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuICd1cGRhdGVTdGF0ZSc7XG4gICAgICAgIGNhc2UgJ2tleWRvd24nOlxuICAgICAgICAgIHRoaXMucC5wcm9wcy5vbktleURvd24gJiYgdGhpcy5wLnByb3BzLm9uS2V5RG93bihlKTtcbiAgICAgICAgICBpZiAoIXRoaXMudHJhY2suZm9jdXMpIHJldHVybiAndGVybWluYXRlJztcbiAgICAgICAgICBpZiAoZS5rZXkgPT09ICcgJykgdGhpcy50cmFjay5zcGFjZUtleURvd24gPSB0cnVlO2Vsc2UgaWYgKGUua2V5ID09PSAnRW50ZXInKSB7XG4gICAgICAgICAgICB0aGlzLnRyYWNrLmVudGVyS2V5RG93biA9IHRydWU7XG4gICAgICAgICAgICBpZiAodGhpcy5lbnRlcktleVRyaWdnZXIpIHRoaXMubWFuYWdlQ2xpY2soJ2tleUNsaWNrJyk7XG4gICAgICAgICAgfSBlbHNlIHJldHVybiAndGVybWluYXRlJztcbiAgICAgICAgICByZXR1cm4gJ3VwZGF0ZVN0YXRlJztcbiAgICAgICAgY2FzZSAna2V5dXAnOlxuICAgICAgICAgIHRoaXMucC5wcm9wcy5vbktleVVwICYmIHRoaXMucC5wcm9wcy5vbktleVVwKGUpO1xuICAgICAgICAgIGlmICghdGhpcy50cmFjay5mb2N1cykgcmV0dXJuICd0ZXJtaW5hdGUnO1xuICAgICAgICAgIGlmIChlLmtleSA9PT0gJ0VudGVyJykgdGhpcy50cmFjay5lbnRlcktleURvd24gPSBmYWxzZTtlbHNlIGlmIChlLmtleSA9PT0gJyAnKSB7XG4gICAgICAgICAgICB0aGlzLnRyYWNrLnNwYWNlS2V5RG93biA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHRoaXMuc3BhY2VLZXlUcmlnZ2VyKSB0aGlzLm1hbmFnZUNsaWNrKCdrZXlDbGljaycpO1xuICAgICAgICAgIH0gZWxzZSByZXR1cm4gJ3Rlcm1pbmF0ZSc7XG4gICAgICAgICAgcmV0dXJuICd1cGRhdGVTdGF0ZSc7XG4gICAgICAgIGNhc2UgJ2RyYWdzdGFydCc6XG4gICAgICAgICAgdGhpcy5wLnByb3BzLm9uRHJhZ1N0YXJ0ICYmIHRoaXMucC5wcm9wcy5vbkRyYWdTdGFydChlKTtcbiAgICAgICAgICB0aGlzLnRyYWNrLmRyYWcgPSB0cnVlO1xuICAgICAgICAgIHJldHVybiAndXBkYXRlU3RhdGUnO1xuICAgICAgICBjYXNlICdkcmFnZW5kJzpcbiAgICAgICAgICB0aGlzLnAucHJvcHMub25EcmFnRW5kICYmIHRoaXMucC5wcm9wcy5vbkRyYWdFbmQoZSk7XG4gICAgICAgICAgdGhpcy5mb3JjZVRyYWNrSVN0YXRlKCdub3JtYWwnKTtcbiAgICAgICAgICByZXR1cm4gJ3VwZGF0ZVN0YXRlJztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gJ3Rlcm1pbmF0ZSc7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY29tcHV0ZVN0eWxlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcHV0ZVN0eWxlKCkge1xuICAgICAgLy8gYnVpbGQgc3R5bGUgb2JqZWN0LCBwcmlvcml0eSBvcmRlcjogc3RhdGUgc3R5bGVzLCBzdHlsZSBwcm9wLCBkZWZhdWx0IHN0eWxlc1xuICAgICAgdmFyIHN0eWxlID0ge307XG4gICAgICAvLyBhZGQgZGVmYXVsdCBzdHlsZXMgZmlyc3Q6XG4gICAgICAvLyBpZiBmb2N1c0Zyb21UYWIgcHJvcCBwcm92aWRlZCwgdGhlbiByZXNldCBicm93c2VyIGZvY3VzIHN0eWxlLFxuICAgICAgLy8gb3RoZXJ3aXNlIG9ubHkgcmVzZXQgaXQgd2hlbiBmb2N1cyBpcyBub3QgZnJvbSB0YWJcbiAgICAgIGlmICghdGhpcy5wLnByb3BzLnVzZUJyb3dzZXJPdXRsaW5lRm9jdXMgJiYgKHRoaXMucC5wcm9wcy5mb2N1c0Zyb21UYWIgfHwgdGhpcy5zdGF0ZS5mb2N1cyAhPT0gJ3RhYicgJiYgIV9jb25zdGFudHMubm9uQmx1cnJhYmxlVGFnc1t0aGlzLnRhZ05hbWVdKSkge1xuICAgICAgICBzdHlsZS5vdXRsaW5lID0gMDtcbiAgICAgICAgc3R5bGUub3V0bGluZU9mZnNldCA9IDA7XG4gICAgICB9XG4gICAgICAvLyBpZiB0b3VjaEFjdGl2ZSBvciBhY3RpdmUgcHJvcCBwcm92aWRlZCwgdGhlbiByZXNldCB3ZWJraXQgdGFwIGhpZ2hsaWdodCBzdHlsZVxuICAgICAgaWYgKCh0aGlzLnAucHJvcHMudG91Y2hBY3RpdmUgfHwgdGhpcy5wLnByb3BzLmFjdGl2ZSkgJiYgX2NvbnN0YW50cy5kZXZpY2VIYXNUb3VjaCkge1xuICAgICAgICBzdHlsZS5XZWJraXRUYXBIaWdobGlnaHRDb2xvciA9ICdyZ2JhKDAsIDAsIDAsIDApJztcbiAgICAgIH1cbiAgICAgIC8vIHNldCBjdXJzb3IgdG8gcG9pbnRlciBpZiBjbGlja2luZyBkb2VzIHNvbWV0aGluZ1xuICAgICAgdmFyIGxvd2VyQXMgPSB0eXBlb2YgdGhpcy5wLnByb3BzLmFzID09PSAnc3RyaW5nJyAmJiB0aGlzLnAucHJvcHMuYXMudG9Mb3dlckNhc2UoKTtcbiAgICAgIGlmICghdGhpcy5wLnByb3BzLnVzZUJyb3dzZXJDdXJzb3IgJiYgKHRoaXMucC5wcm9wcy5vbkNsaWNrIHx8IGxvd2VyQXMgIT09ICdpbnB1dCcgJiYgdGhpcy5wLnByb3BzLnRhYkluZGV4ICYmICh0aGlzLnAubW91c2VGb2N1c1N0eWxlLnN0eWxlIHx8IHRoaXMucC5tb3VzZUZvY3VzU3R5bGUuY2xhc3NOYW1lKSB8fCBsb3dlckFzID09PSAnaW5wdXQnICYmICh0aGlzLnAucHJvcHMudHlwZSA9PT0gJ2NoZWNrYm94JyB8fCB0aGlzLnAucHJvcHMudHlwZSA9PT0gJ3JhZGlvJyB8fCB0aGlzLnAucHJvcHMudHlwZSA9PT0gJ3N1Ym1pdCcpIHx8IGxvd2VyQXMgPT09ICdidXR0b24nIHx8IGxvd2VyQXMgPT09ICdhJyB8fCBsb3dlckFzID09PSAnYXJlYScgfHwgbG93ZXJBcyA9PT0gJ3NlbGVjdCcpICYmICF0aGlzLnAucHJvcHMuZGlzYWJsZWQpIHtcbiAgICAgICAgc3R5bGUuY3Vyc29yID0gJ3BvaW50ZXInO1xuICAgICAgfVxuXG4gICAgICAvLyBhZGQgc3R5bGUgcHJvcCBzdHlsZXMgc2Vjb25kOlxuICAgICAgKDAsIF9vYmplY3RBc3NpZ24yLmRlZmF1bHQpKHN0eWxlLCB0aGlzLnAucHJvcHMuc3R5bGUpO1xuXG4gICAgICAvLyBhZGQgaVN0YXRlIGFuZCBmb2N1cyBzdGF0ZSBzdHlsZXMgdGhpcmQ6XG4gICAgICAvLyBmb2N1cyBoYXMgcHJpb3JpdHkgb3ZlciBpU3RhdGUgc3R5bGVzIHVubGVzcyBvdmVycmlkZGVuIGluIHN0eWxlUHJpb3JpdHlcbiAgICAgIHZhciBoYXNQcmlvcml0eSA9IHRoaXMuc3RhdGUuaVN0YXRlID09PSAna2V5QWN0aXZlJyB8fCB0aGlzLnAucHJvcHMuc3R5bGVQcmlvcml0eSAmJiB0aGlzLnAucHJvcHMuc3R5bGVQcmlvcml0eVt0aGlzLnN0YXRlLmlTdGF0ZV07XG4gICAgICB2YXIgaVN0YXRlU3R5bGUgPSB0aGlzLnBbdGhpcy5zdGF0ZS5pU3RhdGUgKyAnU3R5bGUnXS5zdHlsZTtcbiAgICAgIHZhciBmb2N1c1N0eWxlID0gdGhpcy5zdGF0ZS5mb2N1cyA/IHRoaXMucFt0aGlzLnN0YXRlLmZvY3VzICsgJ0ZvY3VzU3R5bGUnXS5zdHlsZSA6IG51bGw7XG4gICAgICBpZiAoaGFzUHJpb3JpdHkpIHtcbiAgICAgICAgKDAsIF9vYmplY3RBc3NpZ24yLmRlZmF1bHQpKHN0eWxlLCBmb2N1c1N0eWxlLCBpU3RhdGVTdHlsZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAoMCwgX29iamVjdEFzc2lnbjIuZGVmYXVsdCkoc3R5bGUsIGlTdGF0ZVN0eWxlLCBmb2N1c1N0eWxlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdHlsZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjb21wdXRlQ2xhc3NOYW1lJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcHV0ZUNsYXNzTmFtZSgpIHtcbiAgICAgIC8vIGJ1aWxkIGNsYXNzTmFtZSBzdHJpbmcsIHVuaW9uIG9mIGNsYXNzIG5hbWVzIGZyb20gY2xhc3NOYW1lIHByb3AsIGlTdGF0ZSBjbGFzc05hbWUsXG4gICAgICAvLyBhbmQgZm9jdXMgY2xhc3NOYW1lIChpZiBpbiB0aGUgZm9jdXMgc3RhdGUpXG4gICAgICByZXR1cm4gKDAsIF9leHRyYWN0U3R5bGUuam9pbkNsYXNzZXMpKHRoaXMucC5wcm9wcy5jbGFzc05hbWUgfHwgJycsIHRoaXMucFt0aGlzLnN0YXRlLmlTdGF0ZSArICdTdHlsZSddLmNsYXNzTmFtZSwgdGhpcy5zdGF0ZS5mb2N1cyA/IHRoaXMucFt0aGlzLnN0YXRlLmZvY3VzICsgJ0ZvY3VzU3R5bGUnXS5jbGFzc05hbWUgOiAnJyk7XG4gICAgfVxuXG4gICAgLy8gY29tcHV0ZSBjaGlsZHJlbiB3aGVuIHRoZXJlIGlzIGFuIGludGVyYWN0aXZlQ2hpbGQgcHJvcCwgcmV0dXJucyB0aGUgbmV3IGNoaWxkcmVuXG5cbiAgfSwge1xuICAgIGtleTogJ2NvbXB1dGVDaGlsZHJlbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXB1dGVDaGlsZHJlbigpIHtcbiAgICAgIHZhciBfdGhpczkgPSB0aGlzO1xuXG4gICAgICAvLyBjb252ZXJ0IHRoaXMuc3RhdGUuZm9jdXMgdG8gdGhlIHN0cmluZyBmb2N1c0Zyb21bVHlwZV0gZm9yIHVzZSBsYXRlclxuICAgICAgdmFyIGZvY3VzRnJvbSA9IHRoaXMuc3RhdGUuZm9jdXMgJiYgJ2ZvY3VzRnJvbScgKyB0aGlzLnN0YXRlLmZvY3VzLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgdGhpcy5zdGF0ZS5mb2N1cy5zbGljZSgxKTtcbiAgICAgIC8vIGRvZXMgdGhlIGN1cnJlbnQgaVN0YXRlIHN0eWxlIGhhdmUgcHJpb3JpdHkgb3ZlciB0aGUgZm9jdXMgc3RhdGUgc3R5bGVcbiAgICAgIHZhciBpU3RhdGVTdHlsZVByaW9yaXR5ID0gdGhpcy5wLnByb3BzLnN0eWxlUHJpb3JpdHkgJiYgdGhpcy5wLnByb3BzLnN0eWxlUHJpb3JpdHlbdGhpcy5zdGF0ZS5pU3RhdGVdO1xuXG4gICAgICB2YXIgY29tcHV0ZUNoaWxkU3R5bGUgPSBmdW5jdGlvbiBjb21wdXRlQ2hpbGRTdHlsZShwcm9wcykge1xuICAgICAgICB2YXIgc3R5bGUgPSBwcm9wcy5zdHlsZSA/IF9leHRlbmRzKHt9LCBwcm9wcy5zdHlsZSkgOiB7fTtcbiAgICAgICAgKDAsIF9leHRyYWN0U3R5bGUuc2V0QWN0aXZlQW5kRm9jdXNQcm9wcykocHJvcHMpO1xuICAgICAgICB2YXIgaVN0YXRlU3R5bGUgPSAoMCwgX2V4dHJhY3RTdHlsZS5leHRyYWN0U3R5bGUpKHByb3BzLCBfdGhpczkuc3RhdGUuaVN0YXRlKTtcbiAgICAgICAgdmFyIGZvY3VzU3R5bGUgPSBfdGhpczkuc3RhdGUuZm9jdXMgJiYgKDAsIF9leHRyYWN0U3R5bGUuZXh0cmFjdFN0eWxlKShwcm9wcywgZm9jdXNGcm9tKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGNsYXNzTmFtZTogKDAsIF9leHRyYWN0U3R5bGUuam9pbkNsYXNzZXMpKHByb3BzLmNsYXNzTmFtZSB8fCAnJywgaVN0YXRlU3R5bGUuY2xhc3NOYW1lLCBmb2N1c1N0eWxlICYmIGZvY3VzU3R5bGUuY2xhc3NOYW1lIHx8ICcnKSxcbiAgICAgICAgICBzdHlsZTogaVN0YXRlU3R5bGVQcmlvcml0eSAmJiAoMCwgX29iamVjdEFzc2lnbjIuZGVmYXVsdCkoc3R5bGUsIGZvY3VzU3R5bGUuc3R5bGUsIGlTdGF0ZVN0eWxlLnN0eWxlKSB8fCAoMCwgX29iamVjdEFzc2lnbjIuZGVmYXVsdCkoc3R5bGUsIGlTdGF0ZVN0eWxlLnN0eWxlLCBmb2N1c1N0eWxlLnN0eWxlKVxuICAgICAgICB9O1xuICAgICAgfTtcblxuICAgICAgLy8gcmVjdXJzZSBhbmQgbWFwIGNoaWxkcmVuLCBpZiBjaGlsZCBpcyBhbiBJbnRlcmFjdGl2ZSBjb21wb25lbnQsIHRoZW4gZG9uJ3QgcmVjdXJzZSBpbnRvXG4gICAgICAvLyBpdCdzIGNoaWxkcmVuXG4gICAgICB2YXIgcmVjdXJzaXZlTWFwID0gZnVuY3Rpb24gcmVjdXJzaXZlTWFwKGNoaWxkcmVuKSB7XG4gICAgICAgIHJldHVybiBfcmVhY3QyLmRlZmF1bHQuQ2hpbGRyZW4ubWFwKGNoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICBpZiAoIV9yZWFjdDIuZGVmYXVsdC5pc1ZhbGlkRWxlbWVudChjaGlsZCkpIHJldHVybiBjaGlsZDtcblxuICAgICAgICAgIC8vIGlmIHRoZSBjaGlsZCBzaG91bGQgbm90IGJlIHNob3duLCB0aGVuIHJldHVybiBudWxsXG4gICAgICAgICAgaWYgKGNoaWxkLnByb3BzLnNob3dPblBhcmVudCkge1xuICAgICAgICAgICAgdmFyIHNob3dPbiA9IGNoaWxkLnByb3BzLnNob3dPblBhcmVudC5zcGxpdCgnICcpO1xuICAgICAgICAgICAgaWYgKCFzaG93T24uc29tZShmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGVsID09PSBfdGhpczkuc3RhdGUuaVN0YXRlIHx8IC9BY3RpdmUvLnRlc3QoX3RoaXM5LnN0YXRlLmlTdGF0ZSkgJiYgZWwgPT09ICdhY3RpdmUnIHx8IF90aGlzOS5zdGF0ZS5mb2N1cyAmJiAoZWwgPT09IGZvY3VzRnJvbSB8fCBlbCA9PT0gJ2ZvY3VzJyk7XG4gICAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgY2hpbGRQcm9wS2V5cyA9IE9iamVjdC5rZXlzKGNoaWxkLnByb3BzKTtcblxuICAgICAgICAgIC8vIGlmIHRoZSBjaGlsZCBkb2Vzbid0IGhhdmUgYW55IGludGVyYWN0aXZlIGNoaWxkIHByb3BzLCB0aGVuIHJldHVybiB0aGUgY2hpbGRcbiAgICAgICAgICBpZiAoIWNoaWxkUHJvcEtleXMuc29tZShmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnN0YW50cy5jaGlsZEludGVyYWN0aXZlUHJvcHNba2V5XTtcbiAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgaWYgKGNoaWxkLnR5cGUgPT09IEludGVyYWN0aXZlKSByZXR1cm4gY2hpbGQ7XG4gICAgICAgICAgICAvLyBpZiB0aGUgY2hpbGQgaXMgbm90IGFuIEludGVyYWN0aXZlIGNvbXBvbmVudCwgdGhlbiBzdGlsbCByZWN1c2UgaW50byBpdHMgY2hpbGRyZW5cbiAgICAgICAgICAgIHJldHVybiBfcmVhY3QyLmRlZmF1bHQuY2xvbmVFbGVtZW50KGNoaWxkLCB7fSwgcmVjdXJzaXZlTWFwKGNoaWxkLnByb3BzLmNoaWxkcmVuKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIG5ld0NoaWxkUHJvcHMgPSB7fTtcbiAgICAgICAgICB2YXIgY2hpbGRTdHlsZVByb3BzID0ge307XG4gICAgICAgICAgLy8gc2VwYXJhdGUgY2hpbGQgcHJvcHMgdG8gcGFzcyB0aHJvdWdoIChuZXdDaGlsZFByb3BzKSwgZnJvbSBwcm9wcyB1c2VkXG4gICAgICAgICAgLy8gdG8gY29tcHV0ZSB0aGUgY2hpbGQncyBzdHlsZSAoY2hpbGRTdHlsZVByb3BzKVxuICAgICAgICAgIGNoaWxkUHJvcEtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICBpZiAoIV9jb25zdGFudHMuY2hpbGRJbnRlcmFjdGl2ZVByb3BzW2tleV0pIG5ld0NoaWxkUHJvcHNba2V5XSA9IGNoaWxkLnByb3BzW2tleV07ZWxzZSBpZiAoa2V5ICE9PSAnc2hvd09uUGFyZW50Jykge1xuICAgICAgICAgICAgICBjaGlsZFN0eWxlUHJvcHNbJycgKyBrZXkuc2xpY2UoOCkuY2hhckF0KDApLnRvTG93ZXJDYXNlKCkgKyBrZXkuc2xpY2UoOSldID0gY2hpbGQucHJvcHNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGNoaWxkU3R5bGVQcm9wcy5zdHlsZSA9IGNoaWxkLnByb3BzLnN0eWxlO1xuICAgICAgICAgIGNoaWxkU3R5bGVQcm9wcy5jbGFzc05hbWUgPSBjaGlsZC5wcm9wcy5jbGFzc05hbWU7XG5cbiAgICAgICAgICB2YXIgX2NvbXB1dGVDaGlsZFN0eWxlID0gY29tcHV0ZUNoaWxkU3R5bGUoY2hpbGRTdHlsZVByb3BzKSxcbiAgICAgICAgICAgICAgc3R5bGUgPSBfY29tcHV0ZUNoaWxkU3R5bGUuc3R5bGUsXG4gICAgICAgICAgICAgIGNsYXNzTmFtZSA9IF9jb21wdXRlQ2hpbGRTdHlsZS5jbGFzc05hbWU7XG5cbiAgICAgICAgICBuZXdDaGlsZFByb3BzLnN0eWxlID0gc3R5bGU7XG4gICAgICAgICAgaWYgKGNsYXNzTmFtZSkgbmV3Q2hpbGRQcm9wcy5jbGFzc05hbWUgPSBjbGFzc05hbWU7XG5cbiAgICAgICAgICAvLyBjYW4ndCB1c2UgY2xvbmVFbGVtZW50IGJlY2F1c2Ugbm90IHBvc3NpYmxlIHRvIGRlbGV0ZSBleGlzdGluZyBjaGlsZCBwcm9wLFxuICAgICAgICAgIC8vIGUuZy4gbmVlZCB0byBkZWxldGUgdGhlIHByb3Agb25QYXJlbnRIb3ZlciBmcm9tIHRoZSBjaGlsZFxuICAgICAgICAgIHJldHVybiBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlRWxlbWVudChjaGlsZC50eXBlLCBuZXdDaGlsZFByb3BzLCBjaGlsZC50eXBlID09PSBJbnRlcmFjdGl2ZSA/IGNoaWxkLnByb3BzLmNoaWxkcmVuIDogcmVjdXJzaXZlTWFwKGNoaWxkLnByb3BzLmNoaWxkcmVuKSk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIHJlY3Vyc2l2ZU1hcCh0aGlzLnAucHJvcHMuY2hpbGRyZW4pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3JlbmRlcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIC8vIHByb3BzIHRvIHBhc3MgZG93bjpcbiAgICAgIC8vIHBhc3NUaHJvdWdoUHJvcHMgKGluY2x1ZGVzIGV2ZW50IGhhbmRsZXJzKVxuICAgICAgLy8gc3R5bGVcbiAgICAgIC8vIGNsYXNzTmFtZVxuICAgICAgdGhpcy5wLnBhc3NUaHJvdWdoUHJvcHMuc3R5bGUgPSB0aGlzLmNvbXB1dGVTdHlsZSgpO1xuICAgICAgdmFyIGNsYXNzTmFtZSA9IHRoaXMuY29tcHV0ZUNsYXNzTmFtZSgpO1xuICAgICAgaWYgKGNsYXNzTmFtZSkgdGhpcy5wLnBhc3NUaHJvdWdoUHJvcHMuY2xhc3NOYW1lID0gY2xhc3NOYW1lO1xuXG4gICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLnAucHJvcHMuaW50ZXJhY3RpdmVDaGlsZCA/IHRoaXMuY29tcHV0ZUNoaWxkcmVuKCkgOiB0aGlzLnAucHJvcHMuY2hpbGRyZW47XG5cbiAgICAgIC8vIGlmIGBhc2AgaXMgYSBzdHJpbmcgKGkuZS4gRE9NIHRhZyBuYW1lKSwgdGhlbiBhZGQgdGhlIHJlZiB0byBwcm9wcyBhbmQgcmVuZGVyIGBhc2BcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5wLnByb3BzLmFzID09PSAnc3RyaW5nJykge1xuICAgICAgICB0aGlzLnAucGFzc1Rocm91Z2hQcm9wcy5yZWYgPSB0aGlzLnJlZkNhbGxiYWNrO1xuICAgICAgICByZXR1cm4gX3JlYWN0Mi5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQodGhpcy5wLnByb3BzLmFzLCB0aGlzLnAucGFzc1Rocm91Z2hQcm9wcywgY2hpbGRyZW4pO1xuICAgICAgfVxuICAgICAgLy8gSWYgYGFzYCBpcyBhIFJlYWN0Q2xhc3Mgb3IgYSBSZWFjdEZ1bmN0aW9uYWxDb21wb25lbnQsIHRoZW4gd3JhcCBpdCBpbiBhIHNwYW5cbiAgICAgIC8vIHNvIGNhbiBhY2Nlc3MgdGhlIERPTSBub2RlIHdpdGhvdXQgYnJlYWtpbmcgZW5jYXBzdWxhdGlvblxuICAgICAgcmV0dXJuIF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVFbGVtZW50KCdzcGFuJywge1xuICAgICAgICByZWY6IHRoaXMucmVmQ2FsbGJhY2ssXG4gICAgICAgIHN0eWxlOiB0aGlzLnAucHJvcHMud3JhcHBlclN0eWxlLFxuICAgICAgICBjbGFzc05hbWU6IHRoaXMucC5wcm9wcy53cmFwcGVyQ2xhc3NOYW1lXG4gICAgICB9LCBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlRWxlbWVudCh0aGlzLnAucHJvcHMuYXMsIHRoaXMucC5wYXNzVGhyb3VnaFByb3BzLCBjaGlsZHJlbikpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBJbnRlcmFjdGl2ZTtcbn0oX3JlYWN0Mi5kZWZhdWx0LkNvbXBvbmVudCk7XG5cbkludGVyYWN0aXZlLnByb3BUeXBlcyA9IF9wcm9wVHlwZXMucHJvcFR5cGVzO1xuSW50ZXJhY3RpdmUuZGVmYXVsdFByb3BzID0gX3Byb3BUeXBlcy5kZWZhdWx0UHJvcHM7XG5leHBvcnRzLmRlZmF1bHQgPSBJbnRlcmFjdGl2ZTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LWludGVyYWN0aXZlL2xpYi9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNDE0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAyIDQgNSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///414\n");

/***/ }),

/***/ 415:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.defaultProps = exports.propTypes = undefined;\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _propTypes = __webpack_require__(24);\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nvar _constants = __webpack_require__(367);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction statePropsExcept(state) {\n  var statePropsCopy = _extends({}, _constants.stateProps);\n  delete statePropsCopy[state];\n  return Object.keys(statePropsCopy);\n}\n\nvar iStatesShape = {};\nObject.keys(_constants.iStates).forEach(function (iState) {\n  iStatesShape[iState] = _propTypes2.default.bool;\n});\n\nvar propTypes = {\n  as: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.func, _propTypes2.default.element]).isRequired,\n  children: _propTypes2.default.node,\n  normal: _propTypes2.default.oneOfType([_propTypes2.default.object, _propTypes2.default.oneOf(statePropsExcept('normal'))]),\n  hover: _propTypes2.default.oneOfType([_propTypes2.default.object, _propTypes2.default.oneOf(statePropsExcept('hover'))]),\n  active: _propTypes2.default.oneOfType([_propTypes2.default.object, _propTypes2.default.oneOf(statePropsExcept('active'))]),\n  hoverActive: _propTypes2.default.oneOfType([_propTypes2.default.object, _propTypes2.default.oneOf(statePropsExcept('hoverActive'))]),\n  touchActive: _propTypes2.default.oneOfType([_propTypes2.default.object, _propTypes2.default.oneOf(statePropsExcept('touchActive'))]),\n  keyActive: _propTypes2.default.oneOfType([_propTypes2.default.object, _propTypes2.default.oneOf(statePropsExcept('keyActive'))]),\n  focus: _propTypes2.default.oneOfType([_propTypes2.default.object, _propTypes2.default.oneOf(statePropsExcept('focus'))]),\n  focusFromTab: _propTypes2.default.oneOfType([_propTypes2.default.object, _propTypes2.default.oneOf(statePropsExcept('focusFromTab'))]),\n  focusFromTouch: _propTypes2.default.oneOfType([_propTypes2.default.object, _propTypes2.default.oneOf(statePropsExcept('focusFromTouch'))]),\n  focusFromMouse: _propTypes2.default.oneOfType([_propTypes2.default.object, _propTypes2.default.oneOf(statePropsExcept('focusFromMouse'))]),\n  forceState: _propTypes2.default.shape({\n    iState: _propTypes2.default.oneOf(Object.keys(_constants.iStates)),\n    focus: _propTypes2.default.oneOf([false, 'tab', 'mouse', 'touch'])\n  }),\n  initialState: _propTypes2.default.shape({\n    iState: _propTypes2.default.oneOf(Object.keys(_constants.iStates)),\n    focus: _propTypes2.default.oneOf([false, 'tab', 'mouse', 'touch'])\n  }),\n  style: _propTypes2.default.object,\n  className: _propTypes2.default.string,\n  wrapperStyle: _propTypes2.default.object,\n  wrapperClassName: _propTypes2.default.string,\n  onStateChange: _propTypes2.default.func,\n  setStateCallback: _propTypes2.default.func,\n  onClick: _propTypes2.default.func,\n  onTapTwo: _propTypes2.default.func,\n  onTapThree: _propTypes2.default.func,\n  onTapFour: _propTypes2.default.func,\n  tapTimeCutoff: _propTypes2.default.number,\n\n  onMouseEnter: _propTypes2.default.func,\n  onMouseLeave: _propTypes2.default.func,\n  onMouseMove: _propTypes2.default.func,\n  onMouseDown: _propTypes2.default.func,\n  onMouseUp: _propTypes2.default.func,\n  onTouchStart: _propTypes2.default.func,\n  onTouchMove: _propTypes2.default.func,\n  onTouchEnd: _propTypes2.default.func,\n  onTouchCancel: _propTypes2.default.func,\n  onFocus: _propTypes2.default.func,\n  onBlur: _propTypes2.default.func,\n  onKeyDown: _propTypes2.default.func,\n  onKeyUp: _propTypes2.default.func,\n\n  mutableProps: _propTypes2.default.bool,\n  refDOMNode: _propTypes2.default.func,\n  tabIndex: _propTypes2.default.string,\n  useBrowserOutlineFocus: _propTypes2.default.bool,\n  useBrowserCursor: _propTypes2.default.bool,\n  touchActiveTapOnly: _propTypes2.default.bool,\n  extraTouchNoTap: _propTypes2.default.bool,\n  focusToggleOff: _propTypes2.default.bool,\n  stylePriority: _propTypes2.default.shape(iStatesShape),\n  nonContainedChild: _propTypes2.default.bool,\n  interactiveChild: _propTypes2.default.bool\n};\n\nvar defaultProps = {\n  tapTimeCutoff: _constants.defaultTapTimeCutoff\n};\n\nexports.propTypes = propTypes;\nexports.defaultProps = defaultProps;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDE1LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWludGVyYWN0aXZlL2xpYi9wcm9wVHlwZXMuanM/NmEwZCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHRQcm9wcyA9IGV4cG9ydHMucHJvcFR5cGVzID0gdW5kZWZpbmVkO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG52YXIgX3Byb3BUeXBlcyA9IHJlcXVpcmUoJ3Byb3AtdHlwZXMnKTtcblxudmFyIF9wcm9wVHlwZXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcHJvcFR5cGVzKTtcblxudmFyIF9jb25zdGFudHMgPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBzdGF0ZVByb3BzRXhjZXB0KHN0YXRlKSB7XG4gIHZhciBzdGF0ZVByb3BzQ29weSA9IF9leHRlbmRzKHt9LCBfY29uc3RhbnRzLnN0YXRlUHJvcHMpO1xuICBkZWxldGUgc3RhdGVQcm9wc0NvcHlbc3RhdGVdO1xuICByZXR1cm4gT2JqZWN0LmtleXMoc3RhdGVQcm9wc0NvcHkpO1xufVxuXG52YXIgaVN0YXRlc1NoYXBlID0ge307XG5PYmplY3Qua2V5cyhfY29uc3RhbnRzLmlTdGF0ZXMpLmZvckVhY2goZnVuY3Rpb24gKGlTdGF0ZSkge1xuICBpU3RhdGVzU2hhcGVbaVN0YXRlXSA9IF9wcm9wVHlwZXMyLmRlZmF1bHQuYm9vbDtcbn0pO1xuXG52YXIgcHJvcFR5cGVzID0ge1xuICBhczogX3Byb3BUeXBlczIuZGVmYXVsdC5vbmVPZlR5cGUoW19wcm9wVHlwZXMyLmRlZmF1bHQuc3RyaW5nLCBfcHJvcFR5cGVzMi5kZWZhdWx0LmZ1bmMsIF9wcm9wVHlwZXMyLmRlZmF1bHQuZWxlbWVudF0pLmlzUmVxdWlyZWQsXG4gIGNoaWxkcmVuOiBfcHJvcFR5cGVzMi5kZWZhdWx0Lm5vZGUsXG4gIG5vcm1hbDogX3Byb3BUeXBlczIuZGVmYXVsdC5vbmVPZlR5cGUoW19wcm9wVHlwZXMyLmRlZmF1bHQub2JqZWN0LCBfcHJvcFR5cGVzMi5kZWZhdWx0Lm9uZU9mKHN0YXRlUHJvcHNFeGNlcHQoJ25vcm1hbCcpKV0pLFxuICBob3ZlcjogX3Byb3BUeXBlczIuZGVmYXVsdC5vbmVPZlR5cGUoW19wcm9wVHlwZXMyLmRlZmF1bHQub2JqZWN0LCBfcHJvcFR5cGVzMi5kZWZhdWx0Lm9uZU9mKHN0YXRlUHJvcHNFeGNlcHQoJ2hvdmVyJykpXSksXG4gIGFjdGl2ZTogX3Byb3BUeXBlczIuZGVmYXVsdC5vbmVPZlR5cGUoW19wcm9wVHlwZXMyLmRlZmF1bHQub2JqZWN0LCBfcHJvcFR5cGVzMi5kZWZhdWx0Lm9uZU9mKHN0YXRlUHJvcHNFeGNlcHQoJ2FjdGl2ZScpKV0pLFxuICBob3ZlckFjdGl2ZTogX3Byb3BUeXBlczIuZGVmYXVsdC5vbmVPZlR5cGUoW19wcm9wVHlwZXMyLmRlZmF1bHQub2JqZWN0LCBfcHJvcFR5cGVzMi5kZWZhdWx0Lm9uZU9mKHN0YXRlUHJvcHNFeGNlcHQoJ2hvdmVyQWN0aXZlJykpXSksXG4gIHRvdWNoQWN0aXZlOiBfcHJvcFR5cGVzMi5kZWZhdWx0Lm9uZU9mVHlwZShbX3Byb3BUeXBlczIuZGVmYXVsdC5vYmplY3QsIF9wcm9wVHlwZXMyLmRlZmF1bHQub25lT2Yoc3RhdGVQcm9wc0V4Y2VwdCgndG91Y2hBY3RpdmUnKSldKSxcbiAga2V5QWN0aXZlOiBfcHJvcFR5cGVzMi5kZWZhdWx0Lm9uZU9mVHlwZShbX3Byb3BUeXBlczIuZGVmYXVsdC5vYmplY3QsIF9wcm9wVHlwZXMyLmRlZmF1bHQub25lT2Yoc3RhdGVQcm9wc0V4Y2VwdCgna2V5QWN0aXZlJykpXSksXG4gIGZvY3VzOiBfcHJvcFR5cGVzMi5kZWZhdWx0Lm9uZU9mVHlwZShbX3Byb3BUeXBlczIuZGVmYXVsdC5vYmplY3QsIF9wcm9wVHlwZXMyLmRlZmF1bHQub25lT2Yoc3RhdGVQcm9wc0V4Y2VwdCgnZm9jdXMnKSldKSxcbiAgZm9jdXNGcm9tVGFiOiBfcHJvcFR5cGVzMi5kZWZhdWx0Lm9uZU9mVHlwZShbX3Byb3BUeXBlczIuZGVmYXVsdC5vYmplY3QsIF9wcm9wVHlwZXMyLmRlZmF1bHQub25lT2Yoc3RhdGVQcm9wc0V4Y2VwdCgnZm9jdXNGcm9tVGFiJykpXSksXG4gIGZvY3VzRnJvbVRvdWNoOiBfcHJvcFR5cGVzMi5kZWZhdWx0Lm9uZU9mVHlwZShbX3Byb3BUeXBlczIuZGVmYXVsdC5vYmplY3QsIF9wcm9wVHlwZXMyLmRlZmF1bHQub25lT2Yoc3RhdGVQcm9wc0V4Y2VwdCgnZm9jdXNGcm9tVG91Y2gnKSldKSxcbiAgZm9jdXNGcm9tTW91c2U6IF9wcm9wVHlwZXMyLmRlZmF1bHQub25lT2ZUeXBlKFtfcHJvcFR5cGVzMi5kZWZhdWx0Lm9iamVjdCwgX3Byb3BUeXBlczIuZGVmYXVsdC5vbmVPZihzdGF0ZVByb3BzRXhjZXB0KCdmb2N1c0Zyb21Nb3VzZScpKV0pLFxuICBmb3JjZVN0YXRlOiBfcHJvcFR5cGVzMi5kZWZhdWx0LnNoYXBlKHtcbiAgICBpU3RhdGU6IF9wcm9wVHlwZXMyLmRlZmF1bHQub25lT2YoT2JqZWN0LmtleXMoX2NvbnN0YW50cy5pU3RhdGVzKSksXG4gICAgZm9jdXM6IF9wcm9wVHlwZXMyLmRlZmF1bHQub25lT2YoW2ZhbHNlLCAndGFiJywgJ21vdXNlJywgJ3RvdWNoJ10pXG4gIH0pLFxuICBpbml0aWFsU3RhdGU6IF9wcm9wVHlwZXMyLmRlZmF1bHQuc2hhcGUoe1xuICAgIGlTdGF0ZTogX3Byb3BUeXBlczIuZGVmYXVsdC5vbmVPZihPYmplY3Qua2V5cyhfY29uc3RhbnRzLmlTdGF0ZXMpKSxcbiAgICBmb2N1czogX3Byb3BUeXBlczIuZGVmYXVsdC5vbmVPZihbZmFsc2UsICd0YWInLCAnbW91c2UnLCAndG91Y2gnXSlcbiAgfSksXG4gIHN0eWxlOiBfcHJvcFR5cGVzMi5kZWZhdWx0Lm9iamVjdCxcbiAgY2xhc3NOYW1lOiBfcHJvcFR5cGVzMi5kZWZhdWx0LnN0cmluZyxcbiAgd3JhcHBlclN0eWxlOiBfcHJvcFR5cGVzMi5kZWZhdWx0Lm9iamVjdCxcbiAgd3JhcHBlckNsYXNzTmFtZTogX3Byb3BUeXBlczIuZGVmYXVsdC5zdHJpbmcsXG4gIG9uU3RhdGVDaGFuZ2U6IF9wcm9wVHlwZXMyLmRlZmF1bHQuZnVuYyxcbiAgc2V0U3RhdGVDYWxsYmFjazogX3Byb3BUeXBlczIuZGVmYXVsdC5mdW5jLFxuICBvbkNsaWNrOiBfcHJvcFR5cGVzMi5kZWZhdWx0LmZ1bmMsXG4gIG9uVGFwVHdvOiBfcHJvcFR5cGVzMi5kZWZhdWx0LmZ1bmMsXG4gIG9uVGFwVGhyZWU6IF9wcm9wVHlwZXMyLmRlZmF1bHQuZnVuYyxcbiAgb25UYXBGb3VyOiBfcHJvcFR5cGVzMi5kZWZhdWx0LmZ1bmMsXG4gIHRhcFRpbWVDdXRvZmY6IF9wcm9wVHlwZXMyLmRlZmF1bHQubnVtYmVyLFxuXG4gIG9uTW91c2VFbnRlcjogX3Byb3BUeXBlczIuZGVmYXVsdC5mdW5jLFxuICBvbk1vdXNlTGVhdmU6IF9wcm9wVHlwZXMyLmRlZmF1bHQuZnVuYyxcbiAgb25Nb3VzZU1vdmU6IF9wcm9wVHlwZXMyLmRlZmF1bHQuZnVuYyxcbiAgb25Nb3VzZURvd246IF9wcm9wVHlwZXMyLmRlZmF1bHQuZnVuYyxcbiAgb25Nb3VzZVVwOiBfcHJvcFR5cGVzMi5kZWZhdWx0LmZ1bmMsXG4gIG9uVG91Y2hTdGFydDogX3Byb3BUeXBlczIuZGVmYXVsdC5mdW5jLFxuICBvblRvdWNoTW92ZTogX3Byb3BUeXBlczIuZGVmYXVsdC5mdW5jLFxuICBvblRvdWNoRW5kOiBfcHJvcFR5cGVzMi5kZWZhdWx0LmZ1bmMsXG4gIG9uVG91Y2hDYW5jZWw6IF9wcm9wVHlwZXMyLmRlZmF1bHQuZnVuYyxcbiAgb25Gb2N1czogX3Byb3BUeXBlczIuZGVmYXVsdC5mdW5jLFxuICBvbkJsdXI6IF9wcm9wVHlwZXMyLmRlZmF1bHQuZnVuYyxcbiAgb25LZXlEb3duOiBfcHJvcFR5cGVzMi5kZWZhdWx0LmZ1bmMsXG4gIG9uS2V5VXA6IF9wcm9wVHlwZXMyLmRlZmF1bHQuZnVuYyxcblxuICBtdXRhYmxlUHJvcHM6IF9wcm9wVHlwZXMyLmRlZmF1bHQuYm9vbCxcbiAgcmVmRE9NTm9kZTogX3Byb3BUeXBlczIuZGVmYXVsdC5mdW5jLFxuICB0YWJJbmRleDogX3Byb3BUeXBlczIuZGVmYXVsdC5zdHJpbmcsXG4gIHVzZUJyb3dzZXJPdXRsaW5lRm9jdXM6IF9wcm9wVHlwZXMyLmRlZmF1bHQuYm9vbCxcbiAgdXNlQnJvd3NlckN1cnNvcjogX3Byb3BUeXBlczIuZGVmYXVsdC5ib29sLFxuICB0b3VjaEFjdGl2ZVRhcE9ubHk6IF9wcm9wVHlwZXMyLmRlZmF1bHQuYm9vbCxcbiAgZXh0cmFUb3VjaE5vVGFwOiBfcHJvcFR5cGVzMi5kZWZhdWx0LmJvb2wsXG4gIGZvY3VzVG9nZ2xlT2ZmOiBfcHJvcFR5cGVzMi5kZWZhdWx0LmJvb2wsXG4gIHN0eWxlUHJpb3JpdHk6IF9wcm9wVHlwZXMyLmRlZmF1bHQuc2hhcGUoaVN0YXRlc1NoYXBlKSxcbiAgbm9uQ29udGFpbmVkQ2hpbGQ6IF9wcm9wVHlwZXMyLmRlZmF1bHQuYm9vbCxcbiAgaW50ZXJhY3RpdmVDaGlsZDogX3Byb3BUeXBlczIuZGVmYXVsdC5ib29sXG59O1xuXG52YXIgZGVmYXVsdFByb3BzID0ge1xuICB0YXBUaW1lQ3V0b2ZmOiBfY29uc3RhbnRzLmRlZmF1bHRUYXBUaW1lQ3V0b2ZmXG59O1xuXG5leHBvcnRzLnByb3BUeXBlcyA9IHByb3BUeXBlcztcbmV4cG9ydHMuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LWludGVyYWN0aXZlL2xpYi9wcm9wVHlwZXMuanNcbi8vIG1vZHVsZSBpZCA9IDQxNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMiA0IDUiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///415\n");

/***/ }),

/***/ 416:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _detectHover = __webpack_require__(417);\n\nvar _detectHover2 = _interopRequireDefault(_detectHover);\n\nvar _detectPointer = __webpack_require__(418);\n\nvar _detectPointer2 = _interopRequireDefault(_detectPointer);\n\nvar _detectTouchEvents = __webpack_require__(419);\n\nvar _detectTouchEvents2 = _interopRequireDefault(_detectTouchEvents);\n\nvar _detectPassiveEvents = __webpack_require__(420);\n\nvar _detectPassiveEvents2 = _interopRequireDefault(_detectPassiveEvents);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/*\n * detectIt object structure\n * const detectIt = {\n *   deviceType: 'mouseOnly' / 'touchOnly' / 'hybrid',\n *   passiveEvents: boolean,\n *   hasTouch: boolean,\n *   hasMouse: boolean,\n *   maxTouchPoints: number,\n *   primaryHover: 'hover' / 'none',\n *   primaryPointer: 'fine' / 'coarse' / 'none',\n *   state: {\n *     detectHover,\n *     detectPointer,\n *     detectTouchEvents,\n *     detectPassiveEvents,\n *   },\n *   update() {...},\n * }\n */\n\nfunction determineDeviceType(hasTouch, anyHover, anyFine, state) {\n  // A hybrid device is one that both hasTouch and any input device can hover\n  // or has a fine pointer.\n  if (hasTouch && (anyHover || anyFine)) return 'hybrid';\n\n  // workaround for browsers that have the touch events api,\n  // and have implemented Level 4 media queries but not the\n  // hover and pointer media queries, so the tests are all false (notable Firefox)\n  // if it hasTouch, no pointer and hover support, and on an android assume it's touchOnly\n  // if it hasTouch, no pointer and hover support, and not on an android assume it's a hybrid\n  if (hasTouch && Object.keys(state.detectHover).filter(function (key) {\n    return key !== 'update';\n  }).every(function (key) {\n    return state.detectHover[key] === false;\n  }) && Object.keys(state.detectPointer).filter(function (key) {\n    return key !== 'update';\n  }).every(function (key) {\n    return state.detectPointer[key] === false;\n  })) {\n    if (window.navigator && /android/.test(window.navigator.userAgent.toLowerCase())) {\n      return 'touchOnly';\n    }\n    return 'hybrid';\n  }\n\n  // In almost all cases a device that doesnt support touch will have a mouse,\n  // but there may be rare exceptions. Note that it doesnt work to do additional tests\n  // based on hover and pointer media queries as older browsers dont support these.\n  // Essentially, 'mouseOnly' is the default.\n  return hasTouch ? 'touchOnly' : 'mouseOnly';\n}\n\nvar detectIt = {\n  state: {\n    detectHover: _detectHover2.default,\n    detectPointer: _detectPointer2.default,\n    detectTouchEvents: _detectTouchEvents2.default,\n    detectPassiveEvents: _detectPassiveEvents2.default\n  },\n  update: function update() {\n    detectIt.state.detectHover.update();\n    detectIt.state.detectPointer.update();\n    detectIt.state.detectTouchEvents.update();\n    detectIt.state.detectPassiveEvents.update();\n    detectIt.updateOnlyOwnProperties();\n  },\n  updateOnlyOwnProperties: function updateOnlyOwnProperties() {\n    if (typeof window !== 'undefined') {\n      detectIt.passiveEvents = detectIt.state.detectPassiveEvents.hasSupport || false;\n\n      detectIt.hasTouch = detectIt.state.detectTouchEvents.hasSupport || false;\n\n      detectIt.deviceType = determineDeviceType(detectIt.hasTouch, detectIt.state.detectHover.anyHover, detectIt.state.detectPointer.anyFine, detectIt.state);\n\n      detectIt.hasMouse = detectIt.deviceType !== 'touchOnly';\n\n      detectIt.primaryInput = detectIt.deviceType === 'mouseOnly' && 'mouse' || detectIt.deviceType === 'touchOnly' && 'touch' ||\n      // deviceType is hybrid:\n      detectIt.state.detectHover.hover && 'mouse' || detectIt.state.detectHover.none && 'touch' ||\n      // if there's no support for hover media queries but detectIt determined it's\n      // a hybrid  device, then assume it's a mouse first device\n      'mouse';\n\n      // issue with Windows Chrome on hybrid devices starting in version 59 where\n      // media queries represent a touch only device, so if the browser is an\n      // affected Windows Chrome version and hasTouch,\n      // then assume it's a hybrid with primaryInput mouse\n      // note that version 62 of Chrome fixes this issue\n      // see https://github.com/rafrex/detect-it/issues/8\n      var inVersionRange = function inVersionRange(version) {\n        return version >= 59 && version < 62;\n      };\n      var isAffectedWindowsChromeVersion = /windows/.test(window.navigator.userAgent.toLowerCase()) && /chrome/.test(window.navigator.userAgent.toLowerCase()) && inVersionRange(parseInt(/Chrome\\/([0-9.]+)/.exec(navigator.userAgent)[1], 10));\n\n      if (isAffectedWindowsChromeVersion && detectIt.hasTouch) {\n        detectIt.deviceType = 'hybrid';\n        detectIt.hasMouse = true;\n        detectIt.primaryInput = 'mouse';\n      }\n    }\n  }\n};\n\ndetectIt.updateOnlyOwnProperties();\nexports.default = detectIt;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDE2LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RldGVjdC1pdC9saWIvaW5kZXguanM/YjVkNSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfZGV0ZWN0SG92ZXIgPSByZXF1aXJlKCdkZXRlY3QtaG92ZXInKTtcblxudmFyIF9kZXRlY3RIb3ZlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kZXRlY3RIb3Zlcik7XG5cbnZhciBfZGV0ZWN0UG9pbnRlciA9IHJlcXVpcmUoJ2RldGVjdC1wb2ludGVyJyk7XG5cbnZhciBfZGV0ZWN0UG9pbnRlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kZXRlY3RQb2ludGVyKTtcblxudmFyIF9kZXRlY3RUb3VjaEV2ZW50cyA9IHJlcXVpcmUoJ2RldGVjdC10b3VjaC1ldmVudHMnKTtcblxudmFyIF9kZXRlY3RUb3VjaEV2ZW50czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kZXRlY3RUb3VjaEV2ZW50cyk7XG5cbnZhciBfZGV0ZWN0UGFzc2l2ZUV2ZW50cyA9IHJlcXVpcmUoJ2RldGVjdC1wYXNzaXZlLWV2ZW50cycpO1xuXG52YXIgX2RldGVjdFBhc3NpdmVFdmVudHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGV0ZWN0UGFzc2l2ZUV2ZW50cyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8qXG4gKiBkZXRlY3RJdCBvYmplY3Qgc3RydWN0dXJlXG4gKiBjb25zdCBkZXRlY3RJdCA9IHtcbiAqICAgZGV2aWNlVHlwZTogJ21vdXNlT25seScgLyAndG91Y2hPbmx5JyAvICdoeWJyaWQnLFxuICogICBwYXNzaXZlRXZlbnRzOiBib29sZWFuLFxuICogICBoYXNUb3VjaDogYm9vbGVhbixcbiAqICAgaGFzTW91c2U6IGJvb2xlYW4sXG4gKiAgIG1heFRvdWNoUG9pbnRzOiBudW1iZXIsXG4gKiAgIHByaW1hcnlIb3ZlcjogJ2hvdmVyJyAvICdub25lJyxcbiAqICAgcHJpbWFyeVBvaW50ZXI6ICdmaW5lJyAvICdjb2Fyc2UnIC8gJ25vbmUnLFxuICogICBzdGF0ZToge1xuICogICAgIGRldGVjdEhvdmVyLFxuICogICAgIGRldGVjdFBvaW50ZXIsXG4gKiAgICAgZGV0ZWN0VG91Y2hFdmVudHMsXG4gKiAgICAgZGV0ZWN0UGFzc2l2ZUV2ZW50cyxcbiAqICAgfSxcbiAqICAgdXBkYXRlKCkgey4uLn0sXG4gKiB9XG4gKi9cblxuZnVuY3Rpb24gZGV0ZXJtaW5lRGV2aWNlVHlwZShoYXNUb3VjaCwgYW55SG92ZXIsIGFueUZpbmUsIHN0YXRlKSB7XG4gIC8vIEEgaHlicmlkIGRldmljZSBpcyBvbmUgdGhhdCBib3RoIGhhc1RvdWNoIGFuZCBhbnkgaW5wdXQgZGV2aWNlIGNhbiBob3ZlclxuICAvLyBvciBoYXMgYSBmaW5lIHBvaW50ZXIuXG4gIGlmIChoYXNUb3VjaCAmJiAoYW55SG92ZXIgfHwgYW55RmluZSkpIHJldHVybiAnaHlicmlkJztcblxuICAvLyB3b3JrYXJvdW5kIGZvciBicm93c2VycyB0aGF0IGhhdmUgdGhlIHRvdWNoIGV2ZW50cyBhcGksXG4gIC8vIGFuZCBoYXZlIGltcGxlbWVudGVkIExldmVsIDQgbWVkaWEgcXVlcmllcyBidXQgbm90IHRoZVxuICAvLyBob3ZlciBhbmQgcG9pbnRlciBtZWRpYSBxdWVyaWVzLCBzbyB0aGUgdGVzdHMgYXJlIGFsbCBmYWxzZSAobm90YWJsZSBGaXJlZm94KVxuICAvLyBpZiBpdCBoYXNUb3VjaCwgbm8gcG9pbnRlciBhbmQgaG92ZXIgc3VwcG9ydCwgYW5kIG9uIGFuIGFuZHJvaWQgYXNzdW1lIGl0J3MgdG91Y2hPbmx5XG4gIC8vIGlmIGl0IGhhc1RvdWNoLCBubyBwb2ludGVyIGFuZCBob3ZlciBzdXBwb3J0LCBhbmQgbm90IG9uIGFuIGFuZHJvaWQgYXNzdW1lIGl0J3MgYSBoeWJyaWRcbiAgaWYgKGhhc1RvdWNoICYmIE9iamVjdC5rZXlzKHN0YXRlLmRldGVjdEhvdmVyKS5maWx0ZXIoZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiBrZXkgIT09ICd1cGRhdGUnO1xuICB9KS5ldmVyeShmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIHN0YXRlLmRldGVjdEhvdmVyW2tleV0gPT09IGZhbHNlO1xuICB9KSAmJiBPYmplY3Qua2V5cyhzdGF0ZS5kZXRlY3RQb2ludGVyKS5maWx0ZXIoZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiBrZXkgIT09ICd1cGRhdGUnO1xuICB9KS5ldmVyeShmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIHN0YXRlLmRldGVjdFBvaW50ZXJba2V5XSA9PT0gZmFsc2U7XG4gIH0pKSB7XG4gICAgaWYgKHdpbmRvdy5uYXZpZ2F0b3IgJiYgL2FuZHJvaWQvLnRlc3Qod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKSkpIHtcbiAgICAgIHJldHVybiAndG91Y2hPbmx5JztcbiAgICB9XG4gICAgcmV0dXJuICdoeWJyaWQnO1xuICB9XG5cbiAgLy8gSW4gYWxtb3N0IGFsbCBjYXNlcyBhIGRldmljZSB0aGF0IGRvZXNu4oCZdCBzdXBwb3J0IHRvdWNoIHdpbGwgaGF2ZSBhIG1vdXNlLFxuICAvLyBidXQgdGhlcmUgbWF5IGJlIHJhcmUgZXhjZXB0aW9ucy4gTm90ZSB0aGF0IGl0IGRvZXNu4oCZdCB3b3JrIHRvIGRvIGFkZGl0aW9uYWwgdGVzdHNcbiAgLy8gYmFzZWQgb24gaG92ZXIgYW5kIHBvaW50ZXIgbWVkaWEgcXVlcmllcyBhcyBvbGRlciBicm93c2VycyBkb27igJl0IHN1cHBvcnQgdGhlc2UuXG4gIC8vIEVzc2VudGlhbGx5LCAnbW91c2VPbmx5JyBpcyB0aGUgZGVmYXVsdC5cbiAgcmV0dXJuIGhhc1RvdWNoID8gJ3RvdWNoT25seScgOiAnbW91c2VPbmx5Jztcbn1cblxudmFyIGRldGVjdEl0ID0ge1xuICBzdGF0ZToge1xuICAgIGRldGVjdEhvdmVyOiBfZGV0ZWN0SG92ZXIyLmRlZmF1bHQsXG4gICAgZGV0ZWN0UG9pbnRlcjogX2RldGVjdFBvaW50ZXIyLmRlZmF1bHQsXG4gICAgZGV0ZWN0VG91Y2hFdmVudHM6IF9kZXRlY3RUb3VjaEV2ZW50czIuZGVmYXVsdCxcbiAgICBkZXRlY3RQYXNzaXZlRXZlbnRzOiBfZGV0ZWN0UGFzc2l2ZUV2ZW50czIuZGVmYXVsdFxuICB9LFxuICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICBkZXRlY3RJdC5zdGF0ZS5kZXRlY3RIb3Zlci51cGRhdGUoKTtcbiAgICBkZXRlY3RJdC5zdGF0ZS5kZXRlY3RQb2ludGVyLnVwZGF0ZSgpO1xuICAgIGRldGVjdEl0LnN0YXRlLmRldGVjdFRvdWNoRXZlbnRzLnVwZGF0ZSgpO1xuICAgIGRldGVjdEl0LnN0YXRlLmRldGVjdFBhc3NpdmVFdmVudHMudXBkYXRlKCk7XG4gICAgZGV0ZWN0SXQudXBkYXRlT25seU93blByb3BlcnRpZXMoKTtcbiAgfSxcbiAgdXBkYXRlT25seU93blByb3BlcnRpZXM6IGZ1bmN0aW9uIHVwZGF0ZU9ubHlPd25Qcm9wZXJ0aWVzKCkge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgZGV0ZWN0SXQucGFzc2l2ZUV2ZW50cyA9IGRldGVjdEl0LnN0YXRlLmRldGVjdFBhc3NpdmVFdmVudHMuaGFzU3VwcG9ydCB8fCBmYWxzZTtcblxuICAgICAgZGV0ZWN0SXQuaGFzVG91Y2ggPSBkZXRlY3RJdC5zdGF0ZS5kZXRlY3RUb3VjaEV2ZW50cy5oYXNTdXBwb3J0IHx8IGZhbHNlO1xuXG4gICAgICBkZXRlY3RJdC5kZXZpY2VUeXBlID0gZGV0ZXJtaW5lRGV2aWNlVHlwZShkZXRlY3RJdC5oYXNUb3VjaCwgZGV0ZWN0SXQuc3RhdGUuZGV0ZWN0SG92ZXIuYW55SG92ZXIsIGRldGVjdEl0LnN0YXRlLmRldGVjdFBvaW50ZXIuYW55RmluZSwgZGV0ZWN0SXQuc3RhdGUpO1xuXG4gICAgICBkZXRlY3RJdC5oYXNNb3VzZSA9IGRldGVjdEl0LmRldmljZVR5cGUgIT09ICd0b3VjaE9ubHknO1xuXG4gICAgICBkZXRlY3RJdC5wcmltYXJ5SW5wdXQgPSBkZXRlY3RJdC5kZXZpY2VUeXBlID09PSAnbW91c2VPbmx5JyAmJiAnbW91c2UnIHx8IGRldGVjdEl0LmRldmljZVR5cGUgPT09ICd0b3VjaE9ubHknICYmICd0b3VjaCcgfHxcbiAgICAgIC8vIGRldmljZVR5cGUgaXMgaHlicmlkOlxuICAgICAgZGV0ZWN0SXQuc3RhdGUuZGV0ZWN0SG92ZXIuaG92ZXIgJiYgJ21vdXNlJyB8fCBkZXRlY3RJdC5zdGF0ZS5kZXRlY3RIb3Zlci5ub25lICYmICd0b3VjaCcgfHxcbiAgICAgIC8vIGlmIHRoZXJlJ3Mgbm8gc3VwcG9ydCBmb3IgaG92ZXIgbWVkaWEgcXVlcmllcyBidXQgZGV0ZWN0SXQgZGV0ZXJtaW5lZCBpdCdzXG4gICAgICAvLyBhIGh5YnJpZCAgZGV2aWNlLCB0aGVuIGFzc3VtZSBpdCdzIGEgbW91c2UgZmlyc3QgZGV2aWNlXG4gICAgICAnbW91c2UnO1xuXG4gICAgICAvLyBpc3N1ZSB3aXRoIFdpbmRvd3MgQ2hyb21lIG9uIGh5YnJpZCBkZXZpY2VzIHN0YXJ0aW5nIGluIHZlcnNpb24gNTkgd2hlcmVcbiAgICAgIC8vIG1lZGlhIHF1ZXJpZXMgcmVwcmVzZW50IGEgdG91Y2ggb25seSBkZXZpY2UsIHNvIGlmIHRoZSBicm93c2VyIGlzIGFuXG4gICAgICAvLyBhZmZlY3RlZCBXaW5kb3dzIENocm9tZSB2ZXJzaW9uIGFuZCBoYXNUb3VjaCxcbiAgICAgIC8vIHRoZW4gYXNzdW1lIGl0J3MgYSBoeWJyaWQgd2l0aCBwcmltYXJ5SW5wdXQgbW91c2VcbiAgICAgIC8vIG5vdGUgdGhhdCB2ZXJzaW9uIDYyIG9mIENocm9tZSBmaXhlcyB0aGlzIGlzc3VlXG4gICAgICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3JhZnJleC9kZXRlY3QtaXQvaXNzdWVzLzhcbiAgICAgIHZhciBpblZlcnNpb25SYW5nZSA9IGZ1bmN0aW9uIGluVmVyc2lvblJhbmdlKHZlcnNpb24pIHtcbiAgICAgICAgcmV0dXJuIHZlcnNpb24gPj0gNTkgJiYgdmVyc2lvbiA8IDYyO1xuICAgICAgfTtcbiAgICAgIHZhciBpc0FmZmVjdGVkV2luZG93c0Nocm9tZVZlcnNpb24gPSAvd2luZG93cy8udGVzdCh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpKSAmJiAvY2hyb21lLy50ZXN0KHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkpICYmIGluVmVyc2lvblJhbmdlKHBhcnNlSW50KC9DaHJvbWVcXC8oWzAtOS5dKykvLmV4ZWMobmF2aWdhdG9yLnVzZXJBZ2VudClbMV0sIDEwKSk7XG5cbiAgICAgIGlmIChpc0FmZmVjdGVkV2luZG93c0Nocm9tZVZlcnNpb24gJiYgZGV0ZWN0SXQuaGFzVG91Y2gpIHtcbiAgICAgICAgZGV0ZWN0SXQuZGV2aWNlVHlwZSA9ICdoeWJyaWQnO1xuICAgICAgICBkZXRlY3RJdC5oYXNNb3VzZSA9IHRydWU7XG4gICAgICAgIGRldGVjdEl0LnByaW1hcnlJbnB1dCA9ICdtb3VzZSc7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5kZXRlY3RJdC51cGRhdGVPbmx5T3duUHJvcGVydGllcygpO1xuZXhwb3J0cy5kZWZhdWx0ID0gZGV0ZWN0SXQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZGV0ZWN0LWl0L2xpYi9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNDE2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAyIDQgNSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///416\n");

/***/ }),

/***/ 417:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar detectHover = {\n  update: function update() {\n    if (typeof window !== 'undefined' && typeof window.matchMedia === 'function') {\n      detectHover.hover = window.matchMedia('(hover: hover)').matches;\n      detectHover.none = window.matchMedia('(hover: none)').matches || window.matchMedia('(hover: on-demand)').matches;\n      detectHover.anyHover = window.matchMedia('(any-hover: hover)').matches;\n      detectHover.anyNone = window.matchMedia('(any-hover: none)').matches || window.matchMedia('(any-hover: on-demand)').matches;\n    }\n  }\n};\n\ndetectHover.update();\nexports.default = detectHover;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDE3LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RldGVjdC1ob3Zlci9saWIvaW5kZXguanM/NGJiOSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG52YXIgZGV0ZWN0SG92ZXIgPSB7XG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKCkge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93Lm1hdGNoTWVkaWEgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGRldGVjdEhvdmVyLmhvdmVyID0gd2luZG93Lm1hdGNoTWVkaWEoJyhob3ZlcjogaG92ZXIpJykubWF0Y2hlcztcbiAgICAgIGRldGVjdEhvdmVyLm5vbmUgPSB3aW5kb3cubWF0Y2hNZWRpYSgnKGhvdmVyOiBub25lKScpLm1hdGNoZXMgfHwgd2luZG93Lm1hdGNoTWVkaWEoJyhob3Zlcjogb24tZGVtYW5kKScpLm1hdGNoZXM7XG4gICAgICBkZXRlY3RIb3Zlci5hbnlIb3ZlciA9IHdpbmRvdy5tYXRjaE1lZGlhKCcoYW55LWhvdmVyOiBob3ZlciknKS5tYXRjaGVzO1xuICAgICAgZGV0ZWN0SG92ZXIuYW55Tm9uZSA9IHdpbmRvdy5tYXRjaE1lZGlhKCcoYW55LWhvdmVyOiBub25lKScpLm1hdGNoZXMgfHwgd2luZG93Lm1hdGNoTWVkaWEoJyhhbnktaG92ZXI6IG9uLWRlbWFuZCknKS5tYXRjaGVzO1xuICAgIH1cbiAgfVxufTtcblxuZGV0ZWN0SG92ZXIudXBkYXRlKCk7XG5leHBvcnRzLmRlZmF1bHQgPSBkZXRlY3RIb3ZlcjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9kZXRlY3QtaG92ZXIvbGliL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA0MTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDIgNCA1Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///417\n");

/***/ }),

/***/ 418:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar detectPointer = {\n  update: function update() {\n    if (typeof window !== 'undefined' && typeof window.matchMedia === 'function') {\n      detectPointer.fine = window.matchMedia('(pointer: fine)').matches;\n      detectPointer.coarse = window.matchMedia('(pointer: coarse)').matches;\n      detectPointer.none = window.matchMedia('(pointer: none)').matches;\n      detectPointer.anyFine = window.matchMedia('(any-pointer: fine)').matches;\n      detectPointer.anyCoarse = window.matchMedia('(any-pointer: coarse)').matches;\n      detectPointer.anyNone = window.matchMedia('(any-pointer: none)').matches;\n    }\n  }\n};\n\ndetectPointer.update();\nexports.default = detectPointer;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDE4LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RldGVjdC1wb2ludGVyL2xpYi9pbmRleC5qcz9iNTUzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbnZhciBkZXRlY3RQb2ludGVyID0ge1xuICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5tYXRjaE1lZGlhID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBkZXRlY3RQb2ludGVyLmZpbmUgPSB3aW5kb3cubWF0Y2hNZWRpYSgnKHBvaW50ZXI6IGZpbmUpJykubWF0Y2hlcztcbiAgICAgIGRldGVjdFBvaW50ZXIuY29hcnNlID0gd2luZG93Lm1hdGNoTWVkaWEoJyhwb2ludGVyOiBjb2Fyc2UpJykubWF0Y2hlcztcbiAgICAgIGRldGVjdFBvaW50ZXIubm9uZSA9IHdpbmRvdy5tYXRjaE1lZGlhKCcocG9pbnRlcjogbm9uZSknKS5tYXRjaGVzO1xuICAgICAgZGV0ZWN0UG9pbnRlci5hbnlGaW5lID0gd2luZG93Lm1hdGNoTWVkaWEoJyhhbnktcG9pbnRlcjogZmluZSknKS5tYXRjaGVzO1xuICAgICAgZGV0ZWN0UG9pbnRlci5hbnlDb2Fyc2UgPSB3aW5kb3cubWF0Y2hNZWRpYSgnKGFueS1wb2ludGVyOiBjb2Fyc2UpJykubWF0Y2hlcztcbiAgICAgIGRldGVjdFBvaW50ZXIuYW55Tm9uZSA9IHdpbmRvdy5tYXRjaE1lZGlhKCcoYW55LXBvaW50ZXI6IG5vbmUpJykubWF0Y2hlcztcbiAgICB9XG4gIH1cbn07XG5cbmRldGVjdFBvaW50ZXIudXBkYXRlKCk7XG5leHBvcnRzLmRlZmF1bHQgPSBkZXRlY3RQb2ludGVyO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2RldGVjdC1wb2ludGVyL2xpYi9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNDE4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAyIDQgNSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///418\n");

/***/ }),

/***/ 419:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar detectTouchEvents = {\n  update: function update() {\n    if (typeof window !== 'undefined') {\n      detectTouchEvents.hasSupport = 'ontouchstart' in window;\n      detectTouchEvents.browserSupportsApi = Boolean(window.TouchEvent);\n    }\n  }\n};\n\ndetectTouchEvents.update();\nexports.default = detectTouchEvents;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDE5LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RldGVjdC10b3VjaC1ldmVudHMvbGliL2luZGV4LmpzP2MzOTgiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xudmFyIGRldGVjdFRvdWNoRXZlbnRzID0ge1xuICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGRldGVjdFRvdWNoRXZlbnRzLmhhc1N1cHBvcnQgPSAnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3c7XG4gICAgICBkZXRlY3RUb3VjaEV2ZW50cy5icm93c2VyU3VwcG9ydHNBcGkgPSBCb29sZWFuKHdpbmRvdy5Ub3VjaEV2ZW50KTtcbiAgICB9XG4gIH1cbn07XG5cbmRldGVjdFRvdWNoRXZlbnRzLnVwZGF0ZSgpO1xuZXhwb3J0cy5kZWZhdWx0ID0gZGV0ZWN0VG91Y2hFdmVudHM7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZGV0ZWN0LXRvdWNoLWV2ZW50cy9saWIvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDQxOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMiA0IDUiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///419\n");

/***/ }),

/***/ 420:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n// adapted from https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md\nvar detectPassiveEvents = {\n  update: function update() {\n    if (typeof window !== 'undefined' && typeof window.addEventListener === 'function') {\n      var passive = false;\n      var options = Object.defineProperty({}, 'passive', {\n        get: function get() {\n          passive = true;\n        }\n      });\n      // note: have to set and remove a no-op listener instead of null\n      // (which was used previously), becasue Edge v15 throws an error\n      // when providing a null callback.\n      // https://github.com/rafrex/detect-passive-events/pull/3\n      var noop = function noop() {};\n      window.addEventListener('testPassiveEventSupport', noop, options);\n      window.removeEventListener('testPassiveEventSupport', noop, options);\n      detectPassiveEvents.hasSupport = passive;\n    }\n  }\n};\n\ndetectPassiveEvents.update();\nexports.default = detectPassiveEvents;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDIwLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RldGVjdC1wYXNzaXZlLWV2ZW50cy9saWIvaW5kZXguanM/YWE3OCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG4vLyBhZGFwdGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL1dJQ0cvRXZlbnRMaXN0ZW5lck9wdGlvbnMvYmxvYi9naC1wYWdlcy9leHBsYWluZXIubWRcbnZhciBkZXRlY3RQYXNzaXZlRXZlbnRzID0ge1xuICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YXIgcGFzc2l2ZSA9IGZhbHNlO1xuICAgICAgdmFyIG9wdGlvbnMgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdwYXNzaXZlJywge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICBwYXNzaXZlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICAvLyBub3RlOiBoYXZlIHRvIHNldCBhbmQgcmVtb3ZlIGEgbm8tb3AgbGlzdGVuZXIgaW5zdGVhZCBvZiBudWxsXG4gICAgICAvLyAod2hpY2ggd2FzIHVzZWQgcHJldmlvdXNseSksIGJlY2FzdWUgRWRnZSB2MTUgdGhyb3dzIGFuIGVycm9yXG4gICAgICAvLyB3aGVuIHByb3ZpZGluZyBhIG51bGwgY2FsbGJhY2suXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vcmFmcmV4L2RldGVjdC1wYXNzaXZlLWV2ZW50cy9wdWxsLzNcbiAgICAgIHZhciBub29wID0gZnVuY3Rpb24gbm9vcCgpIHt9O1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Rlc3RQYXNzaXZlRXZlbnRTdXBwb3J0Jywgbm9vcCwgb3B0aW9ucyk7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigndGVzdFBhc3NpdmVFdmVudFN1cHBvcnQnLCBub29wLCBvcHRpb25zKTtcbiAgICAgIGRldGVjdFBhc3NpdmVFdmVudHMuaGFzU3VwcG9ydCA9IHBhc3NpdmU7XG4gICAgfVxuICB9XG59O1xuXG5kZXRlY3RQYXNzaXZlRXZlbnRzLnVwZGF0ZSgpO1xuZXhwb3J0cy5kZWZhdWx0ID0gZGV0ZWN0UGFzc2l2ZUV2ZW50cztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9kZXRlY3QtcGFzc2l2ZS1ldmVudHMvbGliL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA0MjBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDIgNCA1Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///420\n");

/***/ }),

/***/ 421:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = compareProps;\n\nvar _react = __webpack_require__(1);\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _constants = __webpack_require__(367);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// shallow compare of two sets of props, can be called recursivly,\n// returns true if the props are the same, and false if they are not the same\nfunction compareProps(propsA, propsB) {\n  // If children are ReactElements, e.g. JSX as opposed to strings,\n  // they will not be equal even if they are the same because React.createElement(...)\n  // returns a new instance every time and is usually called on every render,\n  // so unless there is a deep compare of the ReactElement tree of children,\n  // it doesn't make sense to continue checking other props.\n  // Note, that when nothing has changed in props,\n  // the only thing that's not equal are the children, so check first.\n  if (propsA.children !== propsB.children) return false;\n\n  var keysB = Object.keys(propsB);\n\n  // don't include forceState when comparing props\n  // forceState is handled in componentWillReceiveProps\n  var nextPOffset = propsB.forceState ? -1 : 0;\n  var pOffset = propsA.forceState ? -1 : 0;\n  if (keysB.length + nextPOffset !== Object.keys(propsA).length + pOffset) return false;\n\n  // if it's an state prop options object, then shallow compare the options for equality\n  var sameStateProp = function sameStateProp(stateProp) {\n    // if propsB doesn't have any of the options object keys, then return false b/c not options obj\n    if (!_constants.statePropOptionKeys.some(function (key) {\n      return propsB[stateProp][key];\n    })) return false;\n    // shallow compare the options for equality\n    return _constants.statePropOptionKeys.every(function (key) {\n      return propsB[stateProp][key] === propsA[stateProp][key];\n    });\n  };\n\n  // loop through props\n  for (var i = 0; i < keysB.length; i++) {\n    // skip if prop is forceState\n    if (keysB[i] !== 'forceState') {\n      // do propsA and propsB both have the property as their own?\n      if (!Object.prototype.hasOwnProperty.call(propsA, keysB[i])) return false;\n      // if the two props aren't equal, do some additional checks before returning false\n      if (propsB[keysB[i]] !== propsA[keysB[i]]) {\n        if (keysB[i] === 'as') {\n          if (_react2.default.isValidElement(propsA.as) && _react2.default.isValidElement(propsB.as)) {\n            // If `as` is JSX/ReactElement, first check to see if `as.type` is the same,\n            // e.g. 'div', 'span', ReactClass, ReactFunctionalComponent, and then shallowly\n            // compare it's props with a recursive call to sameProps - this should only recurse\n            // one time because the JSX/ReactElement shouldn't have the `as` prop.\n            if (propsA.as.type !== propsB.as.type) return false;\n            if (!compareProps(propsA.as.props, propsB.as.props)) return false;\n          } else {\n            return false;\n          }\n          // if the prop is a state, check one level deeper if the props are equal\n        } else if (!(_constants.stateProps[keysB[i]] && sameStateProp(keysB[i]))) {\n          return false;\n        }\n      }\n    }\n  }\n  return true;\n}\nmodule.exports = exports['default'];//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDIxLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWludGVyYWN0aXZlL2xpYi9jb21wYXJlUHJvcHMuanM/YTc0MSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBjb21wYXJlUHJvcHM7XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxudmFyIF9jb25zdGFudHMgPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vLyBzaGFsbG93IGNvbXBhcmUgb2YgdHdvIHNldHMgb2YgcHJvcHMsIGNhbiBiZSBjYWxsZWQgcmVjdXJzaXZseSxcbi8vIHJldHVybnMgdHJ1ZSBpZiB0aGUgcHJvcHMgYXJlIHRoZSBzYW1lLCBhbmQgZmFsc2UgaWYgdGhleSBhcmUgbm90IHRoZSBzYW1lXG5mdW5jdGlvbiBjb21wYXJlUHJvcHMocHJvcHNBLCBwcm9wc0IpIHtcbiAgLy8gSWYgY2hpbGRyZW4gYXJlIFJlYWN0RWxlbWVudHMsIGUuZy4gSlNYIGFzIG9wcG9zZWQgdG8gc3RyaW5ncyxcbiAgLy8gdGhleSB3aWxsIG5vdCBiZSBlcXVhbCBldmVuIGlmIHRoZXkgYXJlIHRoZSBzYW1lIGJlY2F1c2UgUmVhY3QuY3JlYXRlRWxlbWVudCguLi4pXG4gIC8vIHJldHVybnMgYSBuZXcgaW5zdGFuY2UgZXZlcnkgdGltZSBhbmQgaXMgdXN1YWxseSBjYWxsZWQgb24gZXZlcnkgcmVuZGVyLFxuICAvLyBzbyB1bmxlc3MgdGhlcmUgaXMgYSBkZWVwIGNvbXBhcmUgb2YgdGhlIFJlYWN0RWxlbWVudCB0cmVlIG9mIGNoaWxkcmVuLFxuICAvLyBpdCBkb2Vzbid0IG1ha2Ugc2Vuc2UgdG8gY29udGludWUgY2hlY2tpbmcgb3RoZXIgcHJvcHMuXG4gIC8vIE5vdGUsIHRoYXQgd2hlbiBub3RoaW5nIGhhcyBjaGFuZ2VkIGluIHByb3BzLFxuICAvLyB0aGUgb25seSB0aGluZyB0aGF0J3Mgbm90IGVxdWFsIGFyZSB0aGUgY2hpbGRyZW4sIHNvIGNoZWNrIGZpcnN0LlxuICBpZiAocHJvcHNBLmNoaWxkcmVuICE9PSBwcm9wc0IuY2hpbGRyZW4pIHJldHVybiBmYWxzZTtcblxuICB2YXIga2V5c0IgPSBPYmplY3Qua2V5cyhwcm9wc0IpO1xuXG4gIC8vIGRvbid0IGluY2x1ZGUgZm9yY2VTdGF0ZSB3aGVuIGNvbXBhcmluZyBwcm9wc1xuICAvLyBmb3JjZVN0YXRlIGlzIGhhbmRsZWQgaW4gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1xuICB2YXIgbmV4dFBPZmZzZXQgPSBwcm9wc0IuZm9yY2VTdGF0ZSA/IC0xIDogMDtcbiAgdmFyIHBPZmZzZXQgPSBwcm9wc0EuZm9yY2VTdGF0ZSA/IC0xIDogMDtcbiAgaWYgKGtleXNCLmxlbmd0aCArIG5leHRQT2Zmc2V0ICE9PSBPYmplY3Qua2V5cyhwcm9wc0EpLmxlbmd0aCArIHBPZmZzZXQpIHJldHVybiBmYWxzZTtcblxuICAvLyBpZiBpdCdzIGFuIHN0YXRlIHByb3Agb3B0aW9ucyBvYmplY3QsIHRoZW4gc2hhbGxvdyBjb21wYXJlIHRoZSBvcHRpb25zIGZvciBlcXVhbGl0eVxuICB2YXIgc2FtZVN0YXRlUHJvcCA9IGZ1bmN0aW9uIHNhbWVTdGF0ZVByb3Aoc3RhdGVQcm9wKSB7XG4gICAgLy8gaWYgcHJvcHNCIGRvZXNuJ3QgaGF2ZSBhbnkgb2YgdGhlIG9wdGlvbnMgb2JqZWN0IGtleXMsIHRoZW4gcmV0dXJuIGZhbHNlIGIvYyBub3Qgb3B0aW9ucyBvYmpcbiAgICBpZiAoIV9jb25zdGFudHMuc3RhdGVQcm9wT3B0aW9uS2V5cy5zb21lKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHJldHVybiBwcm9wc0Jbc3RhdGVQcm9wXVtrZXldO1xuICAgIH0pKSByZXR1cm4gZmFsc2U7XG4gICAgLy8gc2hhbGxvdyBjb21wYXJlIHRoZSBvcHRpb25zIGZvciBlcXVhbGl0eVxuICAgIHJldHVybiBfY29uc3RhbnRzLnN0YXRlUHJvcE9wdGlvbktleXMuZXZlcnkoZnVuY3Rpb24gKGtleSkge1xuICAgICAgcmV0dXJuIHByb3BzQltzdGF0ZVByb3BdW2tleV0gPT09IHByb3BzQVtzdGF0ZVByb3BdW2tleV07XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gbG9vcCB0aHJvdWdoIHByb3BzXG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5c0IubGVuZ3RoOyBpKyspIHtcbiAgICAvLyBza2lwIGlmIHByb3AgaXMgZm9yY2VTdGF0ZVxuICAgIGlmIChrZXlzQltpXSAhPT0gJ2ZvcmNlU3RhdGUnKSB7XG4gICAgICAvLyBkbyBwcm9wc0EgYW5kIHByb3BzQiBib3RoIGhhdmUgdGhlIHByb3BlcnR5IGFzIHRoZWlyIG93bj9cbiAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzQSwga2V5c0JbaV0pKSByZXR1cm4gZmFsc2U7XG4gICAgICAvLyBpZiB0aGUgdHdvIHByb3BzIGFyZW4ndCBlcXVhbCwgZG8gc29tZSBhZGRpdGlvbmFsIGNoZWNrcyBiZWZvcmUgcmV0dXJuaW5nIGZhbHNlXG4gICAgICBpZiAocHJvcHNCW2tleXNCW2ldXSAhPT0gcHJvcHNBW2tleXNCW2ldXSkge1xuICAgICAgICBpZiAoa2V5c0JbaV0gPT09ICdhcycpIHtcbiAgICAgICAgICBpZiAoX3JlYWN0Mi5kZWZhdWx0LmlzVmFsaWRFbGVtZW50KHByb3BzQS5hcykgJiYgX3JlYWN0Mi5kZWZhdWx0LmlzVmFsaWRFbGVtZW50KHByb3BzQi5hcykpIHtcbiAgICAgICAgICAgIC8vIElmIGBhc2AgaXMgSlNYL1JlYWN0RWxlbWVudCwgZmlyc3QgY2hlY2sgdG8gc2VlIGlmIGBhcy50eXBlYCBpcyB0aGUgc2FtZSxcbiAgICAgICAgICAgIC8vIGUuZy4gJ2RpdicsICdzcGFuJywgUmVhY3RDbGFzcywgUmVhY3RGdW5jdGlvbmFsQ29tcG9uZW50LCBhbmQgdGhlbiBzaGFsbG93bHlcbiAgICAgICAgICAgIC8vIGNvbXBhcmUgaXQncyBwcm9wcyB3aXRoIGEgcmVjdXJzaXZlIGNhbGwgdG8gc2FtZVByb3BzIC0gdGhpcyBzaG91bGQgb25seSByZWN1cnNlXG4gICAgICAgICAgICAvLyBvbmUgdGltZSBiZWNhdXNlIHRoZSBKU1gvUmVhY3RFbGVtZW50IHNob3VsZG4ndCBoYXZlIHRoZSBgYXNgIHByb3AuXG4gICAgICAgICAgICBpZiAocHJvcHNBLmFzLnR5cGUgIT09IHByb3BzQi5hcy50eXBlKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBpZiAoIWNvbXBhcmVQcm9wcyhwcm9wc0EuYXMucHJvcHMsIHByb3BzQi5hcy5wcm9wcykpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBpZiB0aGUgcHJvcCBpcyBhIHN0YXRlLCBjaGVjayBvbmUgbGV2ZWwgZGVlcGVyIGlmIHRoZSBwcm9wcyBhcmUgZXF1YWxcbiAgICAgICAgfSBlbHNlIGlmICghKF9jb25zdGFudHMuc3RhdGVQcm9wc1trZXlzQltpXV0gJiYgc2FtZVN0YXRlUHJvcChrZXlzQltpXSkpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtaW50ZXJhY3RpdmUvbGliL2NvbXBhcmVQcm9wcy5qc1xuLy8gbW9kdWxlIGlkID0gNDIxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAyIDQgNSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///421\n");

/***/ }),

/***/ 422:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = mergeAndExtractProps;\n\nvar _react = __webpack_require__(1);\n\nvar _react2 = _interopRequireDefault(_react);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// extract passThroughProps, and\n// if `as` is a JSX/ReactElement, then merge props with `as`'s props\nfunction mergeAndExtractProps(props, knownProps) {\n  var mergedProps = {};\n  var passThroughProps = {};\n  Object.keys(props).forEach(function (key) {\n    mergedProps[key] = props[key];\n    // pass through all props that are not on the knownProps list\n    if (!knownProps[key]) passThroughProps[key] = props[key];\n  });\n  if (_react2.default.isValidElement(props.as)) {\n    // if `as` is JSX/ReactElement, then merge in it's props\n    Object.keys(props.as.props).forEach(function (key) {\n      mergedProps[key] = props.as.props[key];\n      if (!knownProps[key]) passThroughProps[key] = props.as.props[key];\n    });\n\n    // set `as` to the JSX/ReactElement's `type`:\n    // if the ReactElement is a ReactDOMElement then `type` will be a string, e.g. 'div', 'span'\n    // if the ReactElement is a ReactComponentElement, then `type` will be\n    // either a ReactClass or a ReactFunctionalComponent, e.g. as={<MyComponent />}\n    // https://facebook.github.io/react/docs/glossary.html\n    mergedProps.as = props.as.type;\n  } else {\n    mergedProps.as = props.as;\n  }\n\n  return { mergedProps: mergedProps, passThroughProps: passThroughProps };\n}\nmodule.exports = exports['default'];//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDIyLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWludGVyYWN0aXZlL2xpYi9tZXJnZUFuZEV4dHJhY3RQcm9wcy5qcz83N2Q5Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IG1lcmdlQW5kRXh0cmFjdFByb3BzO1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8vIGV4dHJhY3QgcGFzc1Rocm91Z2hQcm9wcywgYW5kXG4vLyBpZiBgYXNgIGlzIGEgSlNYL1JlYWN0RWxlbWVudCwgdGhlbiBtZXJnZSBwcm9wcyB3aXRoIGBhc2AncyBwcm9wc1xuZnVuY3Rpb24gbWVyZ2VBbmRFeHRyYWN0UHJvcHMocHJvcHMsIGtub3duUHJvcHMpIHtcbiAgdmFyIG1lcmdlZFByb3BzID0ge307XG4gIHZhciBwYXNzVGhyb3VnaFByb3BzID0ge307XG4gIE9iamVjdC5rZXlzKHByb3BzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICBtZXJnZWRQcm9wc1trZXldID0gcHJvcHNba2V5XTtcbiAgICAvLyBwYXNzIHRocm91Z2ggYWxsIHByb3BzIHRoYXQgYXJlIG5vdCBvbiB0aGUga25vd25Qcm9wcyBsaXN0XG4gICAgaWYgKCFrbm93blByb3BzW2tleV0pIHBhc3NUaHJvdWdoUHJvcHNba2V5XSA9IHByb3BzW2tleV07XG4gIH0pO1xuICBpZiAoX3JlYWN0Mi5kZWZhdWx0LmlzVmFsaWRFbGVtZW50KHByb3BzLmFzKSkge1xuICAgIC8vIGlmIGBhc2AgaXMgSlNYL1JlYWN0RWxlbWVudCwgdGhlbiBtZXJnZSBpbiBpdCdzIHByb3BzXG4gICAgT2JqZWN0LmtleXMocHJvcHMuYXMucHJvcHMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgbWVyZ2VkUHJvcHNba2V5XSA9IHByb3BzLmFzLnByb3BzW2tleV07XG4gICAgICBpZiAoIWtub3duUHJvcHNba2V5XSkgcGFzc1Rocm91Z2hQcm9wc1trZXldID0gcHJvcHMuYXMucHJvcHNba2V5XTtcbiAgICB9KTtcblxuICAgIC8vIHNldCBgYXNgIHRvIHRoZSBKU1gvUmVhY3RFbGVtZW50J3MgYHR5cGVgOlxuICAgIC8vIGlmIHRoZSBSZWFjdEVsZW1lbnQgaXMgYSBSZWFjdERPTUVsZW1lbnQgdGhlbiBgdHlwZWAgd2lsbCBiZSBhIHN0cmluZywgZS5nLiAnZGl2JywgJ3NwYW4nXG4gICAgLy8gaWYgdGhlIFJlYWN0RWxlbWVudCBpcyBhIFJlYWN0Q29tcG9uZW50RWxlbWVudCwgdGhlbiBgdHlwZWAgd2lsbCBiZVxuICAgIC8vIGVpdGhlciBhIFJlYWN0Q2xhc3Mgb3IgYSBSZWFjdEZ1bmN0aW9uYWxDb21wb25lbnQsIGUuZy4gYXM9ezxNeUNvbXBvbmVudCAvPn1cbiAgICAvLyBodHRwczovL2ZhY2Vib29rLmdpdGh1Yi5pby9yZWFjdC9kb2NzL2dsb3NzYXJ5Lmh0bWxcbiAgICBtZXJnZWRQcm9wcy5hcyA9IHByb3BzLmFzLnR5cGU7XG4gIH0gZWxzZSB7XG4gICAgbWVyZ2VkUHJvcHMuYXMgPSBwcm9wcy5hcztcbiAgfVxuXG4gIHJldHVybiB7IG1lcmdlZFByb3BzOiBtZXJnZWRQcm9wcywgcGFzc1Rocm91Z2hQcm9wczogcGFzc1Rocm91Z2hQcm9wcyB9O1xufVxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtaW50ZXJhY3RpdmUvbGliL21lcmdlQW5kRXh0cmFjdFByb3BzLmpzXG4vLyBtb2R1bGUgaWQgPSA0MjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDIgNCA1Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///422\n");

/***/ }),

/***/ 423:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nexports.extractStyle = extractStyle;\nexports.setActiveAndFocusProps = setActiveAndFocusProps;\nexports.joinClasses = joinClasses;\n\nvar _constants = __webpack_require__(367);\n\n// extract and return the style object and className string for the state given\nfunction extractStyle(props, state) {\n  // if no hoverActive prop, then use hover prop for style and classes\n  var stateProp = state === 'hoverActive' && !props.hoverActive ? 'hover' : state;\n  // loop until the state prop to use is found (i.e. it's not a string)\n  var times = 0;\n  while (typeof stateProp === 'string' && times < 10) {\n    stateProp = props[stateProp];\n    times++;\n  }\n  // if the state prop to use wasn't found, then return a blank style and className object\n  if ((typeof stateProp === 'undefined' ? 'undefined' : _typeof(stateProp)) !== 'object') return { style: null, className: '' };\n\n  var extract = {};\n  // check if the stateProp is an options object, and extract style and className from the stateProp\n  if (_constants.statePropOptionKeys.some(function (key) {\n    return stateProp[key];\n  })) {\n    extract.style = stateProp.style || null;\n    extract.className = stateProp.className || '';\n  } else {\n    // if the stateProp is not an options object, then it's a style object\n    extract.style = stateProp;\n    extract.className = '';\n  }\n\n  return extract;\n}\n\nfunction setActiveAndFocusProps(props) {\n  // use the `active` prop for `[type]Active` if no `[type]Active` prop\n  if (props.active) {\n    if (!props.hoverActive) props.hoverActive = props.active;\n    if (!props.touchActive) props.touchActive = props.active;\n    if (!props.keyActive) props.keyActive = props.active;\n  }\n\n  // use the `focus` prop for `focusFrom[type]` if no `focusFrom[type]` prop\n  if (props.focus) {\n    if (!props.focusFromTab) props.focusFromTab = props.focus;\n    if (!props.focusFromMouse) props.focusFromMouse = props.focus;\n    if (!props.focusFromTouch) props.focusFromTouch = props.focus;\n  }\n}\n\nfunction joinClasses(className, iStateClass, focusClass) {\n  var joined = className;\n  joined += joined && iStateClass ? ' ' + iStateClass : '' + iStateClass;\n  joined += joined && focusClass ? ' ' + focusClass : '' + focusClass;\n  return joined;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDIzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWludGVyYWN0aXZlL2xpYi9leHRyYWN0U3R5bGUuanM/MGQzZSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuZXhwb3J0cy5leHRyYWN0U3R5bGUgPSBleHRyYWN0U3R5bGU7XG5leHBvcnRzLnNldEFjdGl2ZUFuZEZvY3VzUHJvcHMgPSBzZXRBY3RpdmVBbmRGb2N1c1Byb3BzO1xuZXhwb3J0cy5qb2luQ2xhc3NlcyA9IGpvaW5DbGFzc2VzO1xuXG52YXIgX2NvbnN0YW50cyA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyk7XG5cbi8vIGV4dHJhY3QgYW5kIHJldHVybiB0aGUgc3R5bGUgb2JqZWN0IGFuZCBjbGFzc05hbWUgc3RyaW5nIGZvciB0aGUgc3RhdGUgZ2l2ZW5cbmZ1bmN0aW9uIGV4dHJhY3RTdHlsZShwcm9wcywgc3RhdGUpIHtcbiAgLy8gaWYgbm8gaG92ZXJBY3RpdmUgcHJvcCwgdGhlbiB1c2UgaG92ZXIgcHJvcCBmb3Igc3R5bGUgYW5kIGNsYXNzZXNcbiAgdmFyIHN0YXRlUHJvcCA9IHN0YXRlID09PSAnaG92ZXJBY3RpdmUnICYmICFwcm9wcy5ob3ZlckFjdGl2ZSA/ICdob3ZlcicgOiBzdGF0ZTtcbiAgLy8gbG9vcCB1bnRpbCB0aGUgc3RhdGUgcHJvcCB0byB1c2UgaXMgZm91bmQgKGkuZS4gaXQncyBub3QgYSBzdHJpbmcpXG4gIHZhciB0aW1lcyA9IDA7XG4gIHdoaWxlICh0eXBlb2Ygc3RhdGVQcm9wID09PSAnc3RyaW5nJyAmJiB0aW1lcyA8IDEwKSB7XG4gICAgc3RhdGVQcm9wID0gcHJvcHNbc3RhdGVQcm9wXTtcbiAgICB0aW1lcysrO1xuICB9XG4gIC8vIGlmIHRoZSBzdGF0ZSBwcm9wIHRvIHVzZSB3YXNuJ3QgZm91bmQsIHRoZW4gcmV0dXJuIGEgYmxhbmsgc3R5bGUgYW5kIGNsYXNzTmFtZSBvYmplY3RcbiAgaWYgKCh0eXBlb2Ygc3RhdGVQcm9wID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihzdGF0ZVByb3ApKSAhPT0gJ29iamVjdCcpIHJldHVybiB7IHN0eWxlOiBudWxsLCBjbGFzc05hbWU6ICcnIH07XG5cbiAgdmFyIGV4dHJhY3QgPSB7fTtcbiAgLy8gY2hlY2sgaWYgdGhlIHN0YXRlUHJvcCBpcyBhbiBvcHRpb25zIG9iamVjdCwgYW5kIGV4dHJhY3Qgc3R5bGUgYW5kIGNsYXNzTmFtZSBmcm9tIHRoZSBzdGF0ZVByb3BcbiAgaWYgKF9jb25zdGFudHMuc3RhdGVQcm9wT3B0aW9uS2V5cy5zb21lKGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gc3RhdGVQcm9wW2tleV07XG4gIH0pKSB7XG4gICAgZXh0cmFjdC5zdHlsZSA9IHN0YXRlUHJvcC5zdHlsZSB8fCBudWxsO1xuICAgIGV4dHJhY3QuY2xhc3NOYW1lID0gc3RhdGVQcm9wLmNsYXNzTmFtZSB8fCAnJztcbiAgfSBlbHNlIHtcbiAgICAvLyBpZiB0aGUgc3RhdGVQcm9wIGlzIG5vdCBhbiBvcHRpb25zIG9iamVjdCwgdGhlbiBpdCdzIGEgc3R5bGUgb2JqZWN0XG4gICAgZXh0cmFjdC5zdHlsZSA9IHN0YXRlUHJvcDtcbiAgICBleHRyYWN0LmNsYXNzTmFtZSA9ICcnO1xuICB9XG5cbiAgcmV0dXJuIGV4dHJhY3Q7XG59XG5cbmZ1bmN0aW9uIHNldEFjdGl2ZUFuZEZvY3VzUHJvcHMocHJvcHMpIHtcbiAgLy8gdXNlIHRoZSBgYWN0aXZlYCBwcm9wIGZvciBgW3R5cGVdQWN0aXZlYCBpZiBubyBgW3R5cGVdQWN0aXZlYCBwcm9wXG4gIGlmIChwcm9wcy5hY3RpdmUpIHtcbiAgICBpZiAoIXByb3BzLmhvdmVyQWN0aXZlKSBwcm9wcy5ob3ZlckFjdGl2ZSA9IHByb3BzLmFjdGl2ZTtcbiAgICBpZiAoIXByb3BzLnRvdWNoQWN0aXZlKSBwcm9wcy50b3VjaEFjdGl2ZSA9IHByb3BzLmFjdGl2ZTtcbiAgICBpZiAoIXByb3BzLmtleUFjdGl2ZSkgcHJvcHMua2V5QWN0aXZlID0gcHJvcHMuYWN0aXZlO1xuICB9XG5cbiAgLy8gdXNlIHRoZSBgZm9jdXNgIHByb3AgZm9yIGBmb2N1c0Zyb21bdHlwZV1gIGlmIG5vIGBmb2N1c0Zyb21bdHlwZV1gIHByb3BcbiAgaWYgKHByb3BzLmZvY3VzKSB7XG4gICAgaWYgKCFwcm9wcy5mb2N1c0Zyb21UYWIpIHByb3BzLmZvY3VzRnJvbVRhYiA9IHByb3BzLmZvY3VzO1xuICAgIGlmICghcHJvcHMuZm9jdXNGcm9tTW91c2UpIHByb3BzLmZvY3VzRnJvbU1vdXNlID0gcHJvcHMuZm9jdXM7XG4gICAgaWYgKCFwcm9wcy5mb2N1c0Zyb21Ub3VjaCkgcHJvcHMuZm9jdXNGcm9tVG91Y2ggPSBwcm9wcy5mb2N1cztcbiAgfVxufVxuXG5mdW5jdGlvbiBqb2luQ2xhc3NlcyhjbGFzc05hbWUsIGlTdGF0ZUNsYXNzLCBmb2N1c0NsYXNzKSB7XG4gIHZhciBqb2luZWQgPSBjbGFzc05hbWU7XG4gIGpvaW5lZCArPSBqb2luZWQgJiYgaVN0YXRlQ2xhc3MgPyAnICcgKyBpU3RhdGVDbGFzcyA6ICcnICsgaVN0YXRlQ2xhc3M7XG4gIGpvaW5lZCArPSBqb2luZWQgJiYgZm9jdXNDbGFzcyA/ICcgJyArIGZvY3VzQ2xhc3MgOiAnJyArIGZvY3VzQ2xhc3M7XG4gIHJldHVybiBqb2luZWQ7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtaW50ZXJhY3RpdmUvbGliL2V4dHJhY3RTdHlsZS5qc1xuLy8gbW9kdWxlIGlkID0gNDIzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAyIDQgNSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///423\n");

/***/ }),

/***/ 424:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = recursiveNodeCheck;\n// check the node and all of its children\n// returns true if the check function returns true for the node\n// or any of its children, returns false otherwise\nfunction recursiveNodeCheck(node, check) {\n  if (check(node)) return true;\n  for (var i = 0; i < node.children.length; i++) {\n    if (recursiveNodeCheck(node.children[i], check)) return true;\n  }\n  return false;\n}\nmodule.exports = exports[\"default\"];//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDI0LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWludGVyYWN0aXZlL2xpYi9yZWN1cnNpdmVOb2RlQ2hlY2suanM/MmE3MCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHJlY3Vyc2l2ZU5vZGVDaGVjaztcbi8vIGNoZWNrIHRoZSBub2RlIGFuZCBhbGwgb2YgaXRzIGNoaWxkcmVuXG4vLyByZXR1cm5zIHRydWUgaWYgdGhlIGNoZWNrIGZ1bmN0aW9uIHJldHVybnMgdHJ1ZSBmb3IgdGhlIG5vZGVcbi8vIG9yIGFueSBvZiBpdHMgY2hpbGRyZW4sIHJldHVybnMgZmFsc2Ugb3RoZXJ3aXNlXG5mdW5jdGlvbiByZWN1cnNpdmVOb2RlQ2hlY2sobm9kZSwgY2hlY2spIHtcbiAgaWYgKGNoZWNrKG5vZGUpKSByZXR1cm4gdHJ1ZTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHJlY3Vyc2l2ZU5vZGVDaGVjayhub2RlLmNoaWxkcmVuW2ldLCBjaGVjaykpIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1tcImRlZmF1bHRcIl07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtaW50ZXJhY3RpdmUvbGliL3JlY3Vyc2l2ZU5vZGVDaGVjay5qc1xuLy8gbW9kdWxlIGlkID0gNDI0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAyIDQgNSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///424\n");

/***/ }),

/***/ 425:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.focusRegistry = undefined;\nexports.updateMouseFromRI = updateMouseFromRI;\n\nvar _notifier = __webpack_require__(380);\n\nvar _constants = __webpack_require__(367);\n\n// the shape of what's being tracked globally\n// the input object is the default export\nvar input = {\n  mouse: {\n    mouseOnDocument: false,\n    clientX: 0,\n    clientY: 0,\n    buttons: 0\n  },\n  touch: {\n    touchOnScreen: false,\n    recentTouch: false\n  },\n  key: {\n    recentEnterKeyDown: false\n  }\n};\n\n// update touch input tracking\nvar touchTimerID = null;\nfunction updateTouch(e) {\n  if (e.type === 'touchstart') {\n    input.touch.touchOnScreen = true;\n    input.mouse.mouseOnDocument = false;\n  } else if (e.type === 'touchend' || e.type === 'touchcancel') {\n    input.touch.recentTouch = true;\n    if (touchTimerID) window.clearTimeout(touchTimerID);\n    touchTimerID = window.setTimeout(function () {\n      input.touch.recentTouch = false;\n      touchTimerID = null;\n    }, _constants.queueTime);\n  }\n\n  if (e.touches.length === 0) {\n    input.touch.touchOnScreen = false;\n  }\n}\n\n// update mouse input tracking\nfunction updateMouse(e) {\n  input.mouse.clientX = e.clientX;\n  input.mouse.clientY = e.clientY;\n  input.mouse.buttons = e.buttons;\n  if (e.type === 'mouseleave') input.mouse.mouseOnDocument = false;else input.mouse.mouseOnDocument = true;\n}\n\n// only update mouse if the mouse event is not from a touch event\nfunction updateHybridMouse(e) {\n  if (input.touch.recentTouch || input.touch.touchOnScreen) return;\n  updateMouse(e);\n}\n\n// update recent enter keydown tracking, used for form submission detection\nvar enterKeyDownTimerID = null;\nfunction updateEnterKeyDown(e) {\n  if (e.key === 'Enter') {\n    input.key.recentEnterKeyDown = true;\n    if (enterKeyDownTimerID) window.clearTimeout(enterKeyDownTimerID);\n    enterKeyDownTimerID = window.setTimeout(function () {\n      input.key.recentEnterKeyDown = false;\n      enterKeyDownTimerID = null;\n    }, _constants.queueTime);\n  }\n}\n\n// update mouse from RI - this is required for enter and leave events from RI elements\n// because when the mouse is moved onto an RI element the most recent mousemove event\n// will have the mouse coordinates as off the element, so need to get updated coordinates\n// from the react event\nfunction updateMouseFromRI(e) {\n  updateMouse(e);\n  input.mouse.mouseOnDocument = true;\n}\n\n// sign up for notification of touch events if the device supports the touch events api\nif (_constants.deviceHasTouch) {\n  (0, _notifier.notifyOfAll)(Object.keys(_constants.touchEvents), updateTouch);\n}\n\n// sign up for notification of mouse events if the device has a mouse\nif (_constants.deviceHasMouse) {\n  (0, _notifier.notifyOfAll)(Object.keys(_constants.mouseEvents), _constants.deviceType === 'hybrid' ? updateHybridMouse : updateMouse);\n}\n\n// sign up for notification of enter keydown events for form submission detection\n(0, _notifier.notifyOfAll)(['keydown'], updateEnterKeyDown);\n\n// focus registry used by RI to track events that cause focus/blur calls (e.g. mousedown)\n// so focus/blur is not called twice as event bubbles through nested RIs\nvar focusRegistry = exports.focusRegistry = {\n  focus: null,\n  blur: null\n};\n\nexports.default = input;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDI1LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWludGVyYWN0aXZlL2xpYi9pbnB1dFRyYWNrZXIuanM/ZDAyYyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmZvY3VzUmVnaXN0cnkgPSB1bmRlZmluZWQ7XG5leHBvcnRzLnVwZGF0ZU1vdXNlRnJvbVJJID0gdXBkYXRlTW91c2VGcm9tUkk7XG5cbnZhciBfbm90aWZpZXIgPSByZXF1aXJlKCcuL25vdGlmaWVyJyk7XG5cbnZhciBfY29uc3RhbnRzID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcblxuLy8gdGhlIHNoYXBlIG9mIHdoYXQncyBiZWluZyB0cmFja2VkIGdsb2JhbGx5XG4vLyB0aGUgaW5wdXQgb2JqZWN0IGlzIHRoZSBkZWZhdWx0IGV4cG9ydFxudmFyIGlucHV0ID0ge1xuICBtb3VzZToge1xuICAgIG1vdXNlT25Eb2N1bWVudDogZmFsc2UsXG4gICAgY2xpZW50WDogMCxcbiAgICBjbGllbnRZOiAwLFxuICAgIGJ1dHRvbnM6IDBcbiAgfSxcbiAgdG91Y2g6IHtcbiAgICB0b3VjaE9uU2NyZWVuOiBmYWxzZSxcbiAgICByZWNlbnRUb3VjaDogZmFsc2VcbiAgfSxcbiAga2V5OiB7XG4gICAgcmVjZW50RW50ZXJLZXlEb3duOiBmYWxzZVxuICB9XG59O1xuXG4vLyB1cGRhdGUgdG91Y2ggaW5wdXQgdHJhY2tpbmdcbnZhciB0b3VjaFRpbWVySUQgPSBudWxsO1xuZnVuY3Rpb24gdXBkYXRlVG91Y2goZSkge1xuICBpZiAoZS50eXBlID09PSAndG91Y2hzdGFydCcpIHtcbiAgICBpbnB1dC50b3VjaC50b3VjaE9uU2NyZWVuID0gdHJ1ZTtcbiAgICBpbnB1dC5tb3VzZS5tb3VzZU9uRG9jdW1lbnQgPSBmYWxzZTtcbiAgfSBlbHNlIGlmIChlLnR5cGUgPT09ICd0b3VjaGVuZCcgfHwgZS50eXBlID09PSAndG91Y2hjYW5jZWwnKSB7XG4gICAgaW5wdXQudG91Y2gucmVjZW50VG91Y2ggPSB0cnVlO1xuICAgIGlmICh0b3VjaFRpbWVySUQpIHdpbmRvdy5jbGVhclRpbWVvdXQodG91Y2hUaW1lcklEKTtcbiAgICB0b3VjaFRpbWVySUQgPSB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBpbnB1dC50b3VjaC5yZWNlbnRUb3VjaCA9IGZhbHNlO1xuICAgICAgdG91Y2hUaW1lcklEID0gbnVsbDtcbiAgICB9LCBfY29uc3RhbnRzLnF1ZXVlVGltZSk7XG4gIH1cblxuICBpZiAoZS50b3VjaGVzLmxlbmd0aCA9PT0gMCkge1xuICAgIGlucHV0LnRvdWNoLnRvdWNoT25TY3JlZW4gPSBmYWxzZTtcbiAgfVxufVxuXG4vLyB1cGRhdGUgbW91c2UgaW5wdXQgdHJhY2tpbmdcbmZ1bmN0aW9uIHVwZGF0ZU1vdXNlKGUpIHtcbiAgaW5wdXQubW91c2UuY2xpZW50WCA9IGUuY2xpZW50WDtcbiAgaW5wdXQubW91c2UuY2xpZW50WSA9IGUuY2xpZW50WTtcbiAgaW5wdXQubW91c2UuYnV0dG9ucyA9IGUuYnV0dG9ucztcbiAgaWYgKGUudHlwZSA9PT0gJ21vdXNlbGVhdmUnKSBpbnB1dC5tb3VzZS5tb3VzZU9uRG9jdW1lbnQgPSBmYWxzZTtlbHNlIGlucHV0Lm1vdXNlLm1vdXNlT25Eb2N1bWVudCA9IHRydWU7XG59XG5cbi8vIG9ubHkgdXBkYXRlIG1vdXNlIGlmIHRoZSBtb3VzZSBldmVudCBpcyBub3QgZnJvbSBhIHRvdWNoIGV2ZW50XG5mdW5jdGlvbiB1cGRhdGVIeWJyaWRNb3VzZShlKSB7XG4gIGlmIChpbnB1dC50b3VjaC5yZWNlbnRUb3VjaCB8fCBpbnB1dC50b3VjaC50b3VjaE9uU2NyZWVuKSByZXR1cm47XG4gIHVwZGF0ZU1vdXNlKGUpO1xufVxuXG4vLyB1cGRhdGUgcmVjZW50IGVudGVyIGtleWRvd24gdHJhY2tpbmcsIHVzZWQgZm9yIGZvcm0gc3VibWlzc2lvbiBkZXRlY3Rpb25cbnZhciBlbnRlcktleURvd25UaW1lcklEID0gbnVsbDtcbmZ1bmN0aW9uIHVwZGF0ZUVudGVyS2V5RG93bihlKSB7XG4gIGlmIChlLmtleSA9PT0gJ0VudGVyJykge1xuICAgIGlucHV0LmtleS5yZWNlbnRFbnRlcktleURvd24gPSB0cnVlO1xuICAgIGlmIChlbnRlcktleURvd25UaW1lcklEKSB3aW5kb3cuY2xlYXJUaW1lb3V0KGVudGVyS2V5RG93blRpbWVySUQpO1xuICAgIGVudGVyS2V5RG93blRpbWVySUQgPSB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBpbnB1dC5rZXkucmVjZW50RW50ZXJLZXlEb3duID0gZmFsc2U7XG4gICAgICBlbnRlcktleURvd25UaW1lcklEID0gbnVsbDtcbiAgICB9LCBfY29uc3RhbnRzLnF1ZXVlVGltZSk7XG4gIH1cbn1cblxuLy8gdXBkYXRlIG1vdXNlIGZyb20gUkkgLSB0aGlzIGlzIHJlcXVpcmVkIGZvciBlbnRlciBhbmQgbGVhdmUgZXZlbnRzIGZyb20gUkkgZWxlbWVudHNcbi8vIGJlY2F1c2Ugd2hlbiB0aGUgbW91c2UgaXMgbW92ZWQgb250byBhbiBSSSBlbGVtZW50IHRoZSBtb3N0IHJlY2VudCBtb3VzZW1vdmUgZXZlbnRcbi8vIHdpbGwgaGF2ZSB0aGUgbW91c2UgY29vcmRpbmF0ZXMgYXMgb2ZmIHRoZSBlbGVtZW50LCBzbyBuZWVkIHRvIGdldCB1cGRhdGVkIGNvb3JkaW5hdGVzXG4vLyBmcm9tIHRoZSByZWFjdCBldmVudFxuZnVuY3Rpb24gdXBkYXRlTW91c2VGcm9tUkkoZSkge1xuICB1cGRhdGVNb3VzZShlKTtcbiAgaW5wdXQubW91c2UubW91c2VPbkRvY3VtZW50ID0gdHJ1ZTtcbn1cblxuLy8gc2lnbiB1cCBmb3Igbm90aWZpY2F0aW9uIG9mIHRvdWNoIGV2ZW50cyBpZiB0aGUgZGV2aWNlIHN1cHBvcnRzIHRoZSB0b3VjaCBldmVudHMgYXBpXG5pZiAoX2NvbnN0YW50cy5kZXZpY2VIYXNUb3VjaCkge1xuICAoMCwgX25vdGlmaWVyLm5vdGlmeU9mQWxsKShPYmplY3Qua2V5cyhfY29uc3RhbnRzLnRvdWNoRXZlbnRzKSwgdXBkYXRlVG91Y2gpO1xufVxuXG4vLyBzaWduIHVwIGZvciBub3RpZmljYXRpb24gb2YgbW91c2UgZXZlbnRzIGlmIHRoZSBkZXZpY2UgaGFzIGEgbW91c2VcbmlmIChfY29uc3RhbnRzLmRldmljZUhhc01vdXNlKSB7XG4gICgwLCBfbm90aWZpZXIubm90aWZ5T2ZBbGwpKE9iamVjdC5rZXlzKF9jb25zdGFudHMubW91c2VFdmVudHMpLCBfY29uc3RhbnRzLmRldmljZVR5cGUgPT09ICdoeWJyaWQnID8gdXBkYXRlSHlicmlkTW91c2UgOiB1cGRhdGVNb3VzZSk7XG59XG5cbi8vIHNpZ24gdXAgZm9yIG5vdGlmaWNhdGlvbiBvZiBlbnRlciBrZXlkb3duIGV2ZW50cyBmb3IgZm9ybSBzdWJtaXNzaW9uIGRldGVjdGlvblxuKDAsIF9ub3RpZmllci5ub3RpZnlPZkFsbCkoWydrZXlkb3duJ10sIHVwZGF0ZUVudGVyS2V5RG93bik7XG5cbi8vIGZvY3VzIHJlZ2lzdHJ5IHVzZWQgYnkgUkkgdG8gdHJhY2sgZXZlbnRzIHRoYXQgY2F1c2UgZm9jdXMvYmx1ciBjYWxscyAoZS5nLiBtb3VzZWRvd24pXG4vLyBzbyBmb2N1cy9ibHVyIGlzIG5vdCBjYWxsZWQgdHdpY2UgYXMgZXZlbnQgYnViYmxlcyB0aHJvdWdoIG5lc3RlZCBSSXNcbnZhciBmb2N1c1JlZ2lzdHJ5ID0gZXhwb3J0cy5mb2N1c1JlZ2lzdHJ5ID0ge1xuICBmb2N1czogbnVsbCxcbiAgYmx1cjogbnVsbFxufTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gaW5wdXQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtaW50ZXJhY3RpdmUvbGliL2lucHV0VHJhY2tlci5qc1xuLy8gbW9kdWxlIGlkID0gNDI1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAyIDQgNSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///425\n");

/***/ }),

/***/ 426:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = syntheticClick;\n\nvar _notifier = __webpack_require__(380);\n\nvar _constants = __webpack_require__(367);\n\nvar blockClick = false;\nvar blockClickTimerID = null;\nvar blockClickCounter = 0;\n\n// call node.click() on tap, and block a subsequent click fired by the browser if there is one,\n// note that blocking the subsequent click event fired by the browser is required because\n// when the tap/node.click() call results in a change to the layout of the DOM,\n// e.g. hide something, the subsequent click event fired by the browser will land\n// on the DOM in it's new layout, and if where the tap occurred now has something different\n// that has a click handler, e.g. a link, then the subsequent click event will land on\n// and trigger the click handler, which is very bad, so it needs to be blocked.\nfunction syntheticClick(node) {\n  // only block one subsequent click event per node.click() call\n  blockClickCounter++;\n  if (blockClickTimerID !== null) window.clearTimeout(blockClickTimerID);\n  blockClick = false;\n  node.click();\n  blockClick = true;\n  // reset click blocking if subsequent click isn't added to browser's queue w/in queueTime\n  blockClickTimerID = window.setTimeout(function () {\n    blockClick = false;\n    blockClickCounter = 0;\n    blockClickTimerID = null;\n  }, _constants.queueTime);\n}\n\nfunction handleClick(e) {\n  if (!blockClick) return;\n  e.stopPropagation();\n  e.preventDefault();\n  blockClickCounter--;\n  // reset click blocking if the number of clicks to block is met\n  if (blockClickCounter === 0) {\n    blockClick = false;\n    if (blockClickTimerID !== null) {\n      window.clearTimeout(blockClickTimerID);\n      blockClickTimerID = null;\n    }\n  }\n}\n\n// only required for touch devices because called on touchend tap to control tapClick\nif (_constants.deviceHasTouch) (0, _notifier.notifyOfAll)(['click'], handleClick);\nmodule.exports = exports['default'];//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDI2LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWludGVyYWN0aXZlL2xpYi9zeW50aGV0aWNDbGljay5qcz81OGU1Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHN5bnRoZXRpY0NsaWNrO1xuXG52YXIgX25vdGlmaWVyID0gcmVxdWlyZSgnLi9ub3RpZmllcicpO1xuXG52YXIgX2NvbnN0YW50cyA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyk7XG5cbnZhciBibG9ja0NsaWNrID0gZmFsc2U7XG52YXIgYmxvY2tDbGlja1RpbWVySUQgPSBudWxsO1xudmFyIGJsb2NrQ2xpY2tDb3VudGVyID0gMDtcblxuLy8gY2FsbCBub2RlLmNsaWNrKCkgb24gdGFwLCBhbmQgYmxvY2sgYSBzdWJzZXF1ZW50IGNsaWNrIGZpcmVkIGJ5IHRoZSBicm93c2VyIGlmIHRoZXJlIGlzIG9uZSxcbi8vIG5vdGUgdGhhdCBibG9ja2luZyB0aGUgc3Vic2VxdWVudCBjbGljayBldmVudCBmaXJlZCBieSB0aGUgYnJvd3NlciBpcyByZXF1aXJlZCBiZWNhdXNlXG4vLyB3aGVuIHRoZSB0YXAvbm9kZS5jbGljaygpIGNhbGwgcmVzdWx0cyBpbiBhIGNoYW5nZSB0byB0aGUgbGF5b3V0IG9mIHRoZSBET00sXG4vLyBlLmcuIGhpZGUgc29tZXRoaW5nLCB0aGUgc3Vic2VxdWVudCBjbGljayBldmVudCBmaXJlZCBieSB0aGUgYnJvd3NlciB3aWxsIGxhbmRcbi8vIG9uIHRoZSBET00gaW4gaXQncyBuZXcgbGF5b3V0LCBhbmQgaWYgd2hlcmUgdGhlIHRhcCBvY2N1cnJlZCBub3cgaGFzIHNvbWV0aGluZyBkaWZmZXJlbnRcbi8vIHRoYXQgaGFzIGEgY2xpY2sgaGFuZGxlciwgZS5nLiBhIGxpbmssIHRoZW4gdGhlIHN1YnNlcXVlbnQgY2xpY2sgZXZlbnQgd2lsbCBsYW5kIG9uXG4vLyBhbmQgdHJpZ2dlciB0aGUgY2xpY2sgaGFuZGxlciwgd2hpY2ggaXMgdmVyeSBiYWQsIHNvIGl0IG5lZWRzIHRvIGJlIGJsb2NrZWQuXG5mdW5jdGlvbiBzeW50aGV0aWNDbGljayhub2RlKSB7XG4gIC8vIG9ubHkgYmxvY2sgb25lIHN1YnNlcXVlbnQgY2xpY2sgZXZlbnQgcGVyIG5vZGUuY2xpY2soKSBjYWxsXG4gIGJsb2NrQ2xpY2tDb3VudGVyKys7XG4gIGlmIChibG9ja0NsaWNrVGltZXJJRCAhPT0gbnVsbCkgd2luZG93LmNsZWFyVGltZW91dChibG9ja0NsaWNrVGltZXJJRCk7XG4gIGJsb2NrQ2xpY2sgPSBmYWxzZTtcbiAgbm9kZS5jbGljaygpO1xuICBibG9ja0NsaWNrID0gdHJ1ZTtcbiAgLy8gcmVzZXQgY2xpY2sgYmxvY2tpbmcgaWYgc3Vic2VxdWVudCBjbGljayBpc24ndCBhZGRlZCB0byBicm93c2VyJ3MgcXVldWUgdy9pbiBxdWV1ZVRpbWVcbiAgYmxvY2tDbGlja1RpbWVySUQgPSB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgYmxvY2tDbGljayA9IGZhbHNlO1xuICAgIGJsb2NrQ2xpY2tDb3VudGVyID0gMDtcbiAgICBibG9ja0NsaWNrVGltZXJJRCA9IG51bGw7XG4gIH0sIF9jb25zdGFudHMucXVldWVUaW1lKTtcbn1cblxuZnVuY3Rpb24gaGFuZGxlQ2xpY2soZSkge1xuICBpZiAoIWJsb2NrQ2xpY2spIHJldHVybjtcbiAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICBibG9ja0NsaWNrQ291bnRlci0tO1xuICAvLyByZXNldCBjbGljayBibG9ja2luZyBpZiB0aGUgbnVtYmVyIG9mIGNsaWNrcyB0byBibG9jayBpcyBtZXRcbiAgaWYgKGJsb2NrQ2xpY2tDb3VudGVyID09PSAwKSB7XG4gICAgYmxvY2tDbGljayA9IGZhbHNlO1xuICAgIGlmIChibG9ja0NsaWNrVGltZXJJRCAhPT0gbnVsbCkge1xuICAgICAgd2luZG93LmNsZWFyVGltZW91dChibG9ja0NsaWNrVGltZXJJRCk7XG4gICAgICBibG9ja0NsaWNrVGltZXJJRCA9IG51bGw7XG4gICAgfVxuICB9XG59XG5cbi8vIG9ubHkgcmVxdWlyZWQgZm9yIHRvdWNoIGRldmljZXMgYmVjYXVzZSBjYWxsZWQgb24gdG91Y2hlbmQgdGFwIHRvIGNvbnRyb2wgdGFwQ2xpY2tcbmlmIChfY29uc3RhbnRzLmRldmljZUhhc1RvdWNoKSAoMCwgX25vdGlmaWVyLm5vdGlmeU9mQWxsKShbJ2NsaWNrJ10sIGhhbmRsZUNsaWNrKTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LWludGVyYWN0aXZlL2xpYi9zeW50aGV0aWNDbGljay5qc1xuLy8gbW9kdWxlIGlkID0gNDI2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAyIDQgNSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///426\n");

/***/ })

});